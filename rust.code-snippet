{
  "kyopro": [
    {
      "prefix": "usize_tools.rs",
      "body": [
        "pub trait UsizeTools {",
        "\tfn abs_diff(&self, other: Self) -> Self;",
        "\tfn sqrt(&self) -> Self;",
        "}",
        "impl UsizeTools for usize {",
        "\tfn abs_diff(&self, other: Self) -> Self {",
        "\t\tif *self > other {",
        "\t\t\t*self - other",
        "\t\t} else {",
        "\t\t\tother - *self",
        "\t\t}",
        "\t}",
        "\t/// x^2がNを超えない最大のxを求める",
        "\t/// - 計算量：O(log(N))",
        "\tfn sqrt(&self) -> Self {",
        "\t\tlet (mut ok, mut ng) = (0_usize, 1001001001001001001);",
        "\t\twhile (ng - ok) > 1 {",
        "\t\t\tlet m = (ok + ng) / 2;",
        "\t\t\tif m.saturating_mul(m) <= *self {",
        "\t\t\t\tok = m;",
        "\t\t\t} else {",
        "\t\t\t\tng = m;",
        "\t\t\t}",
        "\t\t}",
        "\t\tok",
        "\t}",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::*;",
        "\t#[test]",
        "\tfn test_abs_diff() {",
        "\t\tassert_eq!(5.abs_diff(4), 1);",
        "\t\tassert_eq!(1.abs_diff(9), 8);",
        "\t\tassert_eq!(9238712.abs_diff(98370918237), 98361679525);",
        "\t\tassert_eq!(1092387.abs_diff(9238728), 8146341);",
        "\t}",
        "\t#[test]",
        "\tfn test_sqrt() {",
        "\t\tassert_eq!(0.sqrt(), 0);",
        "\t\tassert_eq!(4.sqrt(), 2);",
        "\t\tassert_eq!(5.sqrt(), 2);",
        "\t\tassert_eq!(100.sqrt(), 10);",
        "\t\tassert_eq!(101.sqrt(), 10);",
        "\t\tassert_eq!(12390879108273.sqrt(), 3520068);",
        "\t\tassert_eq!(99121929823792.sqrt(), 9955999);",
        "\t\tassert_eq!(1001001001001001001.sqrt(), 1000500375);",
        "\t}",
        "}"
      ],
      "description": "usizeの便利ツール"
    },
    {
      "prefix": "factors_all.rs",
      "body": [
        "/// ## 高速約数列挙",
        "/// `1 ~ N`までの数の約数を高速に列挙する",
        "/// 計算量：`O(nloglogn)`",
        "pub fn factors_all(n: usize) -> Vec<Vec<usize>> {",
        "\tlet mut res = vec![vec![]; n+1];",
        "\tfor i in 1..=n {",
        "\t\tfor j in 1.. {",
        "\t\t\tif i*j > n { break; }",
        "\t\t\tres[i*j].push(i);",
        "\t\t}",
        "\t}",
        "\tres",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::*;",
        "\t",
        "\t#[test]",
        "\tfn test_factors_all() {",
        "\t\tlet facs = factors_all(10);",
        "\t\tassert_eq!(",
        "\t\t\tfacs,",
        "\t\t\tvec![",
        "\t\t\t\tvec![],",
        "\t\t\t\tvec![1],",
        "\t\t\t\tvec![1, 2],",
        "\t\t\t\tvec![1, 3],",
        "\t\t\t\tvec![1, 2, 4],",
        "\t\t\t\tvec![1, 5],",
        "\t\t\t\tvec![1, 2, 3, 6],",
        "\t\t\t\tvec![1, 7],",
        "\t\t\t\tvec![1, 2, 4, 8],",
        "\t\t\t\tvec![1, 3, 9],",
        "\t\t\t\tvec![1, 2, 5, 10],",
        "\t\t\t]",
        "\t\t);",
        "\t}",
        "}"
      ],
      "description": "高速な約数列挙"
    },
    {
      "prefix": "lcs.rs",
      "body": [
        "/// `a < b` のとき、`a`を`b`に置き換え、trueを返す",
        "macro_rules! chmax {",
        "\t( \\$a:expr, \\$b:expr ) => {{",
        "\t\tif \\$a < \\$b {",
        "\t\t\t\\$a = \\$b;",
        "\t\t\ttrue",
        "\t\t} else {",
        "\t\t\tfalse",
        "\t\t}",
        "\t}};",
        "}",
        "/// ## LCS",
        "/// 最長共通部分列を得る",
        "/// 計算量：O(NM)",
        "pub fn LCS<T: std::cmp::PartialEq> (A: &[T], B: &[T]) -> usize {",
        "\tlet (la, lb) = (A.len(), B.len());",
        "\tlet mut dp = vec![vec![0; lb+1]; la+1];",
        "\tfor (i, a) in A.iter().enumerate() {",
        "\t\tfor (j, b) in B.iter().enumerate() {",
        "\t\t\tif a == b {",
        "\t\t\t\tchmax!(dp[i+1][j+1], dp[i][j] + 1);",
        "\t\t\t}",
        "\t\t\tchmax!(dp[i+1][j+1], dp[i+1][j]);",
        "\t\t\tchmax!(dp[i+1][j+1], dp[i][j+1]);",
        "\t\t}",
        "\t}",
        "\tdp[la][lb]",
        "}",
        "/// ## LCS with Vector",
        "/// 最長共通部分列を得る",
        "/// 計算量：O(NM)",
        "pub fn LCS_with_Vec<T: std::cmp::PartialEq + Copy> (A: &[T], B: &[T]) -> Vec<T> {",
        "\tlet (la, lb) = (A.len(), B.len());",
        "\tlet mut dp = vec![vec![0; lb+1]; la+1];",
        "\tfor (i, a) in A.iter().enumerate() {",
        "\t\tfor (j, b) in B.iter().enumerate() {",
        "\t\t\tif a == b {",
        "\t\t\t\tchmax!(dp[i+1][j+1], dp[i][j] + 1);",
        "\t\t\t}",
        "\t\t\tchmax!(dp[i+1][j+1], dp[i+1][j]);",
        "\t\t\tchmax!(dp[i+1][j+1], dp[i][j+1]);",
        "\t\t}",
        "\t}",
        "\tlet mut res: Vec<T> = vec![];",
        "\tlet (mut cur, mut col) = (0, 0);",
        "\t'outer: for i in 0..la {",
        "\t\tfor j in col..lb {",
        "\t\t\tif cur == dp[i][j] && dp[i][j] < dp[i+1][j+1] {",
        "\t\t\t\tres.push(A[i]);",
        "\t\t\t\tcur += 1;",
        "\t\t\t\tcol = j + 1;",
        "\t\t\t}",
        "\t\t\tif cur == dp[la][lb] {  // LCSの長さに達したら終了",
        "\t\t\t\tbreak 'outer;",
        "\t\t\t}",
        "\t\t}",
        "\t}",
        "\tres",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::*;",
        "\t#[test]",
        "\tfn test_LCS_isize() {",
        "\t\tlet a: Vec<isize> = vec![0, 1, 2, 3, 4, 5];",
        "\t\tlet b: Vec<isize> = vec![-1, 1, 3, 5, 7, 9];",
        "\t\tassert_eq!(LCS(&a, &b), 3);",
        "\t}",
        "\t#[test]",
        "\tfn test_LCS_char() {",
        "\t\tlet a: Vec<char> = \\\"powell\\\".chars().collect();",
        "\t\tlet b: Vec<char> = \\\"powershell\\\".chars().collect();",
        "\t\tassert_eq!(LCS(&a, &b), 6);",
        "\t}",
        "\t#[test]",
        "\tfn test_LCS_with_Vec_usize() {",
        "\t\tlet a: Vec<isize> = vec![0, 1, 2, 3, 4, 5];",
        "\t\tlet b: Vec<isize> = vec![-1, 1, 3, 5, 7, 9];",
        "\t\tassert_eq!(LCS_with_Vec(&a, &b), vec![1, 3, 5]);",
        "\t}",
        "\t#[test]",
        "\tfn test_LCS_with_Vec_char() {",
        "\t\tlet a: Vec<char> = \\\"powell\\\".chars().collect();",
        "\t\tlet b: Vec<char> = \\\"powershell\\\".chars().collect();",
        "\t\tassert_eq!(LCS_with_Vec(&a, &b), vec!['p', 'o', 'w', 'e', 'l', 'l']);",
        "\t}",
        "}"
      ],
      "description": "最長共通部分列"
    },
    {
      "prefix": "miller_rabin_test.rs",
      "body": [
        "/// 余りをとる累乗",
        "pub fn powmod(a: usize, b: usize, m: usize) -> usize {",
        "\tlet (mut a, mut  b, m) = (a as u128, b as u128, m as u128);",
        "\tlet mut res = 1;",
        "\twhile b > 0 {",
        "\t\tif b & 1 == 1 {",
        "\t\t\tres = (res * a) % m;",
        "\t\t}",
        "\t\ta = (a * a) % m;",
        "\t\tb >>= 1;",
        "\t}",
        "\tres as usize",
        "}",
        "/// ## ミラーラビン素数判定法",
        "/// 参考: <https://zenn.dev/kaki_xxx/articles/40a92b43200215>",
        "pub fn is_prime_MR(N: usize) -> bool {",
        "\tif N <= 2 {",
        "\t\treturn N == 2;",
        "\t}",
        "\tif N % 2 == 0 {",
        "\t\treturn false;",
        "\t}",
        "\tlet (mut s, mut d) = (0, N - 1);",
        "\twhile d % 2 == 0 {",
        "\t\ts += 1;",
        "\t\td >>= 1;",
        "\t}",
        "\t// n < 2^64 の場合、以下を調べれば十分",
        "\tlet A = [2, 325, 9375, 28178, 450775, 9780504, 1795265022];",
        "\tfor &a in &A {",
        "\t\tif a % N == 0 { break; }",
        "\t\tlet mut t = 0;",
        "\t\tlet mut x = powmod(a, d, N);",
        "\t\tif x != 1 {",
        "\t\t\twhile t < s {",
        "\t\t\t\tif x == N - 1 { break; }",
        "\t\t\t\tx = ((x as u128).pow(2) % (N as u128)) as usize;",
        "\t\t\t\tt += 1;",
        "\t\t\t}",
        "\t\t\tif t == s { return false; }",
        "\t\t}",
        "\t}",
        "\ttrue",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::*;",
        "\t#[test]",
        "\tfn test_algo_method() {",
        "\t\tassert_eq!(is_prime_MR(4033), false);",
        "\t\tassert_eq!(is_prime_MR(4681), false);",
        "\t\tassert_eq!(is_prime_MR(341550054645379), true);",
        "\t\tassert_eq!(is_prime_MR(347484690041206937), false);",
        "\t}",
        "}"
      ],
      "description": "ミラー・ラビン素数判定法"
    },
    {
      "prefix": "modint_traits.rs",
      "body": [],
      "description": "Modintをusizeに注入するトレイト"
    },
    {
      "prefix": "binary_search_slice.rs",
      "body": [
        "/// # BinarySearch",
        "/// 二分探索の実装",
        "pub trait BinarySearch<T> {",
        "\tfn lower_bound(&self, x: T) -> usize;",
        "\tfn upper_bound(&self, x: T) -> usize;",
        "}",
        "impl<T: Ord> BinarySearch<T> for [T] {",
        "\t/// ソート済み配列において、`v`以上の最小のインデックスを取得",
        "\tfn lower_bound(&self, v: T) -> usize {",
        "\t\tlet mut ng = 1_usize.wrapping_neg();",
        "\t\tlet mut ok = self.len();",
        "\t\twhile ok.wrapping_sub(ng) > 1 {",
        "\t\t\tlet mid = ng.wrapping_add(ok) / 2;",
        "\t\t\tif v <= self[mid] {",
        "\t\t\t\tok = mid;",
        "\t\t\t} else {",
        "\t\t\t\tng = mid;",
        "\t\t\t}",
        "\t\t}",
        "\t\tok",
        "\t}",
        "\t/// ソート済み配列において、`v`より大きい最小のインデックスを取得",
        "\tfn upper_bound(&self, v: T) -> usize {",
        "\t\tlet mut ng = 1_usize.wrapping_neg();",
        "\t\tlet mut ok = self.len();",
        "\t\twhile ok.wrapping_sub(ng) > 1 {",
        "\t\t\tlet mid = ng.wrapping_add(ok) / 2;",
        "\t\t\tif v < self[mid] {",
        "\t\t\t\tok = mid;",
        "\t\t\t} else {",
        "\t\t\t\tng = mid;",
        "\t\t\t}",
        "\t\t}",
        "\t\tok",
        "\t}",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::*;",
        "\t#[test]",
        "\tfn test_lower_bound() {",
        "\t\tlet arr = vec![0, 1, 1, 1, 2, 2, 3, 5];",
        "\t\tassert_eq!(arr.lower_bound(0), 0);",
        "\t\tassert_eq!(arr.lower_bound(1), 1);",
        "\t\tassert_eq!(arr.lower_bound(2), 4);",
        "\t\tassert_eq!(arr.lower_bound(3), 6);",
        "\t\tassert_eq!(arr.lower_bound(4), 7);",
        "\t\tassert_eq!(arr.lower_bound(5), 7);",
        "\t\tassert_eq!(arr.lower_bound(10), 8);",
        "\t}",
        "\t#[test]",
        "\tfn test_upper_bound() {",
        "\t\tlet arr = vec![0, 1, 1, 1, 2, 2, 3, 5];",
        "\t\tassert_eq!(arr.upper_bound(0), 1);",
        "\t\tassert_eq!(arr.upper_bound(1), 4);",
        "\t\tassert_eq!(arr.upper_bound(2), 6);",
        "\t\tassert_eq!(arr.upper_bound(3), 7);",
        "\t\tassert_eq!(arr.upper_bound(4), 7);",
        "\t\tassert_eq!(arr.upper_bound(5), 8);",
        "\t\tassert_eq!(arr.upper_bound(10), 8);",
        "\t}",
        "}"
      ],
      "description": "sliceに対する`lower_bound`,`upper_bound`の実装"
    },
    {
      "prefix": "comb.rs",
      "body": [
        "const MOD: usize = 998_244_353;",
        "// const MOD: usize = 1_000_000_007;",
        "/// # Comb",
        "/// 二項係数を高速に求める",
        "/// - 前計算: `O(N)`",
        "/// - クエリ: `O(1)`",
        "pub struct Comb {",
        "\tfac: Vec<usize>,",
        "\tfinv: Vec<usize>,",
        "}",
        "impl Comb {",
        "\t/// サイズ`max_size`で配列を初期化する",
        "\tpub fn new(max_size: usize) -> Self {",
        "\t\tlet mut fac = vec![1; max_size];",
        "\t\tlet mut finv = vec![1; max_size];",
        "\t\tlet mut inv = vec![1; max_size];",
        "\t\tfor i in 2..max_size {",
        "\t\t\tfac[i] = fac[i-1] * i % MOD;",
        "\t\t\tinv[i] = MOD - (MOD / i) * inv[MOD % i] % MOD;",
        "\t\t\tfinv[i] = finv[i-1] * inv[i] % MOD;",
        "\t\t}",
        "\t\t",
        "\t\tComb { fac, finv }",
        "\t}",
        "\t/// `nCr`を`MOD`で割った値を求める",
        "\tpub fn comb(&self, n: usize, r: usize) -> usize {",
        "\t\tif n < r {",
        "\t\t\treturn 0;",
        "\t\t}",
        "\t\tself.fac[n] * (self.finv[r] * self.finv[n - r] % MOD) % MOD",
        "\t}",
        "\t/// `nPr`を`MOD`で割った値を求める",
        "\tpub fn perm(&self, n: usize, r: usize) -> usize {",
        "\t\tif n < r {",
        "\t\t\treturn 0;",
        "\t\t}",
        "\t\tself.fac[n] * self.finv[n-r] % MOD",
        "\t}",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::*;",
        "\tconst SIZE: usize = 5050505;",
        "\t#[test]",
        "\tfn test_comb() {",
        "\t\tlet cmb = Comb::new(SIZE);",
        "\t\tassert_eq!(cmb.comb(5, 2), 10);",
        "\t\tassert_eq!(cmb.comb(100, 50), 198626801);",
        "\t\tassert_eq!(cmb.comb(100000, 50000), 710154335);",
        "\t}",
        "\t#[test]",
        "\tfn test_perm() {",
        "\t\tlet cmb = Comb::new(SIZE);",
        "\t\tassert_eq!(cmb.perm(5, 2), 20);",
        "\t\tassert_eq!(cmb.perm(100000, 50000), 801648426);",
        "\t\tassert_eq!(cmb.perm(100000, 30000), 87629341);",
        "\t}",
        "}"
      ],
      "description": "二項係数を求める"
    },
    {
      "prefix": "rolling_hash.rs",
      "body": [
        "/// # Modint",
        "pub trait Modint {",
        "\tconst MOD: usize;",
        "\tfn madd(&self, other: usize) -> usize;",
        "\tfn msub(&self, other: usize) -> usize;",
        "\tfn mmul(&self, other: usize) -> usize;",
        "}",
        "impl Modint for usize {",
        "\tconst MOD: usize = (1 << 61) - 1;",
        "\tfn madd(&self, other: usize) -> usize {",
        "\t\t(*self + other) % Self::MOD",
        "\t}",
        "\tfn msub(&self, other: usize) -> usize {",
        "\t\t(Self::MOD + *self - other) % Self::MOD",
        "\t}",
        "\tfn mmul(&self, other: usize) -> usize {",
        "\t\tlet res: u128 = (*self as u128) * (other as u128);",
        "\t\t(res % Self::MOD as u128) as usize",
        "\t}",
        "}",
        "/// # RollingHash",
        "/// 文字列の比較を高速に行う",
        "/// - 計算量: `O(n+m)`",
        "#[derive(Debug)]",
        "pub struct RollingHash {",
        "\tpub size: usize,",
        "\tpower: Vec<usize>,",
        "\thash: Vec<usize>,",
        "\tbase: usize,",
        "}",
        "impl RollingHash {",
        "\t/// 初期化",
        "\tpub fn build(arr: &[usize], base: usize) -> Self {",
        "\t\tlet size = arr.len();",
        "\t\tlet mut power = vec![0; size + 1];",
        "\t\tlet mut hash = vec![0; size + 1];",
        "\t\t// hashを初期化",
        "\t\tlet (mut h, mut p) = (0, 1);",
        "\t\tfor i in 0..size {",
        "\t\t\th = arr[i].madd(h.mmul(base));",
        "\t\t\tp = p.mmul(base);",
        "\t\t\thash[i + 1] = h;",
        "\t\t\tpower[i + 1] = p;",
        "\t\t}",
        "\t\tSelf {",
        "\t\t\tsize,",
        "\t\t\tpower,",
        "\t\t\thash,",
        "\t\t\tbase,",
        "\t\t}",
        "\t}",
        "\t/// 文字列から生成",
        "\tpub fn from_str(s: &str, base: usize) -> Self {",
        "\t\tlet arr: Vec<usize> = s.chars().map(Self::ord).collect();",
        "\t\tSelf::build(&arr, base)",
        "\t}",
        "\t/// `l..r`のハッシュを取得",
        "\t/// - 計算量: `O(1)`",
        "\tpub fn get(&self, l: usize, r: usize) -> usize {",
        "\t\tself.hash[r].msub(self.hash[l].mmul(self.power[r - l]))",
        "\t}",
        "\t/// `0..size`のハッシュを取得",
        "\t/// - 計算量: `O(1)`",
        "\tpub fn full(&self) -> usize {",
        "\t\tself.hash[self.size]",
        "\t}",
        "\t/// a,bからの最長共通接頭辞の長さを調べる",
        "\t/// - 計算量: `O(log N)`",
        "\tpub fn getLCP(&self, a: usize, b: usize) -> usize {",
        "\t\tlet len = self.size.saturating_sub(a.max(b));",
        "\t\tlet (mut lo, mut hi) = (0, len + 1);",
        "\t\twhile hi - lo > 1 {",
        "\t\t\tlet mid = (lo + hi) / 2;",
        "\t\t\tif self.get(a, a + mid) == self.get(b, b + mid) {",
        "\t\t\t\tlo = mid;",
        "\t\t\t} else {",
        "\t\t\t\thi = mid;",
        "\t\t\t}",
        "\t\t}",
        "\t\tlo",
        "\t}",
        "\t/// ハッシュ同士を連結",
        "\t/// - 計算量: `O(1)`",
        "\tpub fn concat(&self, h1: usize, h2: usize, h2_len: usize) -> usize {",
        "\t\th1.mmul(self.power[h2_len]).madd(h2)",
        "\t}",
        "\t/// `A`を`0`とするascii文字(`A~Za~z`)のインデックスを返す",
        "\tfn ord(c: char) -> usize {",
        "\t\tlet a = 'A' as u32;",
        "\t\tlet c = c as u32;",
        "\t\t(c - a) as usize",
        "\t}",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::*;",
        "\t#[test]",
        "\tfn test_pattern_match() {",
        "\t\tlet base = 20021213;",
        "\t\tlet target = RollingHash::from_str(\\\"momomosumomomomomonouchi\\\", base);",
        "\t\tlet ptn1 = RollingHash::from_str(\\\"sumomo\\\", base);",
        "\t\tlet ptn2 = RollingHash::from_str(\\\"momo\\\", base);",
        "\t\tlet (tlen, p1len, p2len) = (24, 6, 4);",
        "\t\t// \\\"sumomo\\\"を検索",
        "\t\tlet mut res1 = vec![];",
        "\t\tfor i in 0..tlen - p1len {",
        "\t\t\tif target.get(i, i + p1len) == ptn1.full() {",
        "\t\t\t\tres1.push(i);",
        "\t\t\t}",
        "\t\t}",
        "\t\tassert_eq!(res1, vec![6]);",
        "\t\t// \\\"momo\\\"を検索",
        "\t\tlet mut res2 = vec![];",
        "\t\tfor i in 0..tlen - p2len {",
        "\t\t\tif target.get(i, i + p2len) == ptn2.full() {",
        "\t\t\t\tres2.push(i);",
        "\t\t\t}",
        "\t\t}",
        "\t\tassert_eq!(res2, vec![0, 2, 8, 10, 12, 14]);",
        "\t}",
        "\t#[test]",
        "\tfn test_LCP() {",
        "\t\tlet rh1 = RollingHash::from_str(&\\\"humpbump\\\", 2023);",
        "\t\tassert_eq!(rh1.getLCP(0, 4), 0);",
        "\t\tassert_eq!(rh1.getLCP(1, 5), 3);",
        "\t\tlet rh2 = RollingHash::from_str(&\\\"strangeorange\\\", 19);",
        "\t\tassert_eq!(rh2.getLCP(2, 8), 5);",
        "\t\tassert_eq!(rh2.getLCP(3, 9), 4);",
        "\t}",
        "}"
      ],
      "description": "ローリングハッシュ"
    },
    {
      "prefix": "powmod.rs",
      "body": [
        "/// 余りをとる累乗",
        "pub fn powmod(mut a: usize, mut b: usize, m: usize) -> usize {",
        "\tlet mut res = 1;",
        "\twhile b > 0 {",
        "\t\tif b & 1 == 1 {",
        "\t\t\tres = (res * a) % m;",
        "\t\t}",
        "\t\ta = (a * a) % m;",
        "\t\tb >>= 1;",
        "\t}",
        "\tres",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::*;",
        "\t#[test]",
        "\tfn test_powmod_998244353() {",
        "\t\tconst M: usize = 998244353;",
        "\t\tassert_eq!(powmod(2, 40, M), 444595123);",
        "\t\tassert_eq!(powmod(3, 20, M), 492051342);",
        "\t\tassert_eq!(powmod(2, M-2, M), 499122177);",
        "\t\tassert_eq!(powmod(M-1, M-2, M), M-1);",
        "\t}",
        "\t#[test]",
        "\tfn test_powmod_1048576() {",
        "\t\tconst M: usize = 1048576;",
        "\t\tassert_eq!(powmod(2, 40, M), 0);",
        "\t\tassert_eq!(powmod(3, 20, M), 269201);",
        "\t\tassert_eq!(powmod(2, M-2, M), 0);",
        "\t\tassert_eq!(powmod(M-1, M-2, M), 1);",
        "\t}",
        "}"
      ],
      "description": "あまりを取る累乗"
    },
    {
      "prefix": "factors.rs",
      "body": [
        "/// # 前計算ありの高速素因数分解",
        "/// `N`までの数の素因数分解を",
        "/// - 前計算: `O(NloglogN)`",
        "/// - クエリ: `O(logN)`",
        "/// で行う。",
        "pub struct Factors {",
        "\tn: usize,",
        "\tsieve: Vec<usize>,",
        "}",
        "impl Factors {",
        "\t/// 前計算を行う",
        "\t/// - `O(NloglogN)`で篩を作成",
        "\tpub fn new(n: usize) -> Self {",
        "\t\tlet mut facs = Factors {",
        "\t\t\tn,",
        "\t\t\tsieve: vec![1; n+1],",
        "\t\t};",
        "\t\tfor i in 2..=n {",
        "\t\t\tfor j in 1.. {",
        "\t\t\t\tif i*j > n { break; }",
        "\t\t\t\tif facs.sieve[i*j] == 1 {",
        "\t\t\t\t\tfacs.sieve[i*j] = i;",
        "\t\t\t\t}",
        "\t\t\t}",
        "\t\t}",
        "\t\tfacs",
        "\t}",
        "\t/// 素因数分解を`O(logn)`で行う",
        "\tpub fn factorize(&self, mut x: usize) -> Vec<usize> {",
        "\t\tassert!(1 <= x && x <= self.n);",
        "\t\tlet mut factors = vec![];",
        "\t\twhile x > 1 {",
        "\t\t\tfactors.push(self.sieve[x]);",
        "\t\t\tx /= self.sieve[x];",
        "\t\t}",
        "\t\tfactors",
        "\t}",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::*;",
        "\t#[test]",
        "\tfn test_factorize() {",
        "\t\tlet f = Factors::new(200_000);",
        "\t\tassert_eq!(f.factorize(200), vec![2, 2, 2, 5, 5]);",
        "\t\tassert_eq!(f.factorize(123450), vec![2, 3, 5, 5, 823]);",
        "\t\tassert_eq!(f.factorize(107311), vec![239, 449]);",
        "\t\tassert_eq!(f.factorize(199999), vec![199999]);",
        "\t}",
        "}"
      ],
      "description": "前計算ありの高速素因数分解"
    },
    {
      "prefix": "lib.rs",
      "body": [
        "#![allow(non_snake_case)]",
        "#![allow(dead_code)]",
        "pub mod acc2d;",
        "pub mod affine_transform;",
        "pub mod binary_search_btreeset;",
        "pub mod binary_search_slice;",
        "pub mod bit;",
        "pub mod chmax_chmin;",
        "pub mod comb;",
        "pub mod coordinate_compression;",
        "pub mod dijkstra;",
        "pub mod factorize;",
        "pub mod factors;",
        "pub mod factors_all;",
        "pub mod grid;",
        "pub mod lazy_segment_tree;",
        "pub mod lca;",
        "pub mod lcs;",
        "pub mod matrix_exp;",
        "pub mod miller_rabin_test;",
        "pub mod modint;",
        "pub mod modint_traits;",
        "pub mod multiset;",
        "pub mod namori;",
        "pub mod ord_chr;",
        "pub mod pollard_rho_method;",
        "pub mod powmod;",
        "pub mod rolling_hash;",
        "pub mod run_length;",
        "pub mod scc;",
        "pub mod segment_tree;",
        "pub mod simple_graph;",
        "pub mod tree_dp;",
        "pub mod trie;",
        "pub mod union_find;",
        "pub mod usize_tools;",
        "pub mod vec2;",
        "pub mod weighted_union_find;"
      ],
      "description": ""
    },
    {
      "prefix": "coordinate_compression.rs",
      "body": [
        "/// # 座標圧縮",
        "#[derive(Debug)]",
        "pub struct Compression<'a, T> {",
        "\tpub size: usize,",
        "\tpub sorted_array: Vec<&'a T>,",
        "}",
        "impl<'a, T: Ord> Compression<'a, T> {",
        "\t/// スライス`array`で配列を初期化する",
        "\tpub fn new(array: &'a [T]) -> Self {",
        "\t\tlet mut comp: Vec<&T> = array.iter().collect();",
        "\t\tcomp.sort();",
        "\t\tcomp.dedup();",
        "\t\tSelf {",
        "\t\t\tsize: comp.len(),",
        "\t\t\tsorted_array: comp,",
        "\t\t}",
        "\t}",
        "\t/// 圧縮後の`val`の番号を返す",
        "\tpub fn idx(&self, val: &T) -> Option<usize> {",
        "\t\tlet idx = self.sorted_array.binary_search(&val);",
        "\t\tif let Ok(idx) = idx {",
        "\t\t\tSome(idx)",
        "\t\t} else {",
        "\t\t\tNone",
        "\t\t}",
        "\t}",
        "\t/// 圧縮前の要素`idx`を返す",
        "\tpub fn val(&self, idx: usize) -> Option<&T> {",
        "\t\tif let Some(&val) = self.sorted_array.get(idx) {",
        "\t\t\tSome(val)",
        "\t\t} else {",
        "\t\t\tNone",
        "\t\t}",
        "\t}",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::Compression;",
        "\t#[test]",
        "\tfn test_compression_i32() {",
        "\t\tlet arr = vec![6, 7, 100, 10, 4, 100, 20, 0, 300, 0];",
        "\t\tlet comp = Compression::new(&arr);",
        "\t\tprintln!(\\\"{:?}\\\", &comp);",
        "\t\t// idxのテスト",
        "\t\tassert_eq!(comp.idx(&0), Some(0));",
        "\t\tassert_eq!(comp.idx(&5), None);",
        "\t\tassert_eq!(comp.idx(&20), Some(5));",
        "\t\tassert_eq!(comp.idx(&300), Some(7));",
        "\t\tassert_eq!(comp.idx(&400), None);",
        "\t\t// valのテスト",
        "\t\tassert_eq!(comp.val(0), Some(&0));",
        "\t\tassert_eq!(comp.val(5), Some(&20));",
        "\t\tassert_eq!(comp.val(10), None);",
        "\t}",
        "\t#[test]",
        "\tfn test_compression_val() {",
        "\t\tlet arr = vec![\\\"a\\\", \\\"zoo\\\", \\\"hello\\\", \\\"nagoya\\\", \\\"newyork\\\", \\\"a\\\", \\\"zoo\\\"];",
        "\t\tlet comp = Compression::new(&arr);",
        "\t\tprintln!(\\\"{:?}\\\", &comp);",
        "\t\t// idxのテスト",
        "\t\tassert_eq!(comp.idx(&\\\"a\\\"), Some(0));",
        "\t\tassert_eq!(comp.idx(&\\\"zoo\\\"), Some(4));",
        "\t\tassert_eq!(comp.idx(&\\\"akita\\\"), None);",
        "\t\t// valのテスト",
        "\t\tassert_eq!(comp.val(2), Some(&\\\"nagoya\\\"));",
        "\t\tassert_eq!(comp.val(3), Some(&\\\"newyork\\\"));",
        "\t\tassert_eq!(comp.val(10), None);",
        "\t}",
        "}"
      ],
      "description": "座標圧縮"
    },
    {
      "prefix": "lca.rs",
      "body": [
        "const INF: usize = 1001001001001001001;",
        "type Graph = Vec<Vec<usize>>;",
        "/// # LCA",
        "/// 最小共通祖先を求めるクエリに答える",
        "pub struct LCA {",
        "\tdouble: Vec<Vec<usize>>,",
        "\tdepth: Vec<usize>,",
        "}",
        "impl LCA {",
        "\t/// `root`を根に持つ木`tree`で、初期化を行う",
        "\tpub fn new(tree: &Graph, root: usize) -> Self {",
        "\t\tlet V = tree.len();  // グラフの頂点数",
        "\t\tlet logV = {\t\t  // log_2(グラフの頂点数)",
        "\t\t\tlet mut logv = 0;",
        "\t\t\twhile (V >> logv) > 0 {",
        "\t\t\t\tlogv += 1;",
        "\t\t\t}",
        "\t\t\tlogv",
        "\t\t};",
        "\t\tlet mut double = vec![vec![0; V]; logV];  // ダブリング配列",
        "\t\tlet mut depth = vec![INF; V];\t\t\t // 頂点の根からの距離",
        "\t\tdepth[0] = 0;",
        "\t\tSelf::dfs(root, &mut double[0], &mut depth, tree);",
        "\t\t// ダブリング",
        "\t\tfor i in 1..logV {",
        "\t\t\tfor j in 0..V {",
        "\t\t\t\tdouble[i][j] = double[i-1][double[i-1][j]];",
        "\t\t\t}",
        "\t\t}",
        "\t\tSelf { double, depth }",
        "\t}",
        "\tfn dfs(u: usize, par: &mut Vec<usize>, depth: &mut Vec<usize>, tree: &Graph) {",
        "\t\tfor &v in &tree[u] {",
        "\t\t\tif depth[v] != INF { continue; }",
        "\t\t\tdepth[v] = depth[u] + 1;",
        "\t\t\tpar[v] = u;",
        "\t\t\tSelf::dfs(v, par, depth, tree);",
        "\t\t}",
        "\t}",
        "\t/// 頂点`u`,`v`の最小共通祖先を求める",
        "\tpub fn get_lca(&self, mut u: usize, mut v: usize) -> usize {",
        "\t\t// 常にuを深くする",
        "\t\tif self.depth[u] < self.depth[v] {",
        "\t\t\tstd::mem::swap(&mut u, &mut v);",
        "\t\t}",
        "\t\t// LCAまでの距離を同じにする",
        "\t\tfor k in 0..self.double.len() {",
        "\t\t\tif ((self.depth[u] - self.depth[v]) >> k) & 1 == 1 {",
        "\t\t\t\tu = self.double[k][u];",
        "\t\t\t}",
        "\t\t}",
        "\t\tif u == v {",
        "\t\t\treturn u;",
        "\t\t}",
        "\t\t// 二分探索",
        "\t\tfor k in ( 0 .. self.double.len() ).rev() {",
        "\t\t\tif self.double[k][u] != self.double[k][v] {",
        "\t\t\t\tu = self.double[k][u];",
        "\t\t\t\tv = self.double[k][v];",
        "\t\t\t}",
        "\t\t}",
        "\t\t",
        "\t\tself.double[0][u]",
        "\t}",
        "\t/// 頂点`u`,`v`の距離を求める",
        "\tpub fn dist(&self, u: usize, v: usize) -> usize {",
        "\t\tlet o = self.get_lca(u, v);",
        "\t\t(self.depth[u] - self.depth[o]) + (self.depth[v] - self.depth[o])",
        "\t}",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::*;",
        "\t#[test]",
        "\tfn test_lca() {",
        "\t\tlet tree = vec![",
        "\t\t\tvec![1, 2, 3],",
        "\t\t\tvec![4, 5],",
        "\t\t\tvec![],",
        "\t\t\tvec![],",
        "\t\t\tvec![],",
        "\t\t\tvec![6, 7],",
        "\t\t\tvec![],",
        "\t\t\tvec![],",
        "\t\t];",
        "\t\t/*",
        "\t\t *\t   (root)",
        "\t\t *\t\t 0",
        "\t\t *\t   / | \\",
        "\t\t *\t  1  2  3",
        "\t\t *\t / \\",
        "\t\t *\t4   5",
        "\t\t *\t   / \\",
        "\t\t *\t  6   7",
        "\t\t */",
        "\t\tlet lca = LCA::new(&tree, 0);",
        "\t\tassert_eq!(lca.get_lca(4, 6), 1);",
        "\t\tassert_eq!(lca.get_lca(4, 7), 1);",
        "\t\tassert_eq!(lca.get_lca(4, 3), 0);",
        "\t\tassert_eq!(lca.get_lca(5, 2), 0);",
        "\t\tassert_eq!(lca.get_lca(5, 7), 5);",
        "\t\tassert_eq!(lca.get_lca(4, 4), 4);",
        "\t}",
        "\t#[test]",
        "\tfn test_dist() {",
        "\t\tlet tree = vec![",
        "\t\t\tvec![1, 2, 3],",
        "\t\t\tvec![4, 5],",
        "\t\t\tvec![],",
        "\t\t\tvec![],",
        "\t\t\tvec![],",
        "\t\t\tvec![6, 7],",
        "\t\t\tvec![],",
        "\t\t\tvec![],",
        "\t\t];",
        "\t\t/*",
        "\t\t *\t   (root)",
        "\t\t *\t\t 0",
        "\t\t *\t   / | \\",
        "\t\t *\t  1  2  3",
        "\t\t *\t / \\",
        "\t\t *\t4   5",
        "\t\t *\t   / \\",
        "\t\t *\t  6   7",
        "\t\t */",
        "\t\tlet lca = LCA::new(&tree, 0);",
        "\t\t// 根からの距離",
        "\t\tassert_eq!(lca.dist(0, 7), 3);",
        "\t\tassert_eq!(lca.dist(0, 3), 1);",
        "\t\tassert_eq!(lca.dist(0, 5), 2);",
        "\t\tassert_eq!(lca.dist(0, 0), 0);",
        "\t\t",
        "\t\t// 根以外の頂点同士の距離",
        "\t\tassert_eq!(lca.dist(1, 2), 2);",
        "\t\tassert_eq!(lca.dist(3, 7), 4);",
        "\t\tassert_eq!(lca.dist(4, 1), 1);",
        "\t\tassert_eq!(lca.dist(2, 5), 3);",
        "\t\tassert_eq!(lca.dist(7, 7), 0);",
        "\t\tassert_eq!(lca.dist(3, 3), 0);",
        "\t}",
        "}"
      ],
      "description": "ダブリングにより、最小共通祖先を求める"
    },
    {
      "prefix": "pollard_rho_method.rs",
      "body": [
        "use crate::miller_rabin_test::is_prime_MR;",
        "/// `a`,`b`の最大公約数を求める",
        "pub fn gcd(a: usize, b: usize) -> usize {",
        "\tif b == 0 {",
        "\t\ta",
        "\t} else {",
        "\t\tgcd(b, a % b)",
        "\t}",
        "}",
        "/// ## pollard_rho",
        "/// ポラード・ロー法を適用し、約数を見つける",
        "pub fn pollard_rho(N: usize) -> usize {",
        "\tif N % 2 == 0 { ",
        "\t\treturn 2;",
        "\t}",
        "\tif is_prime_MR(N) {",
        "\t\treturn N;",
        "\t}",
        "\tlet f = |x: usize| -> usize {",
        "\t\t(((x as u128).pow(2) + 1) % N as u128) as usize",
        "\t};",
        "\tlet mut step = 0;",
        "\tloop {",
        "\t\tstep += 1;",
        "\t\tlet mut x = step;",
        "\t\tlet mut y = f(x);",
        "\t\tloop {",
        "\t\t\tlet p = gcd(N + y - x, N);",
        "\t\t\tif p == 0 || p == N { break; }",
        "\t\t\tif p != 1 { return p; }",
        "\t\t\tx = f(x);",
        "\t\t\ty = f(f(y));",
        "\t\t}",
        "\t}",
        "}",
        "/// ## factorize",
        "/// ポラード・ロー法による高速素因数分解",
        "/// `O(n^(1/4))`",
        "pub fn factorize(N: usize) -> Vec<usize> {",
        "\tif N == 1 { return vec![]; }",
        "\tlet p = pollard_rho(N);",
        "\tif p == N { return vec![N]; }",
        "\tlet mut left = factorize(p);",
        "\tlet mut right = factorize(N / p);",
        "\tleft.append(&mut right);",
        "\tleft.sort();",
        "\tleft",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::*;",
        "\t#[test]",
        "\tfn test_algo_method() {",
        "\t\tassert_eq!(factorize(4033), vec![37, 109]);",
        "\t\tassert_eq!(factorize(4681), vec![31, 151]);",
        "\t\tassert_eq!(factorize(1000000007), vec![1000000007]);",
        "\t\tassert_eq!(factorize(9999999999999), vec![3, 3, 53, 79, 265371653]);",
        "\t\tassert_eq!(factorize(341550054645379), vec![341550054645379]);",
        "\t\tassert_eq!(factorize(347484690041206937), vec![381727069, 910296173]);",
        "\t}",
        "}"
      ],
      "description": "ポラード・ロー法による素因数分解"
    },
    {
      "prefix": "dijkstra.rs",
      "body": [
        "use std::collections::BinaryHeap;",
        "use std::cmp::Reverse;",
        "/// Dijkstra法",
        "/// - グラフ`graph`が与えられたとき、スタート地点`s`から各頂点への最短路を求める",
        "pub fn dijkstra(graph: &Vec<Vec<(usize, usize)>>, s: usize) -> Vec<usize> {",
        "\tconst INF: usize = 1001001001001001001;",
        "\tlet n: usize = graph.len();",
        "\tlet mut dist: Vec<usize> = vec![INF; n];",
        "\tlet mut pq: BinaryHeap<Reverse<(usize, usize)>> = BinaryHeap::new();",
        "\t// 初期化",
        "\tdist[s] = 0;",
        "\tpq.push(Reverse((dist[s], s)));",
        "\t// 更新",
        "\twhile let Some(Reverse((cost, u))) = pq.pop() {",
        "\t\tif dist[u] < cost { continue; }",
        "\t\tfor &(v, weight) in &graph[u] {",
        "\t\t\tif dist[v] > dist[u] + weight {",
        "\t\t\t\tdist[v] = dist[u] + weight;",
        "\t\t\t\tpq.push(Reverse((dist[v], v)));",
        "\t\t\t}",
        "\t\t}",
        "\t}",
        "\tdist",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::*;",
        "\t",
        "\t#[test]",
        "\tfn test_dijkstra() {",
        "\t\tlet graph = vec![",
        "\t\t\tvec![(1, 2), (3, 4), (4, 5)],",
        "\t\t\tvec![(0, 2), (1, 6), (3, 3)],",
        "\t\t\tvec![(1, 6), (3, 2), (5, 4)],",
        "\t\t\tvec![(0, 4), (1, 3), (2, 2), (4, 2)],",
        "\t\t\tvec![(0, 5), (3, 2), (5, 6)],",
        "\t\t\tvec![(2, 4), (4, 6)],",
        "\t\t];",
        "\t\tlet dist = dijkstra(&graph, 0);",
        "\t\tassert_eq!(dist, vec![0, 2, 6, 4, 5, 10]);",
        "\t}",
        "}"
      ],
      "description": "ダイクストラ法"
    },
    {
      "prefix": "grid.rs",
      "body": [
        "/// グリッドの探索",
        "pub trait Grid<T>",
        "where",
        "\tSelf: Sized,",
        "{",
        "\t/// usizeにおける-1",
        "\tconst NEG1: T;",
        "\t/// 隣接する4方向（上下左右）",
        "\tconst ADJ4: [(T, T); 4];",
        "\t/// 隣接する8方向",
        "\tconst ADJ8: [(T, T); 8];",
        "\t/// 座標`(i,j)`に上下左右で隣接する座標を取得",
        "\t/// - グリッドサイズ`HxW`でバリデーション",
        "\tfn get_adj_4(&self, H: usize, W: usize) -> Vec<Self>;",
        "\t/// 座標`(i,j)`に8方向で隣接する座標を取得",
        "\t/// - グリッドサイズ`HxW`でバリデーション",
        "\tfn get_adj_8(&self, H: usize, W: usize) -> Vec<Self>;",
        "}",
        "impl Grid<usize> for (usize, usize) {",
        "\tconst NEG1: usize = 1_usize.wrapping_neg();",
        "\tconst ADJ4: [(usize, usize); 4] = [(0, Self::NEG1), (Self::NEG1, 0), (0, 1), (1, 0)];",
        "\tconst ADJ8: [(usize, usize); 8] = [",
        "\t\t(Self::NEG1, Self::NEG1),",
        "\t\t(Self::NEG1, 0),",
        "\t\t(Self::NEG1, 1),",
        "\t\t(0, Self::NEG1),",
        "\t\t(0, 1),",
        "\t\t(1, Self::NEG1),",
        "\t\t(1, 0),",
        "\t\t(1, 1),",
        "\t];",
        "\tfn get_adj_4(&self, H: usize, W: usize) -> Vec<(usize, usize)> {",
        "\t\tlet mut adj = vec![];",
        "\t\tfor &(dr, dc) in &Self::ADJ4 {",
        "\t\t\tlet nr = self.0.wrapping_add(dr);",
        "\t\t\tlet nc = self.1.wrapping_add(dc);",
        "\t\t\tif nr < H && nc < W {",
        "\t\t\t\tadj.push((nr, nc));",
        "\t\t\t}",
        "\t\t}",
        "\t\tadj",
        "\t}",
        "\tfn get_adj_8(&self, H: usize, W: usize) -> Vec<(usize, usize)> {",
        "\t\tlet mut adj = vec![];",
        "\t\tfor &(dr, dc) in &Self::ADJ8 {",
        "\t\t\tlet nr = self.0.wrapping_add(dr);",
        "\t\t\tlet nc = self.1.wrapping_add(dc);",
        "\t\t\tif nr < H && nc < W {",
        "\t\t\t\tadj.push((nr, nc));",
        "\t\t\t}",
        "\t\t}",
        "\t\tadj",
        "\t}",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::Grid;",
        "\tuse std::collections::VecDeque;",
        "\tconst INF: usize = usize::MAX;",
        "\t#[test]",
        "\tfn test_grid_4() {",
        "\t\tlet (H, W) = (5, 6);",
        "\t\tlet S = \\\"",
        "\t\t.#...#",
        "\t\t..##..",
        "\t\t.#..##",
        "\t\t...##.",
        "\t\t##....",
        "\t\t\\\";",
        "\t\tlet grid: Vec<Vec<char>> = S",
        "\t\t\t.split_whitespace()",
        "\t\t\t.map(|row| row.chars().collect())",
        "\t\t\t.collect();",
        "\t\t// BFS",
        "\t\tlet dist = {",
        "\t\t\tlet mut arr = vec![vec![INF; W]; H];",
        "\t\t\tarr[0][0] = 0;",
        "\t\t\tlet mut deq = VecDeque::new();",
        "\t\t\tdeq.push_back((0, 0));",
        "\t\t\twhile let Some((r, c)) = deq.pop_front() {",
        "\t\t\t\tfor (nr, nc) in (r, c).get_adj_4(H, W) {",
        "\t\t\t\t\tif grid[nr][nc] == '.' && arr[nr][nc] == INF {",
        "\t\t\t\t\t\tarr[nr][nc] = arr[r][c] + 1;",
        "\t\t\t\t\t\tdeq.push_back((nr, nc));",
        "\t\t\t\t\t}",
        "\t\t\t\t}",
        "\t\t\t}",
        "\t\t\tarr",
        "\t\t};",
        "\t\tassert_eq!(",
        "\t\t\t&dist,",
        "\t\t\t&vec![",
        "\t\t\t\tvec![0, INF, INF, INF, INF, INF],",
        "\t\t\t\tvec![1, 2, INF, INF, INF, INF],",
        "\t\t\t\tvec![2, INF, 6, 7, INF, INF],",
        "\t\t\t\tvec![3, 4, 5, INF, INF, 10],",
        "\t\t\t\tvec![INF, INF, 6, 7, 8, 9],",
        "\t\t\t]",
        "\t\t);",
        "\t}",
        "\t#[test]",
        "\tfn test_grid_8() {",
        "\t\tlet (H, W) = (5, 6);",
        "\t\tlet S = \\\"",
        "\t\t.#...#",
        "\t\t..##..",
        "\t\t.#..##",
        "\t\t...##.",
        "\t\t##....",
        "\t\t\\\";",
        "\t\tlet grid: Vec<Vec<char>> = S",
        "\t\t\t.split_whitespace()",
        "\t\t\t.map(|row| row.chars().collect())",
        "\t\t\t.collect();",
        "\t\t// BFS",
        "\t\tlet dist = {",
        "\t\t\tlet mut arr = vec![vec![INF; W]; H];",
        "\t\t\tarr[0][0] = 0;",
        "\t\t\tlet mut deq = VecDeque::new();",
        "\t\t\tdeq.push_back((0, 0));",
        "\t\t\twhile let Some((r, c)) = deq.pop_front() {",
        "\t\t\t\tfor (nr, nc) in (r, c).get_adj_8(H, W) {",
        "\t\t\t\t\tif grid[nr][nc] == '.' && arr[nr][nc] == INF {",
        "\t\t\t\t\t\tarr[nr][nc] = arr[r][c] + 1;",
        "\t\t\t\t\t\tdeq.push_back((nr, nc));",
        "\t\t\t\t\t}",
        "\t\t\t\t}",
        "\t\t\t}",
        "\t\t\tarr",
        "\t\t};",
        "\t\tassert_eq!(",
        "\t\t\t&dist,",
        "\t\t\t&vec![",
        "\t\t\t\tvec![0, INF, 2, 3, 4, INF],",
        "\t\t\t\tvec![1, 1, INF, INF, 4, 5],",
        "\t\t\t\tvec![2, INF, 2, 3, INF, INF],",
        "\t\t\t\tvec![3, 3, 3, INF, INF, 6],",
        "\t\t\t\tvec![INF, INF, 4, 4, 5, 6],",
        "\t\t\t]",
        "\t\t);",
        "\t}",
        "}"
      ],
      "description": "グリッド探索の便利ツール"
    },
    {
      "prefix": "binary_search_btreeset.rs",
      "body": [
        "use std::collections::BTreeSet;",
        "use std::ops::Bound::{Included, Excluded, Unbounded};",
        "/// # BinarySearch",
        "/// 二分探索",
        "pub trait BinarySearch<T> {",
        "\tfn lower_bound(&self, x: &T) -> Option<&T>;",
        "\tfn upper_bound(&self, x: &T) -> Option<&T>;",
        "}",
        "impl<T: Ord> BinarySearch<T> for BTreeSet<T> {",
        "\t/// x以上の値を探索する",
        "\tfn lower_bound(&self, x: &T) -> Option<&T> {",
        "\t\tlet mut greater_equal = self.range(",
        "\t\t\t(Included(x), Unbounded)",
        "\t\t);",
        "\t\tgreater_equal.next()",
        "\t}",
        "\t/// xより大きい値を探索する",
        "\tfn upper_bound(&self, x: &T) -> Option<&T> {",
        "\t\tlet mut greater_equal = self.range(",
        "\t\t\t(Excluded(x), Unbounded)",
        "\t\t);",
        "\t\tgreater_equal.next()",
        "\t}",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::*;",
        "\t#[test]",
        "\tfn test_lower_bound() {",
        "\t\tlet mut set = BTreeSet::new();",
        "\t\tset.insert(5);",
        "\t\tset.insert(9);",
        "\t\tset.insert(200);",
        "\t\tset.insert(200);",
        "\t\tset.insert(-5);",
        "\t\t/*",
        "\t\t * BTreeSet{ -5, 5, 9, 200, 200, }",
        "\t\t */",
        "\t\tassert_eq!(set.lower_bound(&4), Some(&5));",
        "\t\tassert_eq!(set.lower_bound(&5), Some(&5));",
        "\t\tassert_eq!(set.lower_bound(&8), Some(&9));",
        "\t\tassert_eq!(set.lower_bound(&100), Some(&200));",
        "\t\tassert_eq!(set.lower_bound(&200), Some(&200));",
        "\t\tassert_eq!(set.lower_bound(&201), None);",
        "\t}",
        "\t#[test]",
        "\tfn test_upper_bound() {",
        "\t\tlet mut set = BTreeSet::new();",
        "\t\tset.insert(5);",
        "\t\tset.insert(9);",
        "\t\tset.insert(200);",
        "\t\tset.insert(200);",
        "\t\tset.insert(-5);",
        "\t\t/*",
        "\t\t * BTreeSet{ -5, 5, 9, 200, 200, }",
        "\t\t */",
        "\t\tassert_eq!(set.upper_bound(&4), Some(&5));",
        "\t\tassert_eq!(set.upper_bound(&5), Some(&9));",
        "\t\tassert_eq!(set.upper_bound(&8), Some(&9));",
        "\t\tassert_eq!(set.lower_bound(&100), Some(&200));",
        "\t\tassert_eq!(set.upper_bound(&200), None);",
        "\t\tassert_eq!(set.upper_bound(&201), None);",
        "\t}",
        "}"
      ],
      "description": "BTreeSetに対する`lower_bound`,`upper_bound`の実装"
    },
    {
      "prefix": "union_find.rs",
      "body": [
        "/// # UnionFind",
        "/// 参考: [RustでUnionFind](https://zenn.dev/nakamurus/articles/f398b7f4d7618ea5b7eb)",
        "pub struct UnionFind {",
        "\tpar: Vec<usize>,",
        "\tsiz: Vec<usize>,",
        "\t/// 連結成分の個数",
        "\tpub group_count: usize,",
        "}",
        "impl UnionFind {",
        "\t/// UnionFindを新規作成",
        "\tpub fn new(n: usize) -> Self {",
        "\t\tUnionFind {",
        "\t\t\tpar: (0..n).collect(),",
        "\t\t\tsiz: vec![1; n],",
        "\t\t\tgroup_count: n,",
        "\t\t}",
        "\t}",
        "\t/// 根を求める",
        "\tpub fn root(&mut self, x: usize) -> usize {",
        "\t\tif self.par[x] == x {",
        "\t\t\treturn x;",
        "\t\t}",
        "\t\tself.par[x] = self.root(self.par[x]);  // 経路圧縮",
        "\t\tself.par[x]",
        "\t}",
        "\t/// 同一の集合に所属するか判定",
        "\tpub fn issame(&mut self, x: usize, y: usize) -> bool {",
        "\t\tself.root(x) == self.root(y)",
        "\t}",
        "\t/// 要素を結合",
        "\tpub fn unite(&mut self, mut parent: usize, mut child: usize) -> bool {",
        "\t\tparent = self.root(parent);",
        "\t\tchild = self.root(child);",
        "\t\tif parent == child {",
        "\t\t\treturn false;",
        "\t\t}",
        "\t\t// 要素数が大きい方を子にすることで、高さを均等に保つ",
        "\t\tif self.siz[parent] < self.siz[child] {",
        "\t\t\tstd::mem::swap(&mut parent, &mut child);",
        "\t\t}",
        "\t\tself.par[child] = parent;",
        "\t\tself.siz[parent] += self.siz[child];",
        "\t\tself.group_count -= 1;",
        "\t\ttrue",
        "\t}",
        "\t/// 連結成分の大きさを求める",
        "\tpub fn size(&mut self, x: usize) -> usize {",
        "\t\tlet root = self.root(x);",
        "\t\tself.siz[root]",
        "\t}",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::*;",
        "\t#[test]",
        "\tfn test_unionfind() {",
        "\t\tlet mut uf = UnionFind::new(8);",
        "\t\t/*",
        "\t\t * 0 1 2 3 4 5 6 7",
        "\t\t */",
        "\t\tuf.unite(1, 2);",
        "\t\tuf.unite(3, 2);",
        "\t\t/*",
        "\t\t * 0 1-2-3 4 5 6 7",
        "\t\t */",
        "\t\tassert_eq!(uf.group_count, 6);",
        "\t\tassert!(uf.issame(1, 3) == true);",
        "\t\tassert!(uf.issame(1, 4) == false);",
        "\t\tassert_eq!(uf.size(1), 3);",
        "\t\tuf.unite(2, 4);",
        "\t\t/*",
        "\t\t * 0 1-2-3-4 5 6 7",
        "\t\t */",
        "\t\tassert_eq!(uf.group_count, 5);",
        "\t\tassert!(uf.issame(4, 1) == true);",
        "\t\tassert_eq!(uf.size(4), 4);",
        "\t\tuf.unite(4, 2);",
        "\t\tuf.unite(0, 0);",
        "\t\t/*",
        "\t\t * 0 1-2-3-4 5 6 7",
        "\t\t */",
        "\t\tassert_eq!(uf.group_count, 5);",
        "\t\tassert!(uf.issame(0, 0) == true);",
        "\t\tuf.unite(0, 7);",
        "\t\t/*",
        "\t\t * 0 1-2-3-4 5 6 7",
        "\t\t * └─────────────┘",
        "\t\t */",
        "\t\tassert_eq!(uf.group_count, 4);",
        "\t\tassert!(uf.issame(0, 7) == true);",
        "\t\tuf.unite(5, 6);",
        "\t\t/*",
        "\t\t * 0 1-2-3-4 5-6 7",
        "\t\t * └─────────────┘",
        "\t\t */",
        "\t\tassert_eq!(uf.group_count, 3);",
        "\t\tassert!(uf.issame(5, 6) == true);",
        "\t\tassert!(uf.issame(5, 7) == false);",
        "\t\tuf.unite(4, 5);",
        "\t\tuf.unite(6, 7);",
        "\t\t/*",
        "\t\t * 0-1-2-3-4-5-6-7",
        "\t\t */",
        "\t\tassert_eq!(uf.group_count, 1);",
        "\t\tuf.unite(0, 7);",
        "\t\t/*",
        "\t\t * 0-1-2-3-4-5-6-7",
        "\t\t */",
        "\t",
        "\t\tassert_eq!(uf.group_count, 1);",
        "\t}",
        "}"
      ],
      "description": "UnionFind木"
    },
    {
      "prefix": "vec2.rs",
      "body": [
        "use std::ops::{Add, Sub, Mul, Neg};",
        "pub type Pos<T> = (T, T);",
        "pub type Line<T> = (Pos<T>, Pos<T>);",
        "/// ベクトル演算を行う",
        "pub trait Vec2<T> {",
        "\tfn mul(&self, scalar: T) -> Self;",
        "\tfn add(&self, other: Self) -> Self;",
        "\tfn sub(&self, other: Self) -> Self;",
        "\t/// ドット積",
        "\tfn dot(&self, other: Self) -> T;",
        "\t/// クロス積",
        "\tfn cross(&self, other: Self) -> T;",
        "\t/// L2-ノルム（の2乗）",
        "\tfn dist2(&self, other: Self) -> T;",
        "}",
        "impl<T> Vec2<T> for Pos<T>",
        "where T: Copy",
        "\t+ Add<Output = T>",
        "\t+ Sub<Output = T>",
        "\t+ Mul<Output = T>",
        "\t+ Neg",
        "{",
        "\tfn mul(&self, scalar: T) -> Self {",
        "\t\t(self.0 * scalar, self.1 * scalar)",
        "\t}",
        "\tfn add(&self, other: Self) -> Self {",
        "\t\t(self.0 + other.0, self.1 + other.1)",
        "\t}",
        "\tfn sub(&self, other: Self) -> Self {",
        "\t\t(self.0 - other.0, self.1 - other.1)",
        "\t}",
        "\tfn dot(&self, other: Self) -> T {",
        "\t\tself.0 * other.0 + self.1 * other.1",
        "\t}",
        "\tfn cross(&self, other: Self) -> T {",
        "\t\t(self.0 * other.1) - (other.0 * self.1)",
        "\t}",
        "\tfn dist2(&self, other: Self) -> T {",
        "\t\t(self.0 - other.0) * (self.0 - other.0)",
        "\t\t+ (self.1 - other.1) * (self.1 - other.1)",
        "\t}",
        "}",
        "/// 線分abと線分xyが衝突しているかどうか",
        "pub fn is_collided(ab: Line<isize>, xy: Line<isize>) -> bool {",
        "\tlet (a, b) = ab;",
        "\tlet (x, y) = xy;",
        "\t// Aから見たとき",
        "\tlet AX = x.sub(a);",
        "\tlet AY = y.sub(a);",
        "\tlet AB = b.sub(a);",
        "\t// Xから見たとき",
        "\tlet XA = a.sub(x);",
        "\tlet XB = b.sub(x);",
        "\tlet XY = y.sub(x);",
        "\tAB.cross(AX) * AB.cross(AY) < 0 && XY.cross(XA) * XY.cross(XB) < 0",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::*;",
        "\t#[test]",
        "\tfn test_add_sub_mul_vec2() {",
        "\t\tlet a = (2, 3);",
        "\t\tlet b = (5, -2);",
        "\t\tassert_eq!(a.add(b), (7, 1));",
        "\t\tassert_eq!(a.sub(b), (-3, 5));",
        "\t\tlet a2 = a.mul(-2);",
        "\t\tlet b2 = b.mul(3);",
        "\t\tassert_eq!(a2.add(b2), (11, -12));",
        "\t}",
        "\t#[test]",
        "\tfn test_dot() {",
        "\t\tlet a = (2.0, -5.0);",
        "\t\tlet b = (10.0, 4.0);",
        "\t\tassert_eq!(a.dot(b), 0.0);",
        "\t}",
        "\t#[test]",
        "\tfn test_dist2() {",
        "\t\tlet zero = (0, 0);",
        "\t\tlet a = (1, 2);",
        "\t\tlet b = (2, 1);",
        "\t\tlet dist_0_a = a.dist2(zero);",
        "\t\tlet dist_0_b = b.dist2(zero);",
        "\t\tassert_eq!(dist_0_a, dist_0_b);",
        "\t\tlet dist_a_b = a.dist2(b);",
        "\t\tassert_eq!(dist_a_b, 2);",
        "\t}",
        "\t#[test]",
        "\tfn test_collision_line() {",
        "\t\tlet ab: Line<isize> = (",
        "\t\t\t(3, 1),",
        "\t\t\t(-3, 1)",
        "\t\t);",
        "\t\tlet line1: Line<isize> = (",
        "\t\t\t(1, 2),",
        "\t\t\t(2, 2)",
        "\t\t);",
        "\t\tlet line2: Line<isize> = (",
        "\t\t\t(1, 2),",
        "\t\t\t(1, 0)",
        "\t\t);",
        "\t\tassert_eq!(is_collided(ab, line1), false);",
        "\t\tassert_eq!(is_collided(ab, line2), true);",
        "\t}",
        "}"
      ],
      "description": "幾何ライブラリ"
    },
    {
      "prefix": "factorize.rs",
      "body": [
        "/// - 素因数分解し、`(素因数,指数)`のペアを返す",
        "pub fn factorize(mut n: usize) -> Vec<(usize, usize)> {",
        "\tlet mut res = Vec::new();",
        "\tfor i in 2.. {",
        "\t\tif i*i > n {",
        "\t\t\tbreak;",
        "\t\t}",
        "\t\tlet mut cnt = 0;",
        "\t\twhile n % i == 0 {",
        "\t\t\tn /= i;",
        "\t\t\tcnt += 1;",
        "\t\t}",
        "\t\tif cnt >= 1 {",
        "\t\t\tres.push((i, cnt));",
        "\t\t}",
        "\t}",
        "\tif n > 1 {",
        "\t\tres.push((n, 1));",
        "\t}",
        "\tres",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::*;",
        "\t#[test]",
        "\tfn test_factorize() {",
        "\t\tassert_eq!(",
        "\t\t\tfactorize(1024),",
        "\t\t\tvec![(2, 10)]",
        "\t\t);",
        "\t\tassert_eq!(",
        "\t\t\tfactorize(123456789),",
        "\t\t\tvec![(3, 2), (3607, 1), (3803, 1)]",
        "\t\t);",
        "\t\tassert_eq!(",
        "\t\t\tfactorize(20021213),",
        "\t\t\tvec![(20021213, 1)]",
        "\t\t);",
        "\t\tassert_eq!(",
        "\t\t\tfactorize(1234567891234567),",
        "\t\t\tvec![(47, 1), (167, 1), (167953, 1), (936511, 1)]",
        "\t\t);",
        "\t}",
        "}"
      ],
      "description": "素因数分解"
    },
    {
      "prefix": "trie.rs",
      "body": [
        "use std::fmt::Debug;",
        "// 定数",
        "const ORIGIN: char = 'a'; // 基準となる文字",
        "const ORIGIN_ID: usize = ORIGIN as u32 as usize; // 基準となる文字のID",
        "const KINDS: usize = 26; // 文字の種類数",
        "type NodePointer<T> = Option<Box<TrieNode<T>>>;",
        "/// 何番目の文字かを判定する",
        "fn ord(c: char) -> usize {",
        "\tlet num = c as u32 as usize;",
        "\tnum - ORIGIN_ID",
        "}",
        "/// i番目の文字を返す",
        "fn chr(i: usize) -> char {",
        "\t(ORIGIN_ID + i) as u8 as char",
        "}",
        "/// # TrieNode",
        "/// - トライ木のノード",
        "#[derive(Debug, Clone)]",
        "struct TrieNode<T> {",
        "\tdata: Option<T>,",
        "\tchildren: Vec<NodePointer<T>>,",
        "}",
        "impl<T> TrieNode<T>",
        "where",
        "\tT: Clone,",
        "{",
        "\tpub fn new(data: Option<T>) -> Self {",
        "\t\tSelf {",
        "\t\t\tdata,",
        "\t\t\tchildren: vec![NodePointer::None; KINDS],",
        "\t\t}",
        "\t}",
        "}",
        "/// # Trie",
        "/// - トライ木の実装",
        "#[derive(Debug)]",
        "pub struct Trie<T> {",
        "\troot: NodePointer<T>,",
        "}",
        "impl<T> Trie<T>",
        "where",
        "\tT: Clone + Debug,",
        "{",
        "\t// self.originを基準にした文字の番号を返す",
        "\t// fn ord()",
        "\tpub fn new() -> Self {",
        "\t\tTrie {",
        "\t\t\troot: Some(Box::new(TrieNode {",
        "\t\t\t\tdata: None,",
        "\t\t\t\tchildren: vec![NodePointer::None; KINDS],",
        "\t\t\t})),",
        "\t\t}",
        "\t}",
        "\tpub fn insert(&mut self, key: &str, data: T) {",
        "\t\t*self.get_or_insert_mut(key) = Some(data);",
        "\t}",
        "\tpub fn get(&self, key: &str) -> Option<&T> {",
        "\t\tlet mut node = &self.root;",
        "\t\tfor c in key.chars().map(ord) {",
        "\t\t\tnode = &node.as_ref()?.children[c];",
        "\t\t}",
        "\t\tnode.as_deref()?.data.as_ref()",
        "\t}",
        "\tpub fn get_mut(&mut self, key: &str) -> Option<&mut T> {",
        "\t\tlet mut node = &mut self.root;",
        "\t\tfor c in key.chars().map(ord) {",
        "\t\t\tnode = node.as_mut()?.children.get_mut(c).unwrap();",
        "\t\t}",
        "\t\tnode.as_deref_mut()?.data.as_mut()",
        "\t}",
        "\tpub fn get_or_insert_mut(&mut self, key: &str) -> &mut Option<T> {",
        "\t\tlet mut node = &mut self.root;",
        "\t\tfor c in key.chars().map(ord).chain(KINDS..=KINDS) {",
        "\t\t\t// データの挿入",
        "\t\t\tif c == KINDS {",
        "\t\t\t\tif node.as_ref().is_none() {",
        "\t\t\t\t\t*node = Some(Box::new(TrieNode::new(None)));",
        "\t\t\t\t}",
        "\t\t\t\tbreak;",
        "\t\t\t}",
        "\t\t\tif node.as_ref().is_none() {",
        "\t\t\t\t*node = Some(Box::new(TrieNode::new(None)));",
        "\t\t\t}",
        "\t\t\tnode = node.as_mut().unwrap().children.get_mut(c).unwrap();",
        "\t\t}",
        "\t\t&mut node.as_deref_mut().unwrap().data",
        "\t}",
        "\tpub fn traverse(&self) -> Vec<(String, &T)> {",
        "\t\tlet mut res = vec![];",
        "\t\tlet mut cur = String::new();",
        "\t\ttraverse_inner(&self.root, &mut cur, &mut res);",
        "\t\tres",
        "\t}",
        "}",
        "/// trieを順に探索する",
        "fn traverse_inner<'a, T>(",
        "\tnode: &'a NodePointer<T>,",
        "\tcur: &mut String,",
        "\tlist: &mut Vec<(String, &'a T)>,",
        ") {",
        "\tif let Some(value) = node.as_ref().unwrap().data.as_ref() {",
        "\t\tlet key = cur.clone();",
        "\t\tlist.push((key, value));",
        "\t}",
        "\tif let Some(node) = node.as_deref() {",
        "\t\tfor (i, child) in node.children.iter().enumerate() {",
        "\t\t\tif child.as_ref().is_some() {",
        "\t\t\t\tcur.push(chr(i));",
        "\t\t\t\ttraverse_inner(child, cur, list);",
        "\t\t\t\tcur.pop();",
        "\t\t\t}",
        "\t\t}",
        "\t}",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::Trie;",
        "\t#[test]",
        "\tfn test_trie_node() {",
        "\t\tlet mut trie: Trie<usize> = Trie::new();",
        "\t\t// 文字列の挿入",
        "\t\t// trie.insert(\\\"powell\\\", 5);",
        "\t\t// trie.insert(\\\"kentakomoto\\\", 11);",
        "\t\t// trie.insert(\\\"kenta\\\", 5);",
        "\t\t// trie.insert(\\\"pow\\\", 3);",
        "\t\t// trie.insert(\\\"\\\", 0);",
        "\t\t*trie.get_or_insert_mut(\\\"powell\\\") = Some(6);",
        "\t\t*trie.get_or_insert_mut(\\\"kenta\\\") = Some(8);",
        "\t\t// デバッグ",
        "\t\tprintln!(\\\"{:#?}\\\", trie);",
        "\t\t// 一覧表示",
        "\t\tlet dict = trie.traverse();",
        "\t\tprintln!(\\\"{:?}\\\", dict);",
        "\t\t// 検索",
        "\t\tprintln!(\\\"{:?}\\\", trie.get_mut(\\\"pow\\\"));",
        "\t\t*trie.get_mut(\\\"powell\\\").unwrap() += 1;",
        "\t\t// 一覧表示",
        "\t\tlet dict = trie.traverse();",
        "\t\tprintln!(\\\"{:?}\\\", dict);",
        "\t}",
        "}"
      ],
      "description": "トライ木"
    },
    {
      "prefix": "simple_graph.rs",
      "body": [
        "type Graph = Vec<Vec<usize>>;",
        "/// # 単純グラフ",
        "/// 単純グラフに対して",
        "/// - 連結成分分解",
        "/// - 2部グラフ分解",
        "/// ",
        "/// を行う。",
        "#[derive(Debug)]",
        "pub struct SimpleGraph {",
        "\tpub V: usize,",
        "\tpub E: usize,",
        "\tpub graph: Graph,",
        "\tpub edges: Vec<(usize, usize)>,",
        "\tpub component_size: Option<usize>,",
        "\tpub components: Vec<usize>,",
        "}",
        "impl SimpleGraph {",
        "\tconst INF: usize = 1_000_000_000_000_000_000;",
        "\t/// グラフの構築",
        "\tpub fn new(V: usize) -> Self {",
        "\t\tSelf {",
        "\t\t\tV,",
        "\t\t\tE: 0,",
        "\t\t\tgraph: vec![vec![]; V],",
        "\t\t\tedges: vec![],",
        "\t\t\tcomponent_size: None,",
        "\t\t\tcomponents: vec![Self::INF; V],",
        "\t\t}",
        "\t}",
        "\t/// 辺の追加",
        "\tpub fn add_edge(&mut self, u: usize, v: usize) {",
        "\t\tself.E += 1;",
        "\t\tself.edges.push((u, v));",
        "\t\tself.graph[u].push(v);",
        "\t\tself.graph[v].push(u);",
        "\t}",
        "\t/// 連結成分に分解：O(|V|+|E|)",
        "\tpub fn decompose(&mut self) {",
        "\t\tlet mut component = 0;",
        "\t\tself.components = vec![Self::INF; self.V];",
        "\t\tfor i in 0..self.V {",
        "\t\t\tif self.components[i] != Self::INF {",
        "\t\t\t\tcontinue;",
        "\t\t\t}",
        "\t\t\tself.components[i] = component;",
        "\t\t\tlet mut stack = vec![i];",
        "\t\t\twhile let Some(u) = stack.pop() {",
        "\t\t\t\tfor &v in &self.graph[u] {",
        "\t\t\t\t\tif self.components[v] == Self::INF {",
        "\t\t\t\t\t\tself.components[v] = component;",
        "\t\t\t\t\t\tstack.push(v);",
        "\t\t\t\t\t}",
        "\t\t\t\t}",
        "\t\t\t}",
        "\t\t\tcomponent += 1;",
        "\t\t}",
        "\t\tself.component_size = Some(component);",
        "\t}",
        "\t/// 2部グラフ判定：O(|V|+|E|)",
        "\tpub fn bipartite(&mut self) -> Option<Vec<isize>> {",
        "\t\t// 未だ連結成分分解されていない場合",
        "\t\tif self.component_size.is_none() {",
        "\t\t\tself.decompose();",
        "\t\t}",
        "\t\tlet mut res: Vec<isize> = vec![0; self.V];",
        "\t\tfor i in 0..self.V {",
        "\t\t\tlet mut stack = vec![i];",
        "\t\t\tif res[i] != 0 {",
        "\t\t\t\tcontinue;",
        "\t\t\t}",
        "\t\t\tres[i] = self.components[i] as isize + 1;",
        "\t\t\twhile let Some(u) = stack.pop() {",
        "\t\t\t\tfor &v in &self.graph[u] {",
        "\t\t\t\t\tif res[v] == res[u] {",
        "\t\t\t\t\t\treturn None;",
        "\t\t\t\t\t}",
        "\t\t\t\t\tif res[v] == 0 {",
        "\t\t\t\t\t\tres[v] = -res[u];",
        "\t\t\t\t\t\tstack.push(v);",
        "\t\t\t\t\t}",
        "\t\t\t\t}",
        "\t\t\t}",
        "\t\t}",
        "\t\tSome(res)",
        "\t}",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::*;",
        "\t#[test]",
        "\tfn test_decompose() {",
        "\t\tlet mut graph = SimpleGraph::new(5);",
        "\t\tassert_eq!(graph.component_size, None);",
        "\t\t// 0 -- 1 -- 2 | 3 | 4",
        "\t\tgraph.add_edge(0, 1);",
        "\t\tgraph.add_edge(1, 2);",
        "\t\tgraph.decompose();",
        "\t\tassert_eq!(graph.component_size, Some(3));",
        "\t\tassert_eq!(&graph.components, &vec![0, 0, 0, 1, 2]);",
        "\t\t// 4 -- 0 -- 1 -- 2 | 3",
        "\t\tgraph.add_edge(4, 0);",
        "\t\tgraph.decompose();",
        "\t\tassert_eq!(graph.component_size, Some(2));",
        "\t\tassert_eq!(&graph.components, &vec![0, 0, 0, 1, 0]);",
        "\t}",
        "\t#[test]",
        "\tfn test_bipartite() {",
        "\t\tlet mut graph = SimpleGraph::new(7);",
        "\t\t// 0 -- 1",
        "\t\t// |\t|",
        "\t\t// 2 -- 3 -- 4",
        "\t\t// 5 -- 6",
        "\t\tgraph.add_edge(0, 1);",
        "\t\tgraph.add_edge(0, 2);",
        "\t\tgraph.add_edge(1, 3);",
        "\t\tgraph.add_edge(2, 3);",
        "\t\tgraph.add_edge(3, 4);",
        "\t\tgraph.add_edge(5, 6);",
        "\t\tlet bigraph = graph.bipartite().unwrap();",
        "\t\tassert_eq!(&bigraph, &vec![1, -1, -1, 1, -1, 2, -2]);",
        "\t}",
        "}"
      ],
      "description": "単純グラフの処理"
    },
    {
      "prefix": "tree_dp.rs",
      "body": [
        "type Graph = Vec<Vec<usize>>;",
        "/// # Monoid",
        "pub trait Monoid {",
        "\ttype Val: Clone + PartialEq;",
        "\tconst E: Self::Val;",
        "\tfn op(u: &Self::Val, v: &Self::Val) -> Self::Val;",
        "\tfn apply(val: &Self::Val) -> Self::Val;",
        "}",
        "/// # 木DP",
        "struct TreeDP<T: Monoid> {",
        "\tpub N: usize,",
        "\tpub G: Graph,",
        "\tdp: Vec<T::Val>,",
        "}",
        "impl<T: Monoid> TreeDP<T> {\t",
        "\t/// 頂点数`N`でグラフを初期化する",
        "\tpub fn new(N: usize) -> Self {",
        "\t\tSelf {",
        "\t\t\tN,",
        "\t\t\tG: vec![vec![]; N],",
        "\t\t\tdp: vec![T::E; N],",
        "\t\t}",
        "\t}",
        "\t/// 辺`u`-`v`を追加する",
        "\tpub fn add_edge(&mut self, u: usize, v: usize) {",
        "\t\tself.G[u].push(v);",
        "\t\tself.G[v].push(u);",
        "\t}",
        "\t/// 頂点`start`に値を集約する",
        "\tpub fn aggregate(&mut self, start: usize) -> T::Val {",
        "\t\tlet NEG1 = 1_usize.wrapping_neg();",
        "\t\tSelf::dfs(",
        "\t\t\tNEG1,",
        "\t\t\tstart,",
        "\t\t\t&self.G,",
        "\t\t\t&mut self.dp,",
        "\t\t);",
        "\t\tself.dp[start].clone()",
        "\t}",
        "\tfn dfs(p: usize, u: usize, G: &Graph, dp: &mut Vec<T::Val>) {",
        "\t\t// 葉であるときの処理",
        "\t\tif G[u].len() == 1 && G[u][0] == p {",
        "\t\t\tdp[u] = T::E;",
        "\t\t\treturn;",
        "\t\t}",
        "\t\t// 子要素を集約する",
        "\t\tlet mut acc = T::E; // 子要素の累積",
        "\t\tfor &v in &G[u] {",
        "\t\t\tif v == p {",
        "\t\t\t\tcontinue;",
        "\t\t\t}",
        "\t\t\tSelf::dfs(u, v, G, dp);",
        "\t\t\tacc = T::op(",
        "\t\t\t\t&acc,",
        "\t\t\t\t&dp[v]",
        "\t\t\t);",
        "\t\t}",
        "\t\tdp[u] = T::apply(&acc);",
        "\t}",
        "}"
      ],
      "description": "木DP"
    },
    {
      "prefix": "multiset.rs",
      "body": [
        "use std::collections::BTreeMap;",
        "#[derive(Debug)]",
        "pub struct MultiSet<T> {",
        "\tpub map: BTreeMap<T, usize>,",
        "\tlen: usize,",
        "}",
        "impl<T> MultiSet<T>",
        "where",
        "\tT: Ord,",
        "{",
        "\t/// MultiSetを初期化する",
        "\tpub fn new() -> Self {",
        "\t\tMultiSet {",
        "\t\t\tmap: BTreeMap::new(),",
        "\t\t\tlen: 0,",
        "\t\t}",
        "\t}",
        "\t/// 要素`x`を追加する",
        "\tpub fn insert(&mut self, x: T) {",
        "\t\t*self.map.entry(x).or_insert(0) += 1;",
        "\t\tself.len += 1;",
        "\t}",
        "\t/// 要素`x`を削除する",
        "\tpub fn remove(&mut self, x: &T) -> bool {",
        "\t\tif let Some(v) = self.map.get_mut(x) {",
        "\t\t\t*v -= 1;",
        "\t\t\tif *v == 0 {",
        "\t\t\t\tself.map.remove(x);",
        "\t\t\t}",
        "\t\t\tself.len -= 1;",
        "\t\t\treturn true;",
        "\t\t}",
        "\t\tfalse",
        "\t}",
        "\t/// 要素`x`が存在するか判定する",
        "\tpub fn contains(&self, x: &T) -> bool {",
        "\t\tself.map.contains_key(x)",
        "\t}",
        "\t/// 先頭の要素を取得する",
        "\tpub fn first(&self) -> Option<&T> {",
        "\t\tself.map.keys().next()",
        "\t}",
        "\t/// 末尾の要素を取得する",
        "\tpub fn last(&self) -> Option<&T> {",
        "\t\tself.map.keys().last()",
        "\t}",
        "\t/// `x`の個数をカウントする",
        "\tpub fn count(&self, x: &T) -> usize {",
        "\t\tmatch self.map.get(x) {",
        "\t\t\tSome(&v) => v,",
        "\t\t\tNone => 0,",
        "\t\t}",
        "\t}",
        "\tpub fn len(&self) -> usize {",
        "\t\tself.len",
        "\t}",
        "\tpub fn is_empty(&self) -> bool {",
        "\t\tself.len == 0",
        "\t}",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::*;",
        "\t#[test]",
        "\tfn test_usize() {",
        "\t\tlet mut mset: MultiSet<usize> = MultiSet::new();",
        "\t\tassert!(mset.is_empty());",
        "\t\tmset.insert(5);",
        "\t\tmset.insert(7);",
        "\t\tmset.insert(7);",
        "\t\tmset.insert(10);",
        "\t\tmset.insert(3);",
        "\t\t// remove value",
        "\t\tassert_eq!(mset.remove(&7), true);",
        "\t\tassert_eq!(mset.remove(&7), true);",
        "\t\tassert_eq!(mset.remove(&0), false);",
        "\t\t// is_contain",
        "\t\tassert_eq!(mset.contains(&5), true);",
        "\t\tassert_eq!(mset.contains(&7), false);",
        "\t\tassert_eq!(mset.contains(&0), false);",
        "\t\tassert_eq!(mset.contains(&1000), false);",
        "\t\t// first element",
        "\t\tassert_eq!(mset.first(), Some(&3));",
        "\t\tassert_eq!(mset.remove(&3), true);",
        "\t\tassert_eq!(mset.first(), Some(&5));",
        "\t\tassert_eq!(mset.contains(&3), false);",
        "\t\t// last element",
        "\t\tassert_eq!(mset.last(), Some(&10));",
        "\t\t// count values",
        "\t\tmset.insert(20);",
        "\t\tmset.insert(20);",
        "\t\tmset.insert(20);",
        "\t\t/*",
        "\t\t * MultiSet { 3, 5, 10, 20, 20, 20 }",
        "\t\t */",
        "\t\tassert_eq!(mset.count(&5), 1);",
        "\t\tassert_eq!(mset.count(&20), 3);",
        "\t\tassert_eq!(mset.count(&1000), 0);",
        "\t}",
        "}"
      ],
      "description": "多重集合"
    },
    {
      "prefix": "modint.rs",
      "body": [
        "#![allow(unused_imports)]",
        "#[rustfmt::skip]",
        "pub mod modint {",
        "\tuse std::{fmt::Display,ops::{Add, AddAssign, Div, Mul, MulAssign, Neg, Sub}};",
        "\t#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)] pub struct Modint<const MOD: usize>(usize);",
        "\timpl<const MOD: usize> Modint<MOD> { pub fn new(n: usize) -> Self { Self(if n < MOD { n } else { n % MOD }) } }",
        "\timpl<const MOD: usize> Neg for Modint<MOD> { type Output = Self; fn neg(self) -> Self { Modint(if self.0 == 0 { 0 } else { MOD - self.0 }) } }",
        "\timpl<const MOD: usize> Add for Modint<MOD> { type Output = Self; fn add(self, rhs: Self) -> Self { let mut res = self.0 + rhs.0; if res > MOD { res -= MOD; } Modint(res) } }",
        "\timpl<const MOD: usize> Sub for Modint<MOD> { type Output = Self; fn sub(self, rhs: Self) -> Self { self + (- rhs) } }",
        "\timpl<const MOD: usize> Mul for Modint<MOD> { type Output = Self; fn mul(self, rhs: Self) -> Self { Modint(self.0 * rhs.0 % MOD) } }",
        "\timpl<const MOD: usize> Div for Modint<MOD> { type Output = Self; fn div(self, rhs: Self) -> Self { self * rhs.inv() } }",
        "\timpl<const MOD: usize> AddAssign for Modint<MOD> { fn add_assign(&mut self, rhs: Self) { self.0 = (*self + rhs).0 } }",
        "\timpl<const MOD: usize> MulAssign for Modint<MOD> { fn mul_assign(&mut self, rhs: Self) { self.0 = (*self * rhs).0 } }",
        "\timpl<const MOD: usize> From<usize> for Modint<MOD> { fn from(value: usize) -> Self { Modint::new(value) } }",
        "\timpl<const MOD: usize> Add<usize> for Modint<MOD> { type Output = Self; fn add(self, rhs: usize) -> Self { let mut res = self.0 + rhs; if res > MOD {res -= MOD;} Modint(res) } }",
        "\timpl<const MOD: usize> Sub<usize> for Modint<MOD> { type Output = Self; fn sub(self, rhs: usize) -> Self { self - Modint::new(rhs) } }",
        "\timpl<const MOD: usize> Mul<usize> for Modint<MOD> { type Output = Self; fn mul(self, rhs: usize) -> Self { self * Modint::new(rhs) } }",
        "\timpl<const MOD: usize> Div<usize> for Modint<MOD> { type Output = Self; fn div(self, rhs: usize) -> Self { self / Modint::new(rhs) } }",
        "\timpl<const MOD: usize> AddAssign<usize> for Modint<MOD> { fn add_assign(&mut self, rhs: usize) { *self += Modint::new(rhs) } }",
        "\timpl<const MOD: usize> MulAssign<usize> for Modint<MOD> { fn mul_assign(&mut self, rhs: usize) { *self *= Modint::new(rhs) } }",
        "\timpl<const MOD: usize> Display for Modint<MOD> { fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, \\\"{}\\\", self.0) } }",
        "\timpl<const MOD: usize> PartialEq<usize> for Modint<MOD> { fn eq(&self, other: &usize) -> bool { self == &Modint::new(*other) } }",
        "\tpub trait Fp { fn pow(&self, rhs: usize) -> Self; fn inv(&self) -> Self; }",
        "\timpl<const MOD: usize> Fp for Modint<MOD> { fn pow(&self, rhs: usize) -> Self { let (mut a, mut b) = (self.0, rhs); let mut res = 1; while b > 0 { if b & 1 == 1 { res = (res * a) % MOD; } a = (a * a) % MOD; b >>= 1u32; } Modint(res) } fn inv(&self) -> Self { self.pow(MOD - 2) } }",
        "}",
        "use modint::*;",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::*;",
        "\tconst MOD998: usize = 998244353;",
        "\ttype Modint998 = Modint<MOD998>;",
        "\t#[test]",
        "\tfn test_add() {",
        "\t\tlet x: Modint998 = 998244355.into();",
        "\t\tlet y: usize = 998244359;",
        "\t\tassert_eq!(x + y, 8 + MOD998);",
        "\t\tlet a: Modint998 = MOD998.into();",
        "\t\tlet b = 1000000007;",
        "\t\tlet c = 20021213;",
        "\t\tassert_eq!(a + b + c, 21776867);",
        "\t\tassert_eq!(a + b + c, (21776867 + MOD998));",
        "\t}",
        "\t#[test]",
        "\tfn test_neg() {",
        "\t\tlet x: Modint998 = 0.into();",
        "\t\tassert_eq!(-x, 0);",
        "\t\tlet y = Modint998::new(10);",
        "\t\tassert_eq!(-y, MOD998 - 10);",
        "\t\tlet z = Modint998::new(MOD998 + 200);",
        "\t\tassert_eq!(-z, MOD998 - 200);",
        "\t}",
        "\t#[test]",
        "\tfn test_sub() {",
        "\t\tlet x = Modint998::new(0);",
        "\t\tlet y = 1000000007;",
        "\t\tassert_eq!(x - y, 996488699);",
        "\t\tlet a: Modint998 = 288230376151711744.into(); // 1 << 58",
        "\t\tlet b: usize = 576460752303423488; // 1 << 59",
        "\t\tlet c: usize = 1152921504606846976; // 1 << 60",
        "\t\tassert_eq!(-a - b - c, 553154679);",
        "\t}",
        "\t#[test]",
        "\tfn test_pow() {",
        "\t\tlet x = Modint998::new(2);",
        "\t\tlet y: usize = 1000000007;",
        "\t\tassert_eq!(x.pow(y), 132727571);",
        "\t\tlet a: Modint998 = MOD998.into();",
        "\t\tlet b: usize = 1024;",
        "\t\tassert_eq!(a.pow(b), 0);",
        "\t}",
        "\t#[test]",
        "\tfn test_inv() {",
        "\t\tassert_eq!(Modint998::new(1).inv(), 1);",
        "\t\tassert_eq!(Modint998::new(2).inv(), 499122177);",
        "\t\tassert_eq!(Modint998::new(1000).inv(), 981274199);",
        "\t\tassert_eq!(Modint998::new(998244352).inv(), 998244352);",
        "\t}",
        "\t#[test]",
        "\tfn test_add_assign() {",
        "\t\tlet arr = vec![1, 2, 3];",
        "\t\tlet mut ans = 0;",
        "\t\tfor i in 0..3 {",
        "\t\t\tans += arr[i];",
        "\t\t}",
        "\t\tassert_eq!(ans, 6);",
        "\t}",
        "\t#[test]",
        "\tfn test_mul_assign() {",
        "\t\tlet mut fact = vec![Modint998::new(1); 20];",
        "\t\t// 階乗",
        "\t\tfor i in 1..20 {",
        "\t\t\tlet prv = fact[i - 1];",
        "\t\t\tfact[i] *= prv * i;",
        "\t\t}",
        "\t\tassert_eq!(",
        "\t\t\t&fact,",
        "\t\t\t&[",
        "\t\t\t\t1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600,",
        "\t\t\t\t237554682, 331032489, 972509923, 586493473, 986189864, 781263551, 868586527",
        "\t\t\t]",
        "\t\t);",
        "\t}",
        "}"
      ],
      "description": "Modintの構造体"
    },
    {
      "prefix": "weighted_union_find.rs",
      "body": [
        "use std::fmt::Debug;",
        "/// ## アーベル群",
        "pub trait Abel {",
        "\ttype E: Debug + Clone;",
        "\tconst I: Self::E;",
        "\tfn op(x: &Self::E, y: &Self::E) -> Self::E;",
        "\tfn inv(x: &Self::E) -> Self::E;",
        "}",
        "/// # 重み付きUnionFind",
        "pub struct WeightedUnionFind<G: Abel> {",
        "\tpar: Vec<usize>,",
        "\trank: Vec<usize>,",
        "\tweight: Vec<G::E>,",
        "\tpub group_count: usize,",
        "}",
        "impl<G: Abel> WeightedUnionFind<G> {",
        "\t/// UnionFindを構築",
        "\tpub fn new(n: usize) -> Self {",
        "\t\tWeightedUnionFind {",
        "\t\t\tpar: (0..n).collect(),",
        "\t\t\trank: vec![1; n],",
        "\t\t\tweight: vec![G::I; n],",
        "\t\t\tgroup_count: n,",
        "\t\t}",
        "\t}",
        "\t/// 根を求める",
        "\tpub fn root(&mut self, x: usize) -> usize {",
        "\t\tif self.par[x] == x {",
        "\t\t\treturn x;",
        "\t\t}",
        "\t\tlet r = self.root(self.par[x]);",
        "\t\tlet parent = self.weight[self.par[x]].clone();",
        "\t\tlet child = self.weight.get_mut(x).unwrap();",
        "\t\t*child = G::op(child, &parent);",
        "\t\tself.par[x] = r; // 経路圧縮",
        "\t\tr",
        "\t}",
        "\t/// 重みを求める",
        "\tpub fn weight(&mut self, x: usize) -> G::E {",
        "\t\tself.root(x); // 経路圧縮",
        "\t\tself.weight[x].clone()",
        "\t}",
        "\t/// 同一の集合に所属するか判定",
        "\tpub fn issame(&mut self, x: usize, y: usize) -> bool {",
        "\t\tself.root(x) == self.root(y)",
        "\t}",
        "\t/// 重みの差を求める",
        "\t/// - 同じグループにいない場合にはNone",
        "\tpub fn diff(&mut self, x: usize, y: usize) -> Option<G::E> {",
        "\t\tif self.issame(x, y) {",
        "\t\t\tlet res = G::op(&self.weight(y), &G::inv(&self.weight(x)));",
        "\t\t\treturn Some(res);",
        "\t\t}",
        "\t\tNone",
        "\t}",
        "\t/// 要素を結合",
        "\tpub fn unite(&mut self, mut x: usize, mut y: usize, mut weight: G::E) -> bool {",
        "\t\t// x,yそれぞれについて重み差分を補正",
        "\t\tweight = G::op(&weight, &self.weight(x));",
        "\t\tweight = G::op(&weight, &G::inv(&self.weight(y)));",
        "\t\tx = self.root(x);",
        "\t\ty = self.root(y);",
        "\t\tif x == y {",
        "\t\t\treturn false;",
        "\t\t}",
        "\t\t// 要素数が大きい方を子にすることで、高さを均等に保つ",
        "\t\tif self.rank[x] < self.rank[y] {",
        "\t\t\tstd::mem::swap(&mut x, &mut y);",
        "\t\t\tweight = G::inv(&weight);",
        "\t\t}",
        "\t\tself.par[y] = x;",
        "\t\tself.rank[x] += self.rank[y];",
        "\t\tself.group_count -= 1;",
        "\t\t// 重みの更新",
        "\t\tself.weight[y] = weight;",
        "\t\ttrue",
        "\t}",
        "\tpub fn size(&mut self, x: usize) -> usize {",
        "\t\tlet root = self.root(x);",
        "\t\tself.rank[root]",
        "\t}",
        "}",
        "pub mod Alg {",
        "\tuse super::Abel;",
        "\tpub struct Add;",
        "\timpl Abel for Add {",
        "\t\ttype E = isize;",
        "\t\tconst I: Self::E = 0;",
        "\t\tfn op(x: &Self::E, y: &Self::E) -> Self::E {",
        "\t\t\tx + y",
        "\t\t}",
        "\t\tfn inv(x: &Self::E) -> Self::E {",
        "\t\t\t-x",
        "\t\t}",
        "\t}",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::*;",
        "\t#[test]",
        "\tfn test_weighted_unionfind() {",
        "\t\t// 問題例:",
        "\t\t// https://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=7971476#3",
        "\t\tlet mut uf = WeightedUnionFind::<Alg::Add>::new(8);",
        "\t\tuf.unite(1, 3, 6);",
        "\t\tuf.unite(4, 6, 4);",
        "\t\tuf.unite(2, 5, 5);",
        "\t\tassert_eq!(uf.diff(1, 6), None);",
        "\t\tuf.unite(1, 2, 4);",
        "\t\tassert_eq!(uf.diff(3, 5), Some(3));",
        "\t\tassert_eq!(uf.diff(5, 3), Some(-3));",
        "\t\tassert_eq!(uf.diff(6, 2), None);",
        "\t\tuf.unite(2, 3, 2);",
        "\t\tuf.unite(3, 6, 6);",
        "\t\tassert_eq!(uf.diff(4, 5), Some(1));",
        "\t\tassert_eq!(uf.diff(5, 4), Some(-1));",
        "\t\tassert_eq!(uf.diff(6, 5), Some(-3));",
        "\t\tassert_eq!(uf.diff(5, 6), Some(3));",
        "\t}",
        "}"
      ],
      "description": "重み付きUnionFind"
    },
    {
      "prefix": "affine_transform.rs",
      "body": [
        "/// # AffineMatrix",
        "/// アフィン変換（3x3行列）",
        "#[derive(Debug, Clone, Copy)]",
        "pub struct AffineMatrix {",
        "\tarr: [[isize; 3]; 3],",
        "}",
        "impl AffineMatrix {",
        "\tpub fn e() -> Self {",
        "\t\tSelf {",
        "\t\t\tarr: [[1, 0, 0],",
        "\t\t\t\t  [0, 1, 0],",
        "\t\t\t\t  [0, 0, 1]]",
        "\t\t}",
        "\t}",
        "\tpub fn rotate90() -> Self {",
        "\t\tSelf {",
        "\t\t\tarr: [[0, -1, 0],",
        "\t\t\t\t  [1, 0, 0],",
        "\t\t\t\t  [0, 0, 1]]",
        "\t\t}",
        "\t}",
        "\tpub fn rotate270() -> Self {",
        "\t\tSelf {",
        "\t\t\tarr: [[0, 1, 0],",
        "\t\t\t\t  [-1, 0, 0],",
        "\t\t\t\t  [0, 0, 1]]",
        "\t\t} ",
        "\t}",
        "\tpub fn mirror_x(p: isize) -> Self {",
        "\t\tSelf {",
        "\t\t\tarr: [[-1, 0, 2*p],",
        "\t\t\t\t  [0, 1, 0],",
        "\t\t\t\t  [0, 0, 1]]",
        "\t\t}  ",
        "\t}",
        "\tpub fn mirror_y(p: isize) -> Self {",
        "\t\tSelf {",
        "\t\t\tarr: [[1, 0, 0],",
        "\t\t\t\t  [0, -1, 2*p],",
        "\t\t\t\t  [0, 0, 1]]",
        "\t\t}  ",
        "\t}",
        "\tpub fn dot(&self, other: &Self) -> Self {",
        "\t\tlet mut arr = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];",
        "\t\tfor i in 0..3 {",
        "\t\t\tfor j in 0..3 {",
        "\t\t\t\tfor k in 0..3 {",
        "\t\t\t\t\tarr[i][j] += self.arr[i][k] * other.arr[k][j];",
        "\t\t\t\t}",
        "\t\t\t}",
        "\t\t}",
        "\t\tSelf { arr }",
        "\t}",
        "\tpub fn apply(&self, vec: (isize, isize)) -> (isize, isize) {",
        "\t\t(",
        "\t\t\tself.arr[0][0] * vec.0 + self.arr[0][1] * vec.1 + self.arr[0][2],",
        "\t\t\tself.arr[1][0] * vec.0 + self.arr[1][1] * vec.1 + self.arr[1][2],",
        "\t\t)",
        "\t}",
        "}"
      ],
      "description": "アフィン変換"
    },
    {
      "prefix": "lazy_segment_tree.rs",
      "body": [
        "use std::ops::{",
        "\tBound::{Excluded, Included, Unbounded},",
        "\tRangeBounds,",
        "};",
        "/// 作用付きモノイド",
        "pub trait ExtMonoid {",
        "\t/// 要素のデータ型",
        "\ttype X: Clone + PartialEq;",
        "\t/// 作用素のデータ型",
        "\ttype M: Clone + PartialEq;",
        "\t/// 要素Xの単位元",
        "\tconst IX: Self::X;",
        "\t/// 作用素Mの単位元",
        "\tconst IM: Self::M;",
        "\t/// 要素同士の演算",
        "\tfn operate_x(x: &Self::X, y: &Self::X) -> Self::X;",
        "\t/// 要素に対する作用",
        "\tfn apply(x: &Self::X, y: &Self::M) -> Self::X;",
        "\t/// 作用素同士の演算",
        "\tfn operate_m(x: &Self::M, y: &Self::M) -> Self::M;",
        "\t/// 作用素の集約",
        "\tfn aggregate(x: &Self::M, p: usize) -> Self::M;",
        "}",
        "/// 遅延評価セグメント木",
        "#[derive(Debug)]",
        "pub struct LazySegmentTree<T: ExtMonoid> {",
        "\tpub size: usize,",
        "\toffset: usize,",
        "\tdata: Vec<T::X>,",
        "\tlazy: Vec<T::M>,",
        "}",
        "impl<T: ExtMonoid> LazySegmentTree<T> {",
        "\t#[inline]",
        "\tfn parse_range<R: RangeBounds<usize>>(&self, range: R) -> Option<(usize, usize)> {",
        "\t\tlet start = match range.start_bound() {",
        "\t\t\tUnbounded => 0,",
        "\t\t\tExcluded(&v) => v + 1,",
        "\t\t\tIncluded(&v) => v,",
        "\t\t}",
        "\t\t.min(self.size);",
        "\t\tlet end = match range.end_bound() {",
        "\t\t\tUnbounded => self.size,",
        "\t\t\tExcluded(&v) => v,",
        "\t\t\tIncluded(&v) => v + 1,",
        "\t\t}",
        "\t\t.min(self.size);",
        "\t\tif start <= end {",
        "\t\t\tSome((start, end))",
        "\t\t} else {",
        "\t\t\tNone",
        "\t\t}",
        "\t}",
        "\t/// 遅延評価セグメント木を初期化する",
        "\t/// - `n`: 配列サイズ",
        "\tpub fn new(n: usize) -> Self {",
        "\t\tlet offset = n.next_power_of_two();",
        "\t\tSelf {",
        "\t\t\tsize: n,",
        "\t\t\toffset,",
        "\t\t\tdata: vec![T::IX; offset << 1],",
        "\t\t\tlazy: vec![T::IM; offset << 1],",
        "\t\t}",
        "\t}",
        "\t/// 遅延値を評価",
        "\tfn eval(&mut self, idx: usize, len: usize) {",
        "\t\tif self.lazy[idx] == T::IM {",
        "\t\t\treturn;",
        "\t\t}",
        "\t\t// 葉でなければ子に伝搬",
        "\t\tif idx < self.offset {",
        "\t\t\tself.lazy[idx * 2] = T::operate_m(&self.lazy[idx * 2], &self.lazy[idx]);",
        "\t\t\tself.lazy[idx * 2 + 1] = T::operate_m(&self.lazy[idx * 2 + 1], &self.lazy[idx]);",
        "\t\t}",
        "\t\t// 自身を更新",
        "\t\tself.data[idx] = T::apply(&self.data[idx], &T::aggregate(&self.lazy[idx], len));",
        "\t\tself.lazy[idx] = T::IM;",
        "\t}",
        "\t/// 区間に`val`を作用させる",
        "\t/// - `range`: `[left, right)`",
        "\tpub fn set_range<R: RangeBounds<usize>>(&mut self, range: R, val: T::M) {",
        "\t\tif let Some((left, right)) = self.parse_range(range) {",
        "\t\t\tself.set_range_inner(left, right, val, 0, self.offset, 1);",
        "\t\t}",
        "\t}",
        "\tfn set_range_inner(",
        "\t\t&mut self,",
        "\t\tleft: usize,",
        "\t\tright: usize,",
        "\t\tval: T::M,",
        "\t\tbegin: usize,",
        "\t\tend: usize,",
        "\t\tidx: usize,",
        "\t) {",
        "\t\t// 遅延値を評価",
        "\t\tself.eval(idx, end - begin);",
        "\t\t// 区間を内包するとき",
        "\t\tif left <= begin && end <= right {",
        "\t\t\tself.lazy[idx] = T::operate_m(&self.lazy[idx], &val);",
        "\t\t\tself.eval(idx, end - begin);",
        "\t\t}",
        "\t\t// 区間が重なるとき",
        "\t\telse if left < end && begin < right {",
        "\t\t\tlet mid = (begin + end) / 2;",
        "\t\t\t// 左の子を更新",
        "\t\t\tself.set_range_inner(left, right, val.clone(), begin, mid, idx * 2);",
        "\t\t\t// 右の子を更新",
        "\t\t\tself.set_range_inner(left, right, val, mid, end, idx * 2 + 1);",
        "\t\t\t// 値を更新",
        "\t\t\tself.data[idx] = T::operate_x(&self.data[idx * 2], &self.data[idx * 2 + 1]);",
        "\t\t}",
        "\t}",
        "\t/// 区間を取得する",
        "\t/// - `range`: `[left, right)`",
        "\tpub fn get_range<R: RangeBounds<usize>>(&mut self, range: R) -> T::X {",
        "\t\tif let Some((left, right)) = self.parse_range(range) {",
        "\t\t\tself.get_range_inner(left, right, 0, self.offset, 1)",
        "\t\t} else {",
        "\t\t\tT::IX",
        "\t\t}",
        "\t}",
        "\tfn get_range_inner(",
        "\t\t&mut self,",
        "\t\tleft: usize,",
        "\t\tright: usize,",
        "\t\tbegin: usize,",
        "\t\tend: usize,",
        "\t\tidx: usize,",
        "\t) -> T::X {",
        "\t\t// 遅延値を評価",
        "\t\tself.eval(idx, end - begin);",
        "\t\t// 区間を含まない",
        "\t\tif end <= left || right <= begin {",
        "\t\t\tT::IX",
        "\t\t}",
        "\t\t// 区間を包含する",
        "\t\telse if left <= begin && end <= right {",
        "\t\t\tself.data[idx].clone()",
        "\t\t}",
        "\t\t// 区間が重なる",
        "\t\telse {",
        "\t\t\tlet mid = (begin + end) / 2;",
        "\t\t\tlet l_val = self.get_range_inner(left, right, begin, mid, idx * 2);",
        "\t\t\tlet r_val = self.get_range_inner(left, right, mid, end, idx * 2 + 1);",
        "\t\t\tT::operate_x(&l_val, &r_val)",
        "\t\t}",
        "\t}",
        "}",
        "pub mod ExtAlg {",
        "\tuse super::ExtMonoid;",
        "\t/// ## RSQandRAQ",
        "\t/// - 区間加算",
        "\t/// - 区間和",
        "\t#[derive(Debug)]",
        "\tpub struct RSQandRAQ;",
        "\timpl ExtMonoid for RSQandRAQ {",
        "\t\ttype X = isize;",
        "\t\ttype M = isize;",
        "\t\tconst IX: Self::X = 0;",
        "\t\tconst IM: Self::M = 0;",
        "\t\tfn operate_x(x: &Self::X, y: &Self::X) -> Self::X {",
        "\t\t\tx + y",
        "\t\t}",
        "\t\tfn apply(x: &Self::X, y: &Self::M) -> Self::X {",
        "\t\t\tx + y",
        "\t\t}",
        "\t\tfn operate_m(x: &Self::M, y: &Self::M) -> Self::M {",
        "\t\t\tx + y",
        "\t\t}",
        "\t\tfn aggregate(x: &Self::M, p: usize) -> Self::M {",
        "\t\t\tx * p as isize",
        "\t\t}",
        "\t}",
        "\t/// ## RMQandRUQ",
        "\t/// - 区間更新",
        "\t/// - 区間最小値",
        "\t#[derive(Debug)]",
        "\tpub struct RMQandRUQ;",
        "\timpl ExtMonoid for RMQandRUQ {",
        "\t\ttype X = isize;",
        "\t\ttype M = isize;",
        "\t\tconst IM: Self::M = (1 << 31) - 1;",
        "\t\tconst IX: Self::X = (1 << 31) - 1;",
        "\t\tfn operate_x(x: &Self::X, y: &Self::X) -> Self::X {",
        "\t\t\t*x.min(y)",
        "\t\t}",
        "\t\tfn apply(_x: &Self::X, y: &Self::M) -> Self::X {",
        "\t\t\t*y",
        "\t\t}",
        "\t\tfn operate_m(_x: &Self::M, y: &Self::M) -> Self::M {",
        "\t\t\t*y",
        "\t\t}",
        "\t\tfn aggregate(x: &Self::M, _p: usize) -> Self::M {",
        "\t\t\t*x",
        "\t\t}",
        "\t}",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::*;",
        "\t#[test]",
        "\tfn test_RSQ_and_RAQ_hand() {",
        "\t\tlet mut seg = LazySegmentTree::<ExtAlg::RSQandRAQ>::new(10);",
        "\t\t// [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",
        "\t\tassert_eq!(seg.get_range(..), 0);",
        "\t\tassert_eq!(seg.get_range(..5), 0);",
        "\t\tassert_eq!(seg.get_range(5..), 0);",
        "\t\tassert_eq!(seg.get_range(3..8), 0);",
        "\t\tseg.set_range(0..4, 2);",
        "\t\t// [2, 2, 2, 2, 0, 0, 0, 0, 0, 0]",
        "\t\tassert_eq!(seg.get_range(..), 8);",
        "\t\tassert_eq!(seg.get_range(..5), 8);",
        "\t\tassert_eq!(seg.get_range(5..), 0);",
        "\t\tassert_eq!(seg.get_range(3..8), 2);",
        "\t\tseg.set_range(4.., 5);",
        "\t\t// [2, 2, 2, 2, 5, 5, 5, 5, 5, 5]",
        "\t\tassert_eq!(seg.get_range(..), 38);",
        "\t\tassert_eq!(seg.get_range(..5), 13);",
        "\t\tassert_eq!(seg.get_range(5..), 25);",
        "\t\tassert_eq!(seg.get_range(3..8), 22);",
        "\t\tseg.set_range(2..=5, -3);",
        "\t\t// [2, 2, -1, -1, 2, 2, 5, 5, 5, 5]",
        "\t\tassert_eq!(seg.get_range(..), 26);",
        "\t\tassert_eq!(seg.get_range(..5), 4);",
        "\t\tassert_eq!(seg.get_range(5..), 22);",
        "\t\tassert_eq!(seg.get_range(3..8), 13);",
        "\t\tseg.set_range(8..=10, -10);",
        "\t\t// [2, 2, -1, -1, 2, 2, 5, 5, -5, -5]",
        "\t\tassert_eq!(seg.get_range(..), 6);",
        "\t\tassert_eq!(seg.get_range(..5), 4);",
        "\t\tassert_eq!(seg.get_range(5..), 2);",
        "\t\tassert_eq!(seg.get_range(3..8), 13);",
        "\t}",
        "\t#[test]",
        "\tfn test_RMQ_and_RUQ_hand() {",
        "\t\tconst INF: isize = (1 << 31) - 1;",
        "\t\tlet mut seg = LazySegmentTree::<ExtAlg::RMQandRUQ>::new(10);",
        "\t\t// [INF, INF, INF, INF, INF, INF, INF, INF, INF, INF]",
        "\t\tassert_eq!(seg.get_range(..), INF);",
        "\t\tassert_eq!(seg.get_range(..5), INF);",
        "\t\tassert_eq!(seg.get_range(5..), INF);",
        "\t\tassert_eq!(seg.get_range(3..8), INF);",
        "\t\tseg.set_range(0..4, 2);",
        "\t\t// [2, 2, 2, 2, INF, INF, INF, INF, INF, INF]",
        "\t\tassert_eq!(seg.get_range(..), 2);",
        "\t\tassert_eq!(seg.get_range(..5), 2);",
        "\t\tassert_eq!(seg.get_range(5..), INF);",
        "\t\tassert_eq!(seg.get_range(3..8), 2);",
        "\t\tseg.set_range(4.., 5);",
        "\t\t// [2, 2, 2, 2, 5, 5, 5, 5, 5, 5]",
        "\t\tassert_eq!(seg.get_range(..), 2);",
        "\t\tassert_eq!(seg.get_range(..5), 2);",
        "\t\tassert_eq!(seg.get_range(5..), 5);",
        "\t\tassert_eq!(seg.get_range(3..8), 2);",
        "\t\tseg.set_range(2..=5, -3);",
        "\t\t// [2, 2, -3, -3, -3, -3, 5, 5, 5, 5]",
        "\t\tassert_eq!(seg.get_range(..), -3);",
        "\t\tassert_eq!(seg.get_range(..5), -3);",
        "\t\tassert_eq!(seg.get_range(5..), -3);",
        "\t\tassert_eq!(seg.get_range(3..8), -3);",
        "\t\tseg.set_range(8..=10, -10);",
        "\t\t// [2, 2, -3, -3, -3, -3, 5, 5, -10, -10]",
        "\t\tassert_eq!(seg.get_range(..), -10);",
        "\t\tassert_eq!(seg.get_range(..5), -3);",
        "\t\tassert_eq!(seg.get_range(5..), -10);",
        "\t\tassert_eq!(seg.get_range(3..8), -3);",
        "\t}",
        "}"
      ],
      "description": "遅延評価セグメント木"
    },
    {
      "prefix": "segment_tree.rs",
      "body": [
        "use std::fmt;",
        "use std::ops::{",
        "\tBound::{Excluded, Included, Unbounded},",
        "\tDeref, DerefMut, Index, RangeBounds,",
        "};",
        "/// モノイド",
        "pub trait Monoid {",
        "\t/// 元の型",
        "\ttype Val: fmt::Debug + Clone + PartialEq;",
        "\t/// 単位元",
        "\tconst E: Self::Val;",
        "\t/// 演算",
        "\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val;",
        "}",
        "/// # SegmentTree (Monoid)",
        "/// - 抽象化セグメント木",
        "pub struct SegmentTree<T: Monoid> {",
        "\tpub size: usize,",
        "\toffset: usize,",
        "\tdata: Vec<T::Val>,",
        "}",
        "impl<T: Monoid> Index<usize> for SegmentTree<T> {",
        "\ttype Output = T::Val;",
        "\tfn index(&self, idx: usize) -> &Self::Output {",
        "\t\t&self.data[self.offset + idx]",
        "\t}",
        "}",
        "impl<T: Monoid> SegmentTree<T> {",
        "\t#[inline]",
        "\tfn parse_range<R: RangeBounds<usize>>(&self, range: R) -> Option<(usize, usize)> {",
        "\t\tlet start = match range.start_bound() {",
        "\t\t\tUnbounded => 0,",
        "\t\t\tExcluded(&v) => v + 1,",
        "\t\t\tIncluded(&v) => v,",
        "\t\t}",
        "\t\t.min(self.size);",
        "\t\tlet end = match range.end_bound() {",
        "\t\t\tUnbounded => self.size,",
        "\t\t\tExcluded(&v) => v,",
        "\t\t\tIncluded(&v) => v + 1,",
        "\t\t}",
        "\t\t.min(self.size);",
        "\t\tif start <= end {",
        "\t\t\tSome((start, end))",
        "\t\t} else {",
        "\t\t\tNone",
        "\t\t}",
        "\t}",
        "\t/// ## new",
        "\t/// セグメント木を初期化する",
        "\tpub fn new(n: usize) -> Self {",
        "\t\tlet offset = n.next_power_of_two();",
        "\t\tSelf {",
        "\t\t\tsize: n,",
        "\t\t\toffset,",
        "\t\t\tdata: vec![T::E; offset << 1],",
        "\t\t}",
        "\t}",
        "\tfn update(&mut self, index: usize, value: T::Val) {",
        "\t\tlet mut i = index + self.offset;",
        "\t\tself.data[i] = value;",
        "\t\twhile i > 1 {",
        "\t\t\ti >>= 1;",
        "\t\t\tlet lch = i << 1;",
        "\t\t\tself.data[i] = T::op(&self.data[lch], &self.data[lch + 1]);",
        "\t\t}",
        "\t}",
        "\t/// 可変な参照を返す",
        "\tpub fn get_mut(&mut self, i: usize) -> Option<ValMut<'_, T>> {",
        "\t\tif i < self.offset {",
        "\t\t\tlet default = self.index(i).clone();",
        "\t\t\tSome(ValMut {",
        "\t\t\t\tsegtree: self,",
        "\t\t\t\tidx: i,",
        "\t\t\t\tnew_val: default,",
        "\t\t\t})",
        "\t\t} else {",
        "\t\t\tNone",
        "\t\t}",
        "\t}",
        "\t/// 区間`range`の集約を行う",
        "\tpub fn get_range<R: RangeBounds<usize>>(&self, range: R) -> T::Val {",
        "\t\tlet parsed = self.parse_range(range);",
        "\t\tif parsed.is_none() {",
        "\t\t\treturn T::E;",
        "\t\t}",
        "\t\tlet (start, end) = parsed.unwrap();",
        "\t\t// 全体の値を取得",
        "\t\tif (start, end) == (0, self.offset) {",
        "\t\t\treturn self.data[1].clone();",
        "\t\t}",
        "\t\t// 値の取得",
        "\t\tlet mut l = self.offset + start;",
        "\t\tlet mut r = self.offset + end;",
        "\t\tlet (mut res_l, mut res_r) = (T::E, T::E);",
        "\t\twhile l < r {",
        "\t\t\tif l & 1 == 1 {",
        "\t\t\t\tres_l = T::op(&res_l, &self.data[l]);",
        "\t\t\t\tl += 1;",
        "\t\t\t}",
        "\t\t\tif r & 1 == 1 {",
        "\t\t\t\tr -= 1;",
        "\t\t\t\tres_r = T::op(&self.data[r], &res_r);",
        "\t\t\t}",
        "\t\t\tl >>= 1;",
        "\t\t\tr >>= 1;",
        "\t\t}",
        "\t\tT::op(&res_l, &res_r)",
        "\t}",
        "}",
        "impl<T: Monoid> From<&Vec<T::Val>> for SegmentTree<T> {",
        "\tfn from(src: &Vec<T::Val>) -> Self {",
        "\t\tlet mut seg = Self::new(src.len());",
        "\t\tfor (i, v) in src.iter().enumerate() {",
        "\t\t\tseg.data[seg.offset + i] = v.clone();",
        "\t\t}",
        "\t\tfor i in (0..seg.offset).rev() {",
        "\t\t\tlet lch = i << 1;",
        "\t\t\tseg.data[i] = T::op(&seg.data[lch], &seg.data[lch + 1]);",
        "\t\t}",
        "\t\tseg",
        "\t}",
        "}",
        "impl<T: Monoid> std::fmt::Debug for SegmentTree<T> {",
        "\tfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
        "\t\twrite!(f, \\\"SegmentTree {{ [\\\").ok();",
        "\t\tfor i in 0..self.size {",
        "\t\t\tif i + 1 < self.size {",
        "\t\t\t\twrite!(f, \\\"{:?}, \\\", self.data[self.offset + i]).ok();",
        "\t\t\t} else {",
        "\t\t\t\twrite!(f, \\\"{:?}\\\", self.data[self.offset + i]).ok();",
        "\t\t\t}",
        "\t\t}",
        "\t\twrite!(f, \\\"] }}\\\")",
        "\t}",
        "}",
        "pub struct ValMut<'a, T: 'a + Monoid> {",
        "\tsegtree: &'a mut SegmentTree<T>,",
        "\tidx: usize,",
        "\tnew_val: T::Val,",
        "}",
        "impl<T: Monoid> fmt::Debug for ValMut<'_, T> {",
        "\tfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
        "\t\tf.debug_tuple(\\\"ValMut\\\")",
        "\t\t\t.field(&self.segtree.index(self.idx))",
        "\t\t\t.finish()",
        "\t}",
        "}",
        "impl<T: Monoid> Drop for ValMut<'_, T> {",
        "\tfn drop(&mut self) {",
        "\t\tself.segtree.update(self.idx, self.new_val.clone());",
        "\t}",
        "}",
        "impl<T: Monoid> Deref for ValMut<'_, T> {",
        "\ttype Target = T::Val;",
        "\tfn deref(&self) -> &Self::Target {",
        "\t\t&self.segtree[self.idx]",
        "\t}",
        "}",
        "impl<T: Monoid> DerefMut for ValMut<'_, T> {",
        "\tfn deref_mut(&mut self) -> &mut Self::Target {",
        "\t\t&mut self.new_val",
        "\t}",
        "}",
        "/// さまざまな代数的構造",
        "pub mod Alg {",
        "\tuse super::Monoid;",
        "\t/// 和",
        "\tpub struct Add;",
        "\timpl Monoid for Add {",
        "\t\ttype Val = isize;",
        "\t\tconst E: Self::Val = 0;",
        "\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
        "\t\t\tleft + right",
        "\t\t}",
        "\t}",
        "\t/// 積",
        "\tpub struct Mul;",
        "\timpl Monoid for Mul {",
        "\t\ttype Val = isize;",
        "\t\tconst E: Self::Val = 1;",
        "\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
        "\t\t\tleft * right",
        "\t\t}",
        "\t}",
        "\t/// bit単位の排他的論理和",
        "\tpub struct Xor;",
        "\timpl Monoid for Xor {",
        "\t\ttype Val = usize;",
        "\t\tconst E: Self::Val = 0;",
        "\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
        "\t\t\tleft ^ right",
        "\t\t}",
        "\t}",
        "\t/// 最小値",
        "\tpub struct Min;",
        "\timpl Monoid for Min {",
        "\t\ttype Val = isize;",
        "\t\tconst E: Self::Val = (1 << 31) - 1;",
        "\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
        "\t\t\t*left.min(right)",
        "\t\t}",
        "\t}",
        "\t/// 最大値",
        "\tpub struct Max;",
        "\timpl Monoid for Max {",
        "\t\ttype Val = isize;",
        "\t\tconst E: Self::Val = -((1 << 31) - 1);",
        "\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
        "\t\t\t*left.max(right)",
        "\t\t}",
        "\t}",
        "\t/// 最小公倍数",
        "\tpub struct GCD;",
        "\timpl Monoid for GCD {",
        "\t\ttype Val = usize;",
        "\t\tconst E: Self::Val = 0;",
        "\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
        "\t\t\tgcd(*left, *right)",
        "\t\t}",
        "\t}",
        "\tpub fn gcd(a: usize, b: usize) -> usize {",
        "\t\tif b == 0 {",
        "\t\t\ta",
        "\t\t} else {",
        "\t\t\tgcd(b, a % b)",
        "\t\t}",
        "\t}",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::*;",
        "\t#[test]",
        "\tfn test_get_point() {",
        "\t\tlet segtree = SegmentTree::<Alg::Mul>::from(&vec![1, 2, 3, 4, 5]);",
        "\t\tassert_eq!(segtree[0], 1);",
        "\t\tassert_eq!(segtree[3], 4);",
        "\t}",
        "\t#[test]",
        "\tfn test_RSQ() {",
        "\t\tlet mut segtree = SegmentTree::<Alg::Add>::new(3);",
        "\t\t// segtree.update(0, 1);",
        "\t\t*segtree.get_mut(0).unwrap() += 1;",
        "\t\t*segtree.get_mut(1).unwrap() += 2;",
        "\t\t*segtree.get_mut(2).unwrap() += 3;",
        "\t\t// [1, 2, 3]",
        "\t\tassert_eq!(segtree.get_range(0..2), 3);",
        "\t\tassert_eq!(segtree.get_range(1..2), 2);",
        "\t\tassert_eq!(segtree.get_range(1..=2), 5);",
        "\t\tassert_eq!(segtree.get_range(..), 6);",
        "\t}",
        "\t#[test]",
        "\tfn test_RMQ() {",
        "\t\tconst INF: usize = (1 << 31) - 1;",
        "\t\tlet mut segtree = SegmentTree::<Alg::Min>::new(3);",
        "\t\tassert_eq!(segtree.get_range(..1), (1 << 31) - 1);",
        "\t\t*segtree.get_mut(0).unwrap() = 5;",
        "\t\tassert_eq!(segtree.get_range(..1), 5);",
        "\t}",
        "\t#[test]",
        "\tfn test_from_slice() {",
        "\t\tconst INF: isize = -(1 << 31) + 1;",
        "\t\tlet arr = vec![20, 4, 5, 6, 8, 9, 100];",
        "\t\tlet mut segtree = SegmentTree::<Alg::Max>::from(&arr);",
        "\t\tassert_eq!(segtree.get_range(0..), 100);",
        "\t\tassert_eq!(segtree.get_range(2..5), 8);",
        "\t\tsegtree.update(0, 200);",
        "\t\tassert_eq!(segtree.get_range(..), 200);",
        "\t\tassert_eq!(segtree.get_range(2..5), 8);",
        "\t\tassert_eq!(segtree.get_range(5..10), 100);",
        "\t\tassert_eq!(segtree.get_range(10..20), INF);",
        "\t}",
        "\t#[test]",
        "\tfn test_debug_print() {",
        "\t\tconst INF: isize = -(1 << 31) + 1;",
        "\t\tlet arr = vec![20, 4, 5, 6, 8, 9, 100];",
        "\t\tlet segtree = SegmentTree::<Alg::Max>::from(&arr);",
        "\t\tlet dbg = format!(\\\"{:?}\\\", &segtree);",
        "\t\tassert_eq!(&dbg, \\\"SegmentTree { [20, 4, 5, 6, 8, 9, 100] }\\\");",
        "\t}",
        "}"
      ],
      "description": "セグメント木"
    },
    {
      "prefix": "ord_chr.rs",
      "body": [
        "/// ## ord",
        "/// `A`を`0`とするascii文字(`A~Za~z`)のインデックスを返す",
        "pub fn ord(c: char) -> usize {",
        "\tlet a = 'A' as u32;",
        "\tlet c = c as u32;",
        "\t(c - a) as usize",
        "}",
        "/// ## chr",
        "/// `chr(0) = A`であるようなascii文字(`A~Za~z`)を返す",
        "pub fn chr(i: usize) -> char {",
        "\tlet a = 'A' as u32;",
        "\tchar::from_u32(a + i as u32).unwrap()",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::*;",
        "\t#[test]",
        "\tfn test_ord() {",
        "\t\tfor (i, c) in ('A'..'z').enumerate() {",
        "\t\t\tassert_eq!(ord(c), i);",
        "\t\t}",
        "\t}",
        "\t#[test]",
        "\tfn test_chr() {",
        "\t\tfor (i, c) in ('A'..'z').enumerate() {",
        "\t\t\tassert_eq!(chr(i), c);",
        "\t\t}",
        "\t}",
        "}"
      ],
      "description": "`char`と`usize`の相互変換"
    },
    {
      "prefix": "run_length.rs",
      "body": [
        "/// ## ランレングス圧縮",
        "/// - スライスからエンコードを行う",
        "pub fn run_length_encode<T>(arr: &[T]) -> Vec<(T, usize)>",
        "where",
        "\tT: PartialEq + Copy,",
        "{",
        "\tlet mut res = vec![];",
        "\tlet mut cur = arr[0];",
        "\tlet mut cnt = 1;",
        "\tfor &val in &arr[1..] {",
        "\t\tif val == cur {",
        "\t\t\tcnt += 1;",
        "\t\t} else {",
        "\t\t\tres.push((cur, cnt));",
        "\t\t\tcur = val;",
        "\t\t\tcnt = 1;",
        "\t\t}",
        "\t}",
        "\tlet last_elem = *arr.last().unwrap();",
        "\tres.push((last_elem, cnt));",
        "\tres",
        "}",
        "/// ## ランレングス圧縮 (from Iterator)",
        "/// - イテレータからエンコードを行う",
        "pub fn run_length_encode_from<T, I>(mut itr: I) -> Vec<(T, usize)>",
        "where",
        "\tT: PartialEq,",
        "\tI: Iterator<Item = T>,",
        "{",
        "\tlet mut res = vec![];",
        "\tlet mut cur = itr.next().unwrap();",
        "\tlet mut cnt = 1;",
        "\tfor val in itr {",
        "\t\tif val == cur {",
        "\t\t\tcnt += 1;",
        "\t\t} else {",
        "\t\t\tres.push((cur, cnt));",
        "\t\t\tcur = val;",
        "\t\t\tcnt = 1;",
        "\t\t}",
        "\t}",
        "\tres.push((cur, cnt));",
        "\tres",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::*;",
        "\t#[test]",
        "\tfn test_usize() {",
        "\t\tlet arr = vec![0, 1, 1, 3, 3, 3, 2, 2, 1, 5, 9, 0];",
        "\t\tlet comp = run_length_encode(&arr);",
        "\t\tlet ans = vec![",
        "\t\t\t(0, 1),",
        "\t\t\t(1, 2),",
        "\t\t\t(3, 3),",
        "\t\t\t(2, 2),",
        "\t\t\t(1, 1),",
        "\t\t\t(5, 1),",
        "\t\t\t(9, 1),",
        "\t\t\t(0, 1),",
        "\t\t];",
        "\t\tassert_eq!(comp, ans);",
        "\t}",
        "\t#[test]",
        "\tfn test_string() {",
        "\t\tlet strs = vec![",
        "\t\t\t\\\"Welcome\\\", \\\"to\\\", \\\"Moo\\\", \\\"Moo\\\", \\\"Moo\\\", \\\"nsi\\\", \\\"nsi\\\", \\\"nsi\\\", \\\"nsi\\\", \\\"...\\\", \\\"nside.\\\",",
        "\t\t];",
        "\t\tlet comp = run_length_encode(&strs);",
        "\t\tlet ans = vec![",
        "\t\t\t(\\\"Welcome\\\", 1),",
        "\t\t\t(\\\"to\\\", 1),",
        "\t\t\t(\\\"Moo\\\", 3),",
        "\t\t\t(\\\"nsi\\\", 4),",
        "\t\t\t(\\\"...\\\", 1),",
        "\t\t\t(\\\"nside.\\\", 1),",
        "\t\t];",
        "\t\t// [引用] \\\"Mother2\\\", nintendo, 1989",
        "\t\tassert_eq!(comp, ans);",
        "\t}",
        "\t#[test]",
        "\tfn test_chars() {",
        "\t\tlet str = \\\"aaaxbbbbbbccddef\\\";",
        "\t\tlet chars: Vec<char> = str.chars().collect();",
        "\t\tlet comp = run_length_encode(&chars);",
        "\t\tlet ans = vec![",
        "\t\t\t('a', 3),",
        "\t\t\t('x', 1),",
        "\t\t\t('b', 6),",
        "\t\t\t('c', 2),",
        "\t\t\t('d', 2),",
        "\t\t\t('e', 1),",
        "\t\t\t('f', 1),",
        "\t\t];",
        "\t\tassert_eq!(comp, ans);",
        "\t}",
        "\t#[test]",
        "\tfn test_chars_from_iter() {",
        "\t\tlet str = \\\"aaaxbbbbbbccddef\\\";",
        "\t\tlet chars: Vec<char> = str.chars().collect();",
        "\t\tlet comp = run_length_encode_from(chars.iter());",
        "\t\tlet ans = vec![",
        "\t\t\t(&'a', 3),",
        "\t\t\t(&'x', 1),",
        "\t\t\t(&'b', 6),",
        "\t\t\t(&'c', 2),",
        "\t\t\t(&'d', 2),",
        "\t\t\t(&'e', 1),",
        "\t\t\t(&'f', 1),",
        "\t\t];",
        "\t\tprintln!(\\\"{:?}\\\", comp);",
        "\t\tassert_eq!(comp, ans);",
        "\t}",
        "}"
      ],
      "description": "ランレングス圧縮"
    },
    {
      "prefix": "bit.rs",
      "body": [
        "use std::{",
        "\tfmt::Debug,",
        "\tops::{",
        "\t\tBound::{Excluded, Included, Unbounded},",
        "\t\tRangeBounds,",
        "\t},",
        "};",
        "/// # Monoid",
        "/// - モノイド",
        "pub trait Monoid {",
        "\t/// 値の型",
        "\ttype Val: Debug + Clone + PartialEq;",
        "\t/// 単位元",
        "\tconst E: Self::Val;",
        "\t/// 演算",
        "\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val;",
        "}",
        "/// モノイドに対する逆元の実装",
        "pub trait InversableMonoid: Monoid {",
        "\tfn inv(val: &Self::Val) -> Self::Val;",
        "}",
        "/// モノイドに対する順序の実装",
        "pub trait OrderedMonoid: Monoid {",
        "\tfn lt(left: &Self::Val, right: &Self::Val) -> bool;",
        "\tfn le(left: &Self::Val, right: &Self::Val) -> bool;",
        "}",
        "/// # BinaryIndexedTree",
        "/// - `0-indexed`なインターフェースを持つBIT",
        "pub struct BIT<T: Monoid> {",
        "\tpub size: usize,",
        "\tarr: Vec<T::Val>,",
        "}",
        "impl<T: Monoid> BIT<T> {",
        "\t#[inline]",
        "\tfn lsb(x: usize) -> usize {",
        "\t\tx & x.wrapping_neg()",
        "\t}",
        "\t/// BITの初期化を行う",
        "\t/// - `n`: 列の長さ",
        "\tpub fn new(n: usize) -> Self {",
        "\t\tBIT {",
        "\t\t\tsize: n,",
        "\t\t\tarr: vec![T::E; n + 1],",
        "\t\t}",
        "\t}",
        "\t/// 一点加算を行う",
        "\t/// - `i`: 加算を行うインデックス（`0-indexed`）",
        "\t/// - `x`: 加算する値",
        "\tpub fn add(&mut self, mut i: usize, x: T::Val) {",
        "\t\ti += 1;",
        "\t\twhile i <= self.size {",
        "\t\t\tself.arr[i] = T::op(&self.arr[i], &x);",
        "\t\t\ti += Self::lsb(i);",
        "\t\t}",
        "\t}",
        "\t/// 先頭からの和を求める",
        "\t/// - `i`: 区間`[0,i)`に対しての総和（`0-indexed`）",
        "\tpub fn prefix_sum(&self, mut i: usize) -> T::Val {",
        "\t\tlet mut res = T::E;",
        "\t\twhile i != 0 {",
        "\t\t\tres = T::op(&res, &self.arr[i]);",
        "\t\t\ti -= Self::lsb(i);",
        "\t\t}",
        "\t\tres",
        "\t}",
        "}",
        "impl<T: InversableMonoid> BIT<T> {",
        "\t#[inline]",
        "\tfn parse_range<R: RangeBounds<usize>>(&self, range: R) -> Option<(usize, usize)> {",
        "\t\tlet start = match range.start_bound() {",
        "\t\t\tUnbounded => 0,",
        "\t\t\tExcluded(&v) => v + 1,",
        "\t\t\tIncluded(&v) => v,",
        "\t\t}",
        "\t\t.min(self.size);",
        "\t\tlet end = match range.end_bound() {",
        "\t\t\tUnbounded => self.size,",
        "\t\t\tExcluded(&v) => v,",
        "\t\t\tIncluded(&v) => v + 1,",
        "\t\t}",
        "\t\t.min(self.size);",
        "\t\tif start <= end {",
        "\t\t\tSome((start, end))",
        "\t\t} else {",
        "\t\t\tNone",
        "\t\t}",
        "\t}",
        "\t/// 任意の区間の和を求める",
        "\t/// - `range`: 区間を表すRangeオブジェクト",
        "\tfn sum<R: RangeBounds<usize>>(&self, range: R) -> T::Val {",
        "\t\tif let Some((i, j)) = self.parse_range(range) {",
        "\t\t\tT::op(&self.prefix_sum(j), &T::inv(&self.prefix_sum(i)))",
        "\t\t} else {",
        "\t\t\tT::E",
        "\t\t}",
        "\t}",
        "}",
        "impl<T: Monoid> From<&Vec<T::Val>> for BIT<T> {",
        "\t/// ベクターの参照からBITを作成",
        "\tfn from(src: &Vec<T::Val>) -> Self {",
        "\t\tlet size = src.len();",
        "\t\tlet mut arr = vec![T::E; size + 1];",
        "\t\tfor i in 1..=size {",
        "\t\t\tlet x = src[i - 1].clone();",
        "\t\t\tarr[i] = T::op(&arr[i], &x);",
        "\t\t\tlet j = i + Self::lsb(i);",
        "\t\t\tif j < size + 1 {",
        "\t\t\t\tarr[j] = T::op(&arr[j], &arr[i].clone());",
        "\t\t\t}",
        "\t\t}",
        "\t\tSelf { size, arr }",
        "\t}",
        "}",
        "impl<T: OrderedMonoid> BIT<T> {",
        "\t/// `lower_bound`/`upper_bound`を共通化した実装",
        "\tfn binary_search<F>(&self, w: T::Val, compare: F) -> usize",
        "\twhere",
        "\t\tF: Fn(&T::Val, &T::Val) -> bool",
        "\t{",
        "\t\tlet mut sum = T::E;",
        "\t\tlet mut idx = 0;",
        "\t\tlet mut d = self.size.next_power_of_two() / 2;",
        "\t\twhile d != 0 {",
        "\t\t\tif idx + d <= self.size {",
        "\t\t\t\tlet nxt = T::op(&sum, &self.arr[idx + d]);",
        "\t\t\t\tif compare(&nxt, &w) {",
        "\t\t\t\t\tsum = nxt;",
        "\t\t\t\t\tidx += d;",
        "\t\t\t\t}",
        "\t\t\t}",
        "\t\t\td >>= 1;",
        "\t\t}",
        "\t\tidx",
        "\t}",
        "\t/// `a_0 + a_1 + ... + a_i >= w`となる最小の`i`を求める",
        "\tpub fn lower_bound(&self, w: T::Val) -> usize {",
        "\t\tself.binary_search(w, T::lt)",
        "\t}",
        "\t/// `a_0 + a_1 + ... + a_i > w`となる最小の`i`を求める",
        "\tpub fn upper_bound(&self, w: T::Val) -> usize {",
        "\t\tself.binary_search(w, T::le)",
        "\t}",
        "}",
        "impl<T: InversableMonoid> Debug for BIT<T> {",
        "\tfn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
        "\t\twrite!(f, \\\"BIT {{ [\\\")?;",
        "\t\tfor i in 0..self.size - 1 {",
        "\t\t\twrite!(f, \\\"{:?}, \\\", self.sum(i..i + 1))?;",
        "\t\t}",
        "\t\twrite!(f, \\\"{:?}] }}\\\", self.sum(self.size - 1..self.size))",
        "\t}",
        "}",
        "pub mod Alg {",
        "\tuse super::{InversableMonoid, Monoid, OrderedMonoid};",
        "\t#[derive(Debug)]",
        "\tpub struct Add;",
        "\timpl Monoid for Add {",
        "\t\ttype Val = isize;",
        "\t\tconst E: Self::Val = 0;",
        "\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
        "\t\t\tleft + right",
        "\t\t}",
        "\t}",
        "\timpl InversableMonoid for Add {",
        "\t\tfn inv(val: &Self::Val) -> Self::Val {",
        "\t\t\t-val",
        "\t\t}",
        "\t}",
        "\timpl OrderedMonoid for Add {",
        "\t\tfn lt(left: &Self::Val, right: &Self::Val) -> bool {",
        "\t\t\tleft < right",
        "\t\t}",
        "\t\tfn le(left: &Self::Val, right: &Self::Val) -> bool {",
        "\t\t\tleft <= right",
        "\t\t}",
        "\t}",
        "\t#[derive(Debug)]",
        "\tpub struct Mul;",
        "\timpl Monoid for Mul {",
        "\t\ttype Val = isize;",
        "\t\tconst E: Self::Val = 1;",
        "\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
        "\t\t\tleft + right",
        "\t\t}",
        "\t}",
        "\t#[derive(Debug)]",
        "\tpub struct Xor;",
        "\timpl Monoid for Xor {",
        "\t\ttype Val = usize;",
        "\t\tconst E: Self::Val = 0;",
        "\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
        "\t\t\tleft ^ right",
        "\t\t}",
        "\t}",
        "\timpl InversableMonoid for Xor {",
        "\t\tfn inv(val: &Self::Val) -> Self::Val {",
        "\t\t\t*val",
        "\t\t}",
        "\t}",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::*;",
        "\t#[test]",
        "\tfn test_new() {",
        "\t\tlet mut bit = BIT::<Alg::Add>::new(5);",
        "\t\tbit.add(0, 20);",
        "\t\tbit.add(2, -5);",
        "\t\tlet sum_5 = bit.prefix_sum(5);",
        "\t\tassert_eq!(sum_5, 15);",
        "\t\tbit.add(4, 10);",
        "\t\tbit.add(1, -20);",
        "\t\tlet sum_2 = bit.prefix_sum(2);",
        "\t\tassert_eq!(sum_2, 0);",
        "\t\tlet sum_all = bit.prefix_sum(5);",
        "\t\tassert_eq!(sum_all, 5);",
        "\t}",
        "\t#[test]",
        "\tfn test_build() {",
        "\t\tlet mut bit = BIT::<Alg::Add>::from(&vec![1, 2, 3, 4, 5]);",
        "\t\tassert_eq!(bit.prefix_sum(4), 10);",
        "\t\tassert_eq!(bit.prefix_sum(5), 15);",
        "\t\tbit.add(2, -3);",
        "\t\tbit.add(3, -4);",
        "\t\tassert_eq!(bit.prefix_sum(5), 8);",
        "\t}",
        "\t#[test]",
        "\tfn test_sum() {",
        "\t\tlet bit = BIT::<Alg::Add>::from(&vec![1, 2, 3, 4, 5]);",
        "\t\tassert_eq!(bit.sum(0..5), 15);",
        "\t\tassert_eq!(bit.sum(1..5), 14);",
        "\t\tassert_eq!(bit.sum(2..3), 3);",
        "\t\tassert_eq!(bit.sum(3..2), 0);",
        "\t\tassert_eq!(bit.sum(0..=5), 15);",
        "\t\tassert_eq!(bit.sum(1..=3), 9);",
        "\t}",
        "\t#[test]",
        "\tfn test_lower_bound() {",
        "\t\tlet bit = BIT::<Alg::Add>::from(&vec![1, 2, 3, 4, 0, 5]);",
        "\t\tassert_eq!(bit.lower_bound(0), 0);",
        "\t\tassert_eq!(bit.lower_bound(1), 0);",
        "\t\tassert_eq!(bit.lower_bound(2), 1);",
        "\t\tassert_eq!(bit.lower_bound(10), 3);",
        "\t\tassert_eq!(bit.lower_bound(11), 5);",
        "\t\tassert_eq!(bit.lower_bound(100), 6);",
        "\t}",
        "\t#[test]",
        "\tfn test_upper_bound() {",
        "\t\tlet bit = BIT::<Alg::Add>::from(&vec![1, 2, 3, 4, 0, 5]);",
        "\t\tassert_eq!(bit.upper_bound(0), 0);",
        "\t\tassert_eq!(bit.upper_bound(1), 1);",
        "\t\tassert_eq!(bit.upper_bound(2), 1);",
        "\t\tassert_eq!(bit.upper_bound(10), 5);",
        "\t\tassert_eq!(bit.upper_bound(11), 5);",
        "\t\tassert_eq!(bit.upper_bound(100), 6);",
        "\t}",
        "\t#[test]",
        "\tfn test_debugprint() {",
        "\t\tlet bit1 = BIT::<Alg::Add>::from(&vec![1, 2, 3, 4, 5]);",
        "\t\tprintln!(\\\"{:?}\\\", bit1);",
        "\t}",
        "}"
      ],
      "description": "BinaryIndexedTree / FenwickTree"
    },
    {
      "prefix": "matrix_exp.rs",
      "body": [
        "// 定数",
        "const MOD: usize = 998244353;",
        "/* 行列累乗 */",
        "pub const DIM: usize = 4;",
        "pub type Vec = [usize; DIM];",
        "pub type Matrix = [[usize; DIM]; DIM];",
        "pub trait MatrixExp {",
        "\t/// ## e",
        "\t/// 単位行列を返す",
        "\tfn e() -> Self;",
        "\t/// ## apply",
        "\t/// ベクトル`x`と行列`A`について、`Ax`を返す",
        "\tfn dot(&self, other: Self) -> Self;",
        "\t/// ## pow",
        "\t/// 行列の累乗を返す（繰り返し2乗法）",
        "\tfn pow(&self, e: usize) -> Self;",
        "\t/// ## dot",
        "\t/// 行列のドット積",
        "\tfn apply(&self, vec: Vec) -> Vec;",
        "}",
        "impl MatrixExp for Matrix {",
        "\tfn e() -> Self {",
        "\t\tlet mut res = [[0; DIM]; DIM];",
        "\t\tfor i in 0..DIM {",
        "\t\t\tres[i][i] = 1;",
        "\t\t}",
        "\t\tres",
        "\t}",
        "\tfn apply(&self, vec: Vec) -> Vec {",
        "\t\tlet mut res = [0; DIM];",
        "\t\tfor i in 0..DIM {",
        "\t\t\tfor j in 0..DIM {",
        "\t\t\t\tres[i] += self[i][j] * vec[j] % MOD;",
        "\t\t\t\tres[i] %= MOD;",
        "\t\t\t}",
        "\t\t}",
        "\t\tres",
        "\t}",
        "\tfn pow(&self, mut e: usize) -> Self {",
        "\t\tlet mut res = Self::e();",
        "\t\tlet mut tmp = *self;",
        "\t\twhile e > 0 {",
        "\t\t\tif e & 1 == 1 {",
        "\t\t\t\tres = tmp.dot(res);",
        "\t\t\t}",
        "\t\t\ttmp = tmp.dot(tmp);",
        "\t\t\te >>= 1;",
        "\t\t}",
        "\t\tres",
        "\t}",
        "\tfn dot(&self, other: Self) -> Self {",
        "\t\tlet mut res = [[0; DIM]; DIM];",
        "\t\tfor i in 0..DIM {",
        "\t\t\tfor j in 0..DIM {",
        "\t\t\t\tfor k in 0..DIM {",
        "\t\t\t\t\tres[i][j] += self[i][k] * other[k][j] % MOD;",
        "\t\t\t\t\tres[i][j] %= MOD;",
        "\t\t\t\t}",
        "\t\t\t}",
        "\t\t}",
        "\t\tres",
        "\t}",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::*;",
        "\tuse rand::{prelude::*, rngs::ThreadRng};",
        "\tconst REPEAT_TIME: usize = 100;",
        "\t/// ランダムな値で埋められたDIMxDIM行列を生成する",
        "\tfn gen_random_matrix(rng: &mut ThreadRng) -> [[usize; DIM]; DIM] {",
        "\t\tlet mut res = [[0; DIM]; DIM];",
        "\t\tfor i in 0..DIM {",
        "\t\t\tfor j in 0..DIM {",
        "\t\t\t\tres[i][j] = rng.gen::<usize>() % MOD;",
        "\t\t\t}",
        "\t\t}",
        "\t\tres",
        "\t}",
        "\t/// ランダムな1bitの値で埋められたDIM次元行列を生成する",
        "\tfn gen_random_vector(rng: &mut ThreadRng) -> [usize; DIM] {",
        "\t\tlet mut res = [0; DIM];",
        "\t\tfor i in 0..DIM {",
        "\t\t\tres[i] = rng.gen::<bool>() as usize;",
        "\t\t}",
        "\t\tres",
        "\t}",
        "\t/// ## test_dot",
        "\t/// 行列積の正当性の検証",
        "\t/// - [乱択アルゴリズム紹介(行列乗算の検査&多項式等価性の検査)](https://tech.preferred.jp/ja/blog/matrix-multiplication-and-polynomial-identity/)",
        "\t#[test]",
        "\tfn test_dot() {",
        "\t\tlet mut rng = rand::thread_rng();",
        "\t\t// ランダムな行列を生成",
        "\t\tlet A = gen_random_matrix(&mut rng);",
        "\t\tlet B = gen_random_matrix(&mut rng);",
        "\t\tfor _ in 0..REPEAT_TIME {",
        "\t\t\t// ランダムなベクトルを生成",
        "\t\t\tlet v = gen_random_vector(&mut rng);",
        "\t\t\t// left = (A @ B) @ v",
        "\t\t\tlet left = A.dot(B).apply(v);",
        "\t\t\t// right = A @ (B @ v)",
        "\t\t\tlet right = A.apply(B.apply(v));",
        "\t\t\tassert_eq!(left, right);",
        "\t\t}",
        "\t}",
        "\t/// ## test_pow",
        "\t/// 行列累乗の正当性の検証",
        "\t#[test]",
        "\tfn test_pow() {",
        "\t\t// テトラナッチ数",
        "\t\tlet tetra = [[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [1, 1, 1, 1]];",
        "\t\t// 初期値",
        "\t\tlet init = [0, 0, 0, 1];",
        "\t\t// T_{35}を求める",
        "\t\tlet T_35 = tetra.pow(35).apply(init)[0];",
        "\t\tassert_eq!(T_35, 747044834);",
        "\t}",
        "}"
      ],
      "description": "行列累乗"
    },
    {
      "prefix": "acc2d.rs",
      "body": [
        "use num_traits::Num;",
        "/// ## acc2D",
        "/// - 2次元累積和を取る",
        "/// ### 戻り値",
        "/// - `|r_start, r_end, c_start, c_end|: (usize, usize, usize, usize) -> T`",
        "pub fn acc2D<T: Num + Copy>(array: &Vec<Vec<T>>) -> impl Fn(usize, usize, usize, usize) -> T {",
        "\tlet (H, W) = (array.len(), array[0].len());",
        "\tlet mut S = vec![vec![T::zero(); W + 1]; H + 1];",
        "\tfor i in 0..H {",
        "\t\tfor j in 0..W {",
        "\t\t\tS[i + 1][j + 1] = S[i][j + 1] + S[i + 1][j] - S[i][j] + array[i][j];",
        "\t\t}",
        "\t}",
        "\tmove |r_start: usize, r_end: usize, c_start: usize, c_end: usize| -> T {",
        "\t\tS[r_end][c_end]",
        "\t\t\t- S[r_end][c_start]",
        "\t\t\t- S[r_start][c_end]",
        "\t\t\t+ S[r_start][c_start]",
        "\t}",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::acc2D;",
        "\t#[test]",
        "\tfn test_acc2_isize() {",
        "\t\tlet arr: Vec<Vec<isize>> = vec![",
        "\t\t\tvec![1, -2, 3],",
        "\t\t\tvec![4, -5, 6],",
        "\t\t\tvec![7, -8, 9],",
        "\t\t];",
        "\t\tlet acc = acc2D(&arr);",
        "\t\tassert_eq!(acc(0, 1, 0, 1), 1);",
        "\t\tassert_eq!(acc(0, 2, 0, 2), -2);",
        "\t\tassert_eq!(acc(0, 3, 1, 2), -15);",
        "\t\tassert_eq!(acc(1, 2, 0, 3), 5);",
        "\t\tassert_eq!(acc(0, 3, 0, 3), 15);",
        "\t}",
        "\t#[test]",
        "\tfn test_acc2D_usize() {",
        "\t\tlet arr: Vec<Vec<usize>> = vec![",
        "\t\t\tvec![1, 2, 3],",
        "\t\t\tvec![4, 5, 6],",
        "\t\t\tvec![7, 8, 9],",
        "\t\t];",
        "\t\tlet acc = acc2D(&arr);",
        "\t\tassert_eq!(acc(0, 1, 0, 1), 1);",
        "\t\tassert_eq!(acc(0, 2, 0, 2), 12);",
        "\t\tassert_eq!(acc(0, 3, 1, 2), 15);",
        "\t\tassert_eq!(acc(1, 2, 0, 3), 15);",
        "\t\tassert_eq!(acc(0, 3, 0, 3), 45);",
        "\t}",
        "}"
      ],
      "description": "2次元累積和"
    },
    {
      "prefix": "chmax_chmin.rs",
      "body": [
        "/// `chmax!{x1, x2, ..., xn}`:`x1`,`x2`,...,`xn`のうち最大のものを、`x1`に代入する",
        "/// - 代入があったとき、`true`を返す",
        "#[macro_export]",
        "macro_rules! chmax {",
        "\t( \\$a:expr, \\$b:expr \\$(,)* ) => {{",
        "\t\tif \\$a < \\$b {",
        "\t\t\t\\$a = \\$b;",
        "\t\t\ttrue",
        "\t\t} else {",
        "\t\t\tfalse",
        "\t\t}",
        "\t}};",
        "\t( \\$a:expr, \\$b:expr, \\$c:expr \\$(,\\$other:expr)* \\$(,)* ) => {{",
        "\t\tchmax! {",
        "\t\t\t\\$a,",
        "\t\t\t(\\$b).max(\\$c)",
        "\t\t\t\\$(,\\$other)*",
        "\t\t}",
        "\t}}",
        "}",
        "/// `chmin!{x1, x2, ..., xn}`:`x1`,`x2`,...,`xn`のうち最小のものを、`x1`に代入する",
        "/// - 代入があったとき、`true`を返す",
        "#[macro_export]",
        "macro_rules! chmin {",
        "\t( \\$a:expr, \\$b:expr \\$(,)* ) => {{",
        "\t\tif \\$a > \\$b {",
        "\t\t\t\\$a = \\$b;",
        "\t\t\ttrue",
        "\t\t} else {",
        "\t\t\tfalse",
        "\t\t}",
        "\t}};",
        "\t( \\$a:expr, \\$b:expr, \\$c:expr \\$(,\\$other:expr)* \\$(,)* ) => {{",
        "\t\tchmin! {",
        "\t\t\t\\$a,",
        "\t\t\t(\\$b).min(\\$c)",
        "\t\t\t\\$(,\\$other)*",
        "\t\t}",
        "\t}};",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\t#[test]",
        "\tfn test_chmax() {",
        "\t\t// 2変数",
        "\t\tlet mut a = 20;",
        "\t\tlet b = 10;",
        "\t\tchmax!(a, b);",
        "\t\tassert_eq!(a, 20);",
        "\t\t// 5変数",
        "\t\tlet mut one = 100;",
        "\t\tlet two = 30;",
        "\t\tlet three = 400;",
        "\t\tlet four = 10;",
        "\t\tlet five = 5;",
        "\t\tlet has_changed = chmax!(one, two, three, four, five,);",
        "\t\tassert_eq!(has_changed, true);",
        "\t\tassert_eq!(one, 400);",
        "\t}",
        "\t#[test]",
        "\tfn test_chmax_vector() {",
        "\t\tlet mut arr = (0..10).collect::<Vec<usize>>();",
        "\t\tprintln!(\\\"{:?}\\\", &arr);",
        "\t\tfor i in 0..10 {",
        "\t\t\tchmax!(arr[0], arr[i]);",
        "\t\t}",
        "\t\tprintln!(\\\"{:?}\\\", &arr);",
        "\t\tassert_eq!(&arr, &vec![9_usize, 1, 2, 3, 4, 5, 6, 7, 8, 9]);",
        "\t}",
        "\t#[test]",
        "\tfn test_chmin() {",
        "\t\t// 2変数",
        "\t\tlet mut a = 20;",
        "\t\tlet b = 10;",
        "\t\tchmin!(a, b);",
        "\t\tassert_eq!(a, 10);",
        "\t\t// 5変数",
        "\t\tlet mut one = 100;",
        "\t\tlet two = 30;",
        "\t\tlet three = 40;",
        "\t\tlet four = 10;",
        "\t\tlet five = 5;",
        "\t\tlet has_changed = chmin!(one, two, three, four, five,);",
        "\t\tassert_eq!(has_changed, true);",
        "\t\tassert_eq!(one, 5);",
        "\t}",
        "}"
      ],
      "description": "chmax/chminの実装"
    },
    {
      "prefix": "namori.rs",
      "body": [
        "use std::collections::VecDeque;",
        "pub type Graph = Vec<Vec<usize>>;",
        "/// # なもりグラフ",
        "/// - なもりグラフ（木に辺を1本加えたグラフ）を分解する",
        "#[derive(Debug)]",
        "pub struct Namori {",
        "\tpub N: usize,",
        "\tpub graph: Graph,",
        "\tpub forest: Graph,",
        "\tpub on_cycle: Vec<bool>,",
        "}",
        "impl Namori {",
        "\t/// 頂点数`N`のグラフを作成する",
        "\tpub fn new(N: usize) -> Self {",
        "\t\tSelf {",
        "\t\t\tN,",
        "\t\t\tgraph: vec![vec![]; N],",
        "\t\t\tforest: vec![vec![]; N],",
        "\t\t\ton_cycle: vec![true; N],",
        "\t\t}",
        "\t}",
        "\t/// 頂点`u`,`v`に辺を張る",
        "\tpub fn add_edge(&mut self, u: usize, v: usize) {",
        "\t\tself.graph[u].push(v);",
        "\t\tself.graph[v].push(u);",
        "\t}",
        "\t/// なもりグラフを分解し、",
        "\t/// - サイクルを取り除いた森",
        "\t/// - サイクル上の頂点",
        "\t/// ",
        "\t/// を求める",
        "\tpub fn decompose(&mut self) {",
        "\t\t// 葉を調べる",
        "\t\tlet mut degree = vec![0; self.N];",
        "\t\tlet mut leafs = VecDeque::new();",
        "\t\tlet mut visited = vec![false; self.N];",
        "\t\tfor i in 0..self.N {",
        "\t\t\tdegree[i] = self.graph[i].len(); // 次数を調べる",
        "\t\t\t// 次数が1の頂点を格納",
        "\t\t\tif degree[i] == 1 {",
        "\t\t\t\tleafs.push_back(i);",
        "\t\t\t\tvisited[i] = true;",
        "\t\t\t}",
        "\t\t}",
        "\t\t// 葉を辿って木に分解",
        "\t\twhile let Some(u) = leafs.pop_front() {",
        "\t\t\tself.on_cycle[u] = false;",
        "\t\t\tfor &v in &self.graph[u] {",
        "\t\t\t\tif visited[v] {",
        "\t\t\t\t\tcontinue;",
        "\t\t\t\t}",
        "\t\t\t\tdegree[v] -= 1;",
        "\t\t\t\t// 森に追加",
        "\t\t\t\tself.forest[u].push(v);",
        "\t\t\t\tself.forest[v].push(u);",
        "\t\t\t\tif degree[v] <= 1 {",
        "\t\t\t\t\tleafs.push_back(v);",
        "\t\t\t\t\tvisited[v] = true;",
        "\t\t\t\t}",
        "\t\t\t}",
        "\t\t}",
        "\t}",
        "}"
      ],
      "description": "なもりグラフの分解"
    },
    {
      "prefix": "scc.rs",
      "body": [
        "type Graph = Vec<Vec<usize>>;",
        "/// ## SCC (強連結成分分解)",
        "/// - Strongly Conneected Components",
        "pub struct SCC {",
        "\tpub V: usize,",
        "\tpub E: usize,",
        "\tpub G: Graph,",
        "\trG: Graph,",
        "\tpub group_count: Option<usize>,",
        "\tpub components: Vec<usize>,",
        "\tpub DAG: Graph,",
        "}",
        "impl SCC {",
        "\tconst INF: usize = std::usize::MAX;",
        "\t/// 頂点`V`のグラフを構築する",
        "\tpub fn new(V: usize) -> Self {",
        "\t\tSelf {",
        "\t\t\tV,",
        "\t\t\tE: 0,",
        "\t\t\tG: vec![vec![]; V],",
        "\t\t\trG: vec![vec![]; V],",
        "\t\t\tgroup_count: None,",
        "\t\t\tcomponents: vec![],",
        "\t\t\tDAG: vec![],",
        "\t\t}",
        "\t}",
        "\t/// uからvへの有向辺を追加",
        "\tpub fn add_edge(&mut self, u: usize, v: usize) {",
        "\t\tself.E += 1;",
        "\t\tself.G[u].push(v);",
        "\t\tself.rG[v].push(u);",
        "\t}",
        "\t/// 強連結成分に分解する",
        "\tpub fn decompose(&mut self) {",
        "\t\t// 帰りがけ順で順序付け",
        "\t\tlet mut order = vec![];",
        "\t\tlet mut visited = vec![false; self.V];",
        "\t\tfor i in 0..self.V {",
        "\t\t\tSelf::dfs(i, &self.G, &mut order, &mut visited);",
        "\t\t}",
        "\t\t// 連結成分に分解",
        "\t\tlet mut group = 0;",
        "\t\tlet mut components = vec![Self::INF; self.V];",
        "\t\tfor &i in order.iter().rev() {",
        "\t\t\tif components[i] == Self::INF {",
        "\t\t\t\tSelf::rdfs(i, group, &self.rG, &mut components);",
        "\t\t\t\tgroup += 1;",
        "\t\t\t}",
        "\t\t}",
        "\t\t// DAGを構築",
        "\t\tlet mut DAG = vec![vec![]; group];",
        "\t\tfor i in 0..self.V {",
        "\t\t\tfor &j in &self.G[i] {",
        "\t\t\t\tlet (u, v) = (components[i], components[j]);",
        "\t\t\t\tif u != v {",
        "\t\t\t\t\tDAG[u].push(v);",
        "\t\t\t\t}",
        "\t\t\t}",
        "\t\t}",
        "\t\tself.group_count = Some(group);",
        "\t\tself.components = components;",
        "\t\tself.DAG = DAG;",
        "\t}",
        "\tfn dfs(u: usize, G: &Graph, order: &mut Vec<usize>, visited: &mut Vec<bool>) {",
        "\t\tif visited[u] {",
        "\t\t\treturn;",
        "\t\t}",
        "\t\tvisited[u] = true;",
        "\t\tfor &v in &G[u] {",
        "\t\t\tSelf::dfs(v, G, order, visited);",
        "\t\t}",
        "\t\torder.push(u);",
        "\t}",
        "\tfn rdfs(u: usize, group: usize, rG: &Graph, components: &mut Vec<usize>) {",
        "\t\tif components[u] != Self::INF {",
        "\t\t\treturn;",
        "\t\t}",
        "\t\tcomponents[u] = group;",
        "\t\tfor &v in &rG[u] {",
        "\t\t\tSelf::rdfs(v, group, rG, components);",
        "\t\t}",
        "\t}",
        "}",
        "#[cfg(test)]",
        "mod test {",
        "\tuse super::*;",
        "\t#[test]",
        "\tfn test_scc() {",
        "\t\tlet V = 6;",
        "\t\tlet edges = [(1, 4), (5, 2), (3, 0), (5, 5), (4, 1), (0, 3), (4, 2)];",
        "\t\tlet mut scc = SCC::new(V);",
        "\t\tedges.iter().for_each(|&(u, v)| scc.add_edge(u, v));",
        "\t\t// 強連結成分分解",
        "\t\tscc.decompose();",
        "\t\tassert_eq!(scc.group_count, Some(4));",
        "\t\tassert_eq!(&scc.components, &vec![3, 1, 2, 3, 1, 0]);",
        "\t\tassert_eq!(&scc.DAG, &vec![vec![2], vec![2], vec![], vec![]]);",
        "\t}",
        "}"
      ],
      "description": "強連結成分分解"
    }
  ]
}