{
  "lineartime_merging.rs": {
    "prefix": "lineartime_merging",
    "body": [
      "mod lineartime_merging {",
      "\t#![allow(dead_code)]",
      "\t//! ソート済み配列の線形時間マージ",
      "\tuse std::iter::Peekable;",
      "\t/// ソート済み配列を O(N+M) でマージする",
      "\tpub fn merge<T, I, J>(A: I, B: J) -> MergeIterator<T, I, J>",
      "\twhere",
      "\t\tT: Ord,",
      "\t\tI: Iterator<Item = T>,",
      "\t\tJ: Iterator<Item = T>,",
      "\t{",
      "\t\tMergeIterator {",
      "\t\t\titr_a: A.peekable(),",
      "\t\t\titr_b: B.peekable(),",
      "\t\t}",
      "\t}",
      "\t/// マージ後の値を順に返すイテレータ",
      "\tpub struct MergeIterator<T, I, J>",
      "\twhere",
      "\t\tT: Ord,",
      "\t\tI: Iterator<Item = T>,",
      "\t\tJ: Iterator<Item = T>,",
      "\t{",
      "\t\titr_a: Peekable<I>,",
      "\t\titr_b: Peekable<J>,",
      "\t}",
      "\timpl<T, I, J> Iterator for MergeIterator<T, I, J>",
      "\twhere",
      "\t\tT: Ord,",
      "\t\tI: Iterator<Item = T>,",
      "\t\tJ: Iterator<Item = T>,",
      "\t{",
      "\t\ttype Item = T;",
      "\t\tfn next(&mut self) -> Option<Self::Item> {",
      "\t\t\tmatch (self.itr_a.peek(), self.itr_b.peek()) {",
      "\t\t\t\t(Some(a), Some(b)) => {",
      "\t\t\t\t\tif a <= b {",
      "\t\t\t\t\t\tself.itr_a.next()",
      "\t\t\t\t\t} else {",
      "\t\t\t\t\t\tself.itr_b.next()",
      "\t\t\t\t\t}",
      "\t\t\t\t}",
      "\t\t\t\t(Some(_), _) => self.itr_a.next(),",
      "\t\t\t\t_ => self.itr_b.next(),",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "ソート済み配列の線形時間マージ"
  },
  "multiset.rs": {
    "prefix": "multiset",
    "body": [
      "mod multiset {",
      "\t#![allow(dead_code)]",
      "\t//! 多重集合（Setによる実装）",
      "\tuse rustc_hash::FxHashMap;",
      "\tuse std::{collections::BTreeSet, hash::Hash};",
      "\t#[derive(Debug)]",
      "\tpub struct MultiSet<T> {",
      "\t\tpub counter: FxHashMap<T, usize>,",
      "\t\tpub items: BTreeSet<(T, usize)>,",
      "\t}",
      "\timpl<T> MultiSet<T>",
      "\twhere",
      "\t\tT: Ord + Hash + Copy,",
      "\t{",
      "\t\t/// MultiSetを初期化する",
      "\t\tpub fn new() -> Self {",
      "\t\t\tMultiSet {",
      "\t\t\t\tcounter: FxHashMap::default(),",
      "\t\t\t\titems: BTreeSet::new(),",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 要素`x`を追加する",
      "\t\tpub fn insert(&mut self, x: T) {",
      "\t\t\t// カウンターに追加",
      "\t\t\tlet cnt = self.counter.entry(x).or_insert(0);",
      "\t\t\t// setに追加",
      "\t\t\tself.items.insert((x, *cnt));",
      "\t\t\t// カウント",
      "\t\t\t*cnt += 1;",
      "\t\t}",
      "\t\t/// 要素`x`を削除する",
      "\t\tpub fn remove(&mut self, x: &T) -> bool {",
      "\t\t\tif let Some(v) = self.counter.get_mut(x) {",
      "\t\t\t\t// カウンターをデクリメント",
      "\t\t\t\t*v -= 1;",
      "\t\t\t\t// setから削除",
      "\t\t\t\tself.items.remove(&(*x, *v));",
      "\t\t\t\treturn true;",
      "\t\t\t}",
      "\t\t\tfalse",
      "\t\t}",
      "\t\t/// 要素`x`が存在するか判定する",
      "\t\tpub fn contains(&self, x: &T) -> bool {",
      "\t\t\tself.counter.get(x).is_some_and(|cnt| *cnt > 0)",
      "\t\t}",
      "\t\t/// 先頭の要素を取得する",
      "\t\tpub fn first(&self) -> Option<&T> {",
      "\t\t\tself.items.first().map(|(ref x, _)| x)",
      "\t\t}",
      "\t\t/// 末尾の要素を取得する",
      "\t\tpub fn last(&self) -> Option<&T> {",
      "\t\t\tself.items.last().map(|(ref x, _)| x)",
      "\t\t}",
      "\t\t/// `x`の個数をカウントする",
      "\t\tpub fn count(&self, x: &T) -> usize {",
      "\t\t\tmatch self.counter.get(x) {",
      "\t\t\t\tSome(&v) => v,",
      "\t\t\t\tNone => 0,",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 要素をすべて削除する",
      "\t\tpub fn clear(&mut self) {",
      "\t\t\tself.counter.clear();",
      "\t\t\tself.items.clear();",
      "\t\t}",
      "\t\tpub fn len(&self) -> usize {",
      "\t\t\tself.items.len()",
      "\t\t}",
      "\t\tpub fn is_empty(&self) -> bool {",
      "\t\t\tself.len() == 0",
      "\t\t}",
      "\t}",
      "\timpl<T> MultiSet<T> {",
      "\t\tpub fn iter(&self) -> impl Iterator<Item = &T> {",
      "\t\t\tself.items.iter().map(|(ref x, _)| x)",
      "\t\t}",
      "\t}",
      "\timpl<T: Ord + Hash + Copy> FromIterator<T> for MultiSet<T> {",
      "\t\tfn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {",
      "\t\t\tlet mut multiset = MultiSet::new();",
      "\t\t\tfor x in iter {",
      "\t\t\t\tmultiset.insert(x);",
      "\t\t\t}",
      "\t\t\tmultiset",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "多重集合（Setによる実装）"
  },
  "affine_transform.rs": {
    "prefix": "affine_transform",
    "body": [
      "mod affine_transform {",
      "\t#![allow(dead_code)]",
      "\t//! アフィン変換",
      "\t/// # AffineMatrix",
      "\t/// アフィン変換（3x3行列）",
      "\t#[derive(Debug, Clone, Copy)]",
      "\tpub struct AffineMatrix {",
      "\t\tarr: [[isize; 3]; 3],",
      "\t}",
      "\timpl AffineMatrix {",
      "\t\tpub fn e() -> Self {",
      "\t\t\tSelf {",
      "\t\t\t\tarr: [[1, 0, 0], [0, 1, 0], [0, 0, 1]],",
      "\t\t\t}",
      "\t\t}",
      "\t\tpub fn rotate90() -> Self {",
      "\t\t\tSelf {",
      "\t\t\t\tarr: [[0, -1, 0], [1, 0, 0], [0, 0, 1]],",
      "\t\t\t}",
      "\t\t}",
      "\t\tpub fn rotate270() -> Self {",
      "\t\t\tSelf {",
      "\t\t\t\tarr: [[0, 1, 0], [-1, 0, 0], [0, 0, 1]],",
      "\t\t\t}",
      "\t\t}",
      "\t\tpub fn mirror_x(p: isize) -> Self {",
      "\t\t\tSelf {",
      "\t\t\t\tarr: [[-1, 0, 2 * p], [0, 1, 0], [0, 0, 1]],",
      "\t\t\t}",
      "\t\t}",
      "\t\tpub fn mirror_y(p: isize) -> Self {",
      "\t\t\tSelf {",
      "\t\t\t\tarr: [[1, 0, 0], [0, -1, 2 * p], [0, 0, 1]],",
      "\t\t\t}",
      "\t\t}",
      "\t\tpub fn dot(&self, other: &Self) -> Self {",
      "\t\t\tlet mut arr = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];",
      "\t\t\tfor i in 0..3 {",
      "\t\t\t\tfor j in 0..3 {",
      "\t\t\t\t\tfor k in 0..3 {",
      "\t\t\t\t\t\tarr[i][j] += self.arr[i][k] * other.arr[k][j];",
      "\t\t\t\t\t}",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\tSelf { arr }",
      "\t\t}",
      "\t\tpub fn apply(&self, vec: (isize, isize)) -> (isize, isize) {",
      "\t\t\t(",
      "\t\t\t\tself.arr[0][0] * vec.0 + self.arr[0][1] * vec.1 + self.arr[0][2],",
      "\t\t\t\tself.arr[1][0] * vec.0 + self.arr[1][1] * vec.1 + self.arr[1][2],",
      "\t\t\t)",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "アフィン変換"
  },
  "modint_comb.rs": {
    "prefix": "modint_comb",
    "body": [
      "mod modint {",
      "\t#![allow(dead_code)]",
      "\t//! Modintの構造体",
      "\tpub use modint::*;",
      "\tpub type M998 = Modint<998244353>;",
      "\tpub type M107 = Modint<1000000007>;",
      "\t// 適当な素数",
      "\tpub type P1 = Modint<938472061>;",
      "\tpub type P2 = Modint<958472071>;",
      "\t#[rustfmt::skip]",
      "\tpub mod modint {",
      "\t\tfn sqrt(n: usize) -> usize { (n as f64).sqrt() as usize }",
      "\t\tuse std::{fmt::{Debug, Display}, iter::{Sum, Product}, mem::replace, num::ParseIntError, ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign}, str::FromStr};",
      "\t\t#[derive(Clone, Copy, Default, PartialEq, Eq, Hash)] pub struct Modint<const MOD: usize>(pub usize);",
      "\t\timpl<const MOD: usize> Modint<MOD> { pub fn new(n: usize) -> Self { Self(if n < MOD { n } else { n % MOD }) }",
      "\t\tpub fn from_str(s: &str) -> Self { s.chars().fold(0.into(), |n, c| n * 10 + c.to_digit(10).unwrap() as usize) }",
      "\t\tpub fn from_isize(n: isize) -> Self { Self::new((MOD as isize + n % MOD as isize) as usize) }",
      "\t\tpub fn rational_reconstruction(&self) -> Option<(usize, usize)> { let N = sqrt(MOD / 2); let mut v = (MOD, 0); let mut w = (self.0, 1);",
      "\t\twhile w.0 > N { let q = v.0.div_euclid(w.0); let z = (v.0 - q * w.0, v.1 + q * w.1); v = replace(&mut w, z); } (w.0 <= N && w.1 <= N).then_some(w) } }",
      "\t\timpl<const MOD: usize> Neg for Modint<MOD> { type Output = Self; fn neg(self) -> Self { Modint(if self.0 == 0 { 0 } else { MOD - self.0 }) } }",
      "\t\timpl<const MOD: usize> Add for Modint<MOD> { type Output = Self; fn add(self, rhs: Self) -> Self { let mut res = self.0 + rhs.0; if res >= MOD { res -= MOD; } Modint(res) } }",
      "\t\timpl<const MOD: usize> Sub for Modint<MOD> { type Output = Self; fn sub(self, rhs: Self) -> Self { self + (- rhs) } }",
      "\t\timpl<const MOD: usize> Mul for Modint<MOD> { type Output = Self; fn mul(self, rhs: Self) -> Self { Modint(self.0 * rhs.0 % MOD) } }",
      "\t\timpl<const MOD: usize> Div for Modint<MOD> { type Output = Self; fn div(self, rhs: Self) -> Self { self * rhs.inv() } }",
      "\t\timpl<const MOD: usize> AddAssign for Modint<MOD> { fn add_assign(&mut self, rhs: Self) { self.0 = (*self + rhs).0 } }",
      "\t\timpl<const MOD: usize> SubAssign for Modint<MOD> { fn sub_assign(&mut self, rhs: Self) { self.0 = (*self - rhs).0 } }",
      "\t\timpl<const MOD: usize> MulAssign for Modint<MOD> { fn mul_assign(&mut self, rhs: Self) { self.0 = (*self * rhs).0 } }",
      "\t\timpl<const MOD: usize> DivAssign for Modint<MOD> { fn div_assign(&mut self, rhs: Self) { self.0 = (*self / rhs).0 } }",
      "\t\timpl<const MOD: usize> From<usize> for Modint<MOD> { fn from(value: usize) -> Self { Modint::new(value) } }",
      "\t\timpl<const MOD: usize> Add<usize> for Modint<MOD> { type Output = Self; fn add(self, rhs: usize) -> Self { let mut res = self.0 + rhs; if res >= MOD {res -= MOD;} Modint(res) } }",
      "\t\timpl<const MOD: usize> Sub<usize> for Modint<MOD> { type Output = Self; fn sub(self, rhs: usize) -> Self { self - Modint::new(rhs) } }",
      "\t\timpl<const MOD: usize> Mul<usize> for Modint<MOD> { type Output = Self; fn mul(self, rhs: usize) -> Self { self * Modint::new(rhs) } }",
      "\t\timpl<const MOD: usize> Div<usize> for Modint<MOD> { type Output = Self; fn div(self, rhs: usize) -> Self { self / Modint::new(rhs) } }",
      "\t\timpl<const MOD: usize> AddAssign<usize> for Modint<MOD> { fn add_assign(&mut self, rhs: usize) { *self += Modint::new(rhs) } }",
      "\t\timpl<const MOD: usize> SubAssign<usize> for Modint<MOD> { fn sub_assign(&mut self, rhs: usize) { *self -= Modint::new(rhs) } }",
      "\t\timpl<const MOD: usize> MulAssign<usize> for Modint<MOD> { fn mul_assign(&mut self, rhs: usize) { *self *= Modint::new(rhs) } }",
      "\t\timpl<const MOD: usize> DivAssign<usize> for Modint<MOD> { fn div_assign(&mut self, rhs: usize) { *self /= Modint::new(rhs) } }",
      "\t\timpl<const MOD: usize> Display for Modint<MOD> { fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, \"{}\", self.0) } }",
      "\t\timpl<const MOD: usize> PartialEq<usize> for Modint<MOD> { fn eq(&self, other: &usize) -> bool { self == &Modint::new(*other) } }",
      "\t\timpl<const MOD: usize> FromStr for Modint<MOD> { type Err = ParseIntError; fn from_str(s: &str) -> Result<Self, Self::Err> { Ok(Self::from_str(s)) } }",
      "\t\timpl<const MOD: usize> Debug for Modint<MOD> { fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { match self.rational_reconstruction() { Some((n, d)) => if d > 1 { write!(f, \"Modint({n}/{d})\") } else { write!(f, \"Modint({n})\") } _ => write!(f, \"Modint({})\", self.0) } } }",
      "\t\tpub trait Fp { fn pow(&self, rhs: usize) -> Self; fn inv(&self) -> Self; }",
      "\t\timpl<const MOD: usize> Fp for Modint<MOD> { fn pow(&self, rhs: usize) -> Self { let (mut a, mut b) = (self.0, rhs); let mut res = 1; while b > 0 { if b & 1 == 1 { res = (res * a) % MOD; } a = (a * a) % MOD; b >>= 1u32; } Modint(res) } fn inv(&self) -> Self { self.pow(MOD - 2) } }",
      "\t\timpl<const MOD: usize> Sum<Modint<MOD>> for Modint<MOD> { fn sum<I: Iterator<Item = Modint<MOD>>>(iter: I) -> Self { iter.fold(Modint::<MOD>(0), |acc, x| acc + x) } }",
      "\t\timpl<const MOD: usize> Product<Modint<MOD>> for Modint<MOD> { fn product<I: Iterator<Item = Modint<MOD>>>(iter: I) -> Self { iter.fold(Modint::<MOD>(1), |acc, x| acc * x) } }",
      "\t}",
      "}",
      "",
      "mod modint_comb {",
      "\t#![allow(dead_code)]",
      "\t//! 階乗を前計算する（Modint構造体に依存）",
      "\tuse crate::modint::modint::Modint;",
      "\t/// 二項係数を高速に求める",
      "\t/// - 前計算: `O(N)`",
      "\t/// - クエリ: `O(1)`",
      "\tpub struct Comb<const MOD: usize> {",
      "\t\tfac: Vec<Modint<MOD>>,",
      "\t\tfinv: Vec<Modint<MOD>>,",
      "\t}",
      "\timpl<const MOD: usize> Comb<MOD> {",
      "\t\t/// サイズ`max_size`で配列を初期化する",
      "\t\tpub fn new(max_size: usize) -> Self {",
      "\t\t\tlet mod1: Modint<MOD> = 1.into();",
      "\t\t\tlet mut fac = vec![mod1; max_size];",
      "\t\t\tlet mut finv = vec![mod1; max_size];",
      "\t\t\tlet mut inv = vec![mod1; max_size];",
      "\t\t\tfor i in 2..max_size {",
      "\t\t\t\tfac[i] = fac[i - 1] * i;",
      "\t\t\t\tinv[i] = -Modint::new(MOD / i) * inv[MOD % i];",
      "\t\t\t\tfinv[i] = finv[i - 1] * inv[i];",
      "\t\t\t}",
      "\t\t\tComb { fac, finv }",
      "\t\t}",
      "\t\t/// 順列を求める",
      "\t\tpub fn comb(&self, n: usize, r: usize) -> Modint<MOD> {",
      "\t\t\tif n < r {",
      "\t\t\t\treturn 0.into();",
      "\t\t\t}",
      "\t\t\tself.fac[n] * self.finv[r] * self.finv[n - r]",
      "\t\t}",
      "\t\t/// 組合せを求める",
      "\t\tpub fn perm(&self, n: usize, r: usize) -> Modint<MOD> {",
      "\t\t\tif n < r {",
      "\t\t\t\treturn 0.into();",
      "\t\t\t}",
      "\t\t\tself.fac[n] * self.finv[n - r]",
      "\t\t}",
      "\t\t/// 重複を許す組合せ(combination with repetition)",
      "\t\tpub fn comb_with_rep(&self, n: usize, r: usize) -> Modint<MOD> {",
      "\t\t\tself.comb(n + r - 1, r)",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "階乗を前計算する（Modint構造体に依存）"
  },
  "mex_set.rs": {
    "prefix": "mex_set",
    "body": [
      "mod mex_set {",
      "\t#![allow(dead_code)]",
      "\t//! Mexを管理するデータ構造",
      "\tuse std::{",
      "\t\tcollections::BTreeSet,",
      "\t\tops::{Bound::*, RangeBounds},",
      "\t};",
      "\t/// 集合とそのmexを管理する",
      "\t#[derive(Debug)]",
      "\tpub struct MexSet {",
      "\t\tpub ranges: BTreeSet<(isize, isize)>,",
      "\t}",
      "\timpl MexSet {",
      "\t\t/// MexSetを初期化する",
      "\t\tpub fn new() -> Self {",
      "\t\t\tlet ranges = [(isize::MIN, isize::MIN), (isize::MAX, isize::MAX)]",
      "\t\t\t\t.into_iter()",
      "\t\t\t\t.collect();",
      "\t\t\tSelf { ranges }",
      "\t\t}",
      "\t\t/// 集合に要素`x`を追加する",
      "\t\t/// ### 戻り値",
      "\t\t/// - `true`: `x`が追加された場合",
      "\t\t/// - `false`: `x`がすでに存在していた場合",
      "\t\tpub fn insert(&mut self, x: isize) -> bool {",
      "\t\t\tlet &(ll, l) = self.ranges.range(..(x + 1, x + 1)).next_back().unwrap();",
      "\t\t\tlet &(r, rr) = self.ranges.range((x + 1, x + 1)..).next().unwrap();",
      "\t\t\tif x <= l {",
      "\t\t\t\treturn false;",
      "\t\t\t}",
      "\t\t\tmatch (l == x - 1, x + 1 == r) {",
      "\t\t\t\t(false, false) => {",
      "\t\t\t\t\tself.ranges.insert((x, x));",
      "\t\t\t\t}",
      "\t\t\t\t(false, true) => {",
      "\t\t\t\t\tself.ranges.remove(&(r, rr));",
      "\t\t\t\t\tself.ranges.insert((x, rr));",
      "\t\t\t\t}",
      "\t\t\t\t(true, false) => {",
      "\t\t\t\t\tself.ranges.remove(&(ll, l));",
      "\t\t\t\t\tself.ranges.insert((ll, x));",
      "\t\t\t\t}",
      "\t\t\t\t(true, true) => {",
      "\t\t\t\t\tself.ranges.remove(&(ll, l));",
      "\t\t\t\t\tself.ranges.remove(&(r, rr));",
      "\t\t\t\t\tself.ranges.insert((ll, rr));",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\ttrue",
      "\t\t}",
      "\t\t/// 集合から要素`x`を削除する",
      "\t\t/// ### 戻り値",
      "\t\t/// - `true`: `x`が削除された場合",
      "\t\t/// - `false`: `x`がすでに存在していなかった場合",
      "\t\tpub fn delete(&mut self, x: isize) -> bool {",
      "\t\t\tlet &(ll, l) = self.ranges.range(..(x + 1, x + 1)).next_back().unwrap();",
      "\t\t\tif l < x {",
      "\t\t\t\treturn false;",
      "\t\t\t}",
      "\t\t\tself.ranges.remove(&(ll, l));",
      "\t\t\tmatch (ll == x, x == l) {",
      "\t\t\t\t(false, false) => {",
      "\t\t\t\t\tself.ranges.insert((ll, x - 1));",
      "\t\t\t\t\tself.ranges.insert((x + 1, l));",
      "\t\t\t\t}",
      "\t\t\t\t(false, true) => {",
      "\t\t\t\t\tself.ranges.insert((ll, x - 1));",
      "\t\t\t\t}",
      "\t\t\t\t(true, false) => {",
      "\t\t\t\t\tself.ranges.insert((x + 1, l));",
      "\t\t\t\t}",
      "\t\t\t\t(true, true) => (),",
      "\t\t\t}",
      "\t\t\ttrue",
      "\t\t}",
      "\t\t#[inline]",
      "\t\tfn parse_range<R: RangeBounds<isize>>(range: R) -> (isize, isize) {",
      "\t\t\tlet start = match range.start_bound() {",
      "\t\t\t\tUnbounded => isize::MIN,",
      "\t\t\t\tIncluded(&s) => s,",
      "\t\t\t\tExcluded(&s) => s + 1,",
      "\t\t\t};",
      "\t\t\tlet end = match range.end_bound() {",
      "\t\t\t\tUnbounded => isize::MAX,",
      "\t\t\t\tIncluded(&e) => e,",
      "\t\t\t\tExcluded(&e) => e - 1,",
      "\t\t\t};",
      "\t\t\t(start, end)",
      "\t\t}",
      "\t\t/// 集合に区間を追加する",
      "\t\t/// - 計算量: O(log(n)) (amotized)",
      "\t\tpub fn insert_range<R: RangeBounds<isize>>(&mut self, range: R) -> bool {",
      "\t\t\tlet (start, end) = Self::parse_range(range);",
      "\t\t\tif start > end {",
      "\t\t\t\treturn false;",
      "\t\t\t}",
      "\t\t\tif start == end {",
      "\t\t\t\treturn self.insert(start);",
      "\t\t\t}",
      "\t\t\twhile let Some(&(l, r)) = self",
      "\t\t\t\t.ranges",
      "\t\t\t\t.range((Excluded((start, start)), Excluded((end, end))))",
      "\t\t\t\t.next()",
      "\t\t\t{",
      "\t\t\t\tif r < end {",
      "\t\t\t\t\tself.ranges.remove(&(l, r));",
      "\t\t\t\t} else {",
      "\t\t\t\t\tbreak;",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\tlet &(ll, l) = self",
      "\t\t\t\t.ranges",
      "\t\t\t\t.range(..(start + 1, start + 1))",
      "\t\t\t\t.next_back()",
      "\t\t\t\t.unwrap();",
      "\t\t\tlet &(r, rr) = self.ranges.range((end, end)..).next().unwrap();",
      "\t\t\tif ll <= start && end <= l {",
      "\t\t\t\treturn false;",
      "\t\t\t}",
      "\t\t\tmatch (start <= l + 1, r - 1 <= end) {",
      "\t\t\t\t(false, false) => {",
      "\t\t\t\t\tself.ranges.insert((start, end));",
      "\t\t\t\t}",
      "\t\t\t\t(false, true) => {",
      "\t\t\t\t\tself.ranges.remove(&(r, rr));",
      "\t\t\t\t\tself.ranges.insert((start, rr));",
      "\t\t\t\t}",
      "\t\t\t\t(true, false) => {",
      "\t\t\t\t\tself.ranges.remove(&(ll, l));",
      "\t\t\t\t\tself.ranges.insert((ll, end));",
      "\t\t\t\t}",
      "\t\t\t\t(true, true) => {",
      "\t\t\t\t\tself.ranges.remove(&(ll, l));",
      "\t\t\t\t\tself.ranges.remove(&(r, rr));",
      "\t\t\t\t\tself.ranges.insert((ll, rr));",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\ttrue",
      "\t\t}",
      "\t\t/// 集合から区間を削除する",
      "\t\t/// - 計算量: O(log(n)) (amotized)",
      "\t\tpub fn delete_range<R: RangeBounds<isize>>(&mut self, range: R) -> bool {",
      "\t\t\tlet (start, end) = Self::parse_range(range);",
      "\t\t\tif start > end {",
      "\t\t\t\treturn false;",
      "\t\t\t}",
      "\t\t\tif start == end {",
      "\t\t\t\treturn self.delete(start);",
      "\t\t\t}",
      "\t\t\twhile let Some(&(l, r)) = self",
      "\t\t\t\t.ranges",
      "\t\t\t\t.range((Excluded((start, start)), Excluded((end, end))))",
      "\t\t\t\t.next()",
      "\t\t\t{",
      "\t\t\t\tif r < end {",
      "\t\t\t\t\tself.ranges.remove(&(l, r));",
      "\t\t\t\t} else {",
      "\t\t\t\t\tbreak;",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\tlet &(ll, l) = self",
      "\t\t\t\t.ranges",
      "\t\t\t\t.range((Unbounded, Included((start, start))))",
      "\t\t\t\t.next_back()",
      "\t\t\t\t.unwrap();",
      "\t\t\tlet &(r, rr) = self",
      "\t\t\t\t.ranges",
      "\t\t\t\t.range((Unbounded, Included((end, end))))",
      "\t\t\t\t.next_back()",
      "\t\t\t\t.unwrap();",
      "\t\t\tprintln!(\"{:?}\", ((ll, l), (r, rr)));",
      "\t\t\tif l < start && end < r {",
      "\t\t\t\treturn false;",
      "\t\t\t}",
      "\t\t\tif start <= l {",
      "\t\t\t\tself.ranges.remove(&(ll, l));",
      "\t\t\t\tmatch (ll < start, end < l) {",
      "\t\t\t\t\t(false, false) => {}",
      "\t\t\t\t\t(false, true) => {",
      "\t\t\t\t\t\tself.ranges.insert((end.saturating_add(1), l));",
      "\t\t\t\t\t}",
      "\t\t\t\t\t(true, false) => {",
      "\t\t\t\t\t\tself.ranges.insert((ll, start.saturating_sub(1)));",
      "\t\t\t\t\t}",
      "\t\t\t\t\t(true, true) => {",
      "\t\t\t\t\t\tself.ranges.insert((ll, start.saturating_sub(1)));",
      "\t\t\t\t\t\tself.ranges.insert((end.saturating_add(1), l));",
      "\t\t\t\t\t}",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\tif r <= end && end <= rr {",
      "\t\t\t\tself.ranges.remove(&(r, rr));",
      "\t\t\t\tself.ranges.insert((end.saturating_add(1), rr));",
      "\t\t\t}",
      "\t\t\ttodo!()",
      "\t\t}",
      "\t\t/// **集合に含まれない**`x`以上で最小の整数を調べる",
      "\t\tpub fn mex(&self, x: isize) -> isize {",
      "\t\t\tlet &(ll, l) = self.ranges.range(..(x + 1, x + 1)).next_back().unwrap();",
      "\t\t\tif ll <= x && x <= l {",
      "\t\t\t\tl + 1",
      "\t\t\t} else {",
      "\t\t\t\tx",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "Mexを管理するデータ構造"
  },
  "loop_detection.rs": {
    "prefix": "loop_detection",
    "body": [
      "mod loop_detection {",
      "\t#![allow(dead_code)]",
      "\t//! ループ検出",
      "\tuse num_bigint::BigUint;",
      "\tuse num_traits::{FromPrimitive, ToPrimitive, Zero};",
      "\tuse std::ops::{Add, Mul, Sub};",
      "\tuse std::{collections::HashMap, hash::Hash};",
      "\tpub struct Loop<T, V, F, G>",
      "\twhere",
      "\t\tF: Fn(T) -> T,",
      "\t\tG: Fn(T) -> V,",
      "\t{",
      "\t\t/// ノードの移動を行う関数",
      "\t\tpub next: F,",
      "\t\t/// ノードから値を取り出す関数",
      "\t\tpub get_val: G,",
      "\t\t/// 始点となるノード",
      "\t\tpub begin: T,",
      "\t\t/// ループの長さ",
      "\t\tpub loop_len: usize,",
      "\t\t/// ループ開始時の値",
      "\t\tpub loop_begin: T,",
      "\t\t/// ループに到達するまでの移動回数",
      "\t\tpub loop_begin_idx: usize,",
      "\t\t/// ループ開始時までの累積",
      "\t\tpub before_loop_sum: V,",
      "\t\t/// ループ内での累積",
      "\t\tpub loop_sum: V,",
      "\t\t/// ループの途中の値",
      "\t\tvals: HashMap<T, (usize, V)>,",
      "\t}",
      "\timpl<T, V, F, G> Loop<T, V, F, G>",
      "\twhere",
      "\t\tT: Copy + Hash + Eq,",
      "\t\tV: Copy + Zero + Add<Output = V> + Sub<Output = V> + Mul<usize, Output = V>,",
      "\t\tF: Fn(T) -> T,",
      "\t\tG: Fn(T) -> V,",
      "\t{",
      "\t\t/// ループを検出する",
      "\t\tpub fn build(begin: T, next: F, get_val: G) -> Self {",
      "\t\t\t// 初期化",
      "\t\t\tlet mut cur: T = begin;",
      "\t\t\tlet mut idx: usize = 0;",
      "\t\t\tlet mut sum: V = V::zero();",
      "\t\t\tlet mut vals: HashMap<T, (usize, V)> = HashMap::new();",
      "\t\t\t// ループ検出",
      "\t\t\twhile vals.get(&cur).is_none() {",
      "\t\t\t\tvals.insert(cur, (idx, sum));",
      "\t\t\t\tsum = sum + get_val(cur);",
      "\t\t\t\tcur = next(cur);",
      "\t\t\t\tidx += 1;",
      "\t\t\t}",
      "\t\t\t// ループの値を取り出す",
      "\t\t\tlet loop_begin = cur;",
      "\t\t\tlet (loop_begin_idx, before_loop_sum) = vals[&loop_begin];",
      "\t\t\tlet loop_len = idx - loop_begin_idx;",
      "\t\t\tlet loop_sum = sum - before_loop_sum;",
      "\t\t\t// 返す",
      "\t\t\tSelf {",
      "\t\t\t\tnext,",
      "\t\t\t\tget_val,",
      "\t\t\t\tbegin,",
      "\t\t\t\tloop_len,",
      "\t\t\t\tloop_begin,",
      "\t\t\t\tloop_begin_idx,",
      "\t\t\t\tbefore_loop_sum,",
      "\t\t\t\tloop_sum,",
      "\t\t\t\tvals,",
      "\t\t\t}",
      "\t\t}",
      "\t\tfn accumulate(&self, begin: T, n: usize) -> (T, V) {",
      "\t\t\tlet mut res = V::zero();",
      "\t\t\tlet mut cur = begin;",
      "\t\t\tfor _ in 0..n {",
      "\t\t\t\tres = res + (self.get_val)(cur);",
      "\t\t\t\tcur = (self.next)(cur);",
      "\t\t\t}",
      "\t\t\t(cur, res)",
      "\t\t}",
      "\t\t/// self.beginからn個後の頂点を取り出す",
      "\t\tpub fn get_nth_node_usize(&self, n: usize) -> T {",
      "\t\t\tif n < self.loop_begin_idx {",
      "\t\t\t\tself.accumulate(self.begin, n).0",
      "\t\t\t} else {",
      "\t\t\t\tlet loop_rem = (n - self.loop_begin_idx) % self.loop_len;",
      "\t\t\t\tself.accumulate(self.loop_begin, loop_rem).0",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// self.beginからn個後の値を取り出す",
      "\t\tpub fn get_nth_val_usize(&self, n: usize) -> V {",
      "\t\t\tif n < self.loop_begin_idx {",
      "\t\t\t\tself.accumulate(self.begin, n).1",
      "\t\t\t} else {",
      "\t\t\t\tlet loop_rep = (n - self.loop_begin_idx) / self.loop_len;",
      "\t\t\t\tlet loop_rem = (n - self.loop_begin_idx) % self.loop_len;",
      "\t\t\t\tself.before_loop_sum",
      "\t\t\t\t\t+ self.loop_sum * loop_rep",
      "\t\t\t\t\t+ self.accumulate(self.loop_begin, loop_rem).1",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// self.beginからn個後の値を取り出す",
      "\t\tpub fn get_nth_node_biguint(&self, n: BigUint) -> T {",
      "\t\t\tlet loop_begin_idx = BigUint::from_usize(self.loop_begin_idx).unwrap();",
      "\t\t\tif n < loop_begin_idx {",
      "\t\t\t\tlet n_usize = n.to_usize().unwrap();",
      "\t\t\t\tself.accumulate(self.begin, n_usize).0",
      "\t\t\t} else {",
      "\t\t\t\tlet loop_len = BigUint::from_usize(self.loop_len).unwrap();",
      "\t\t\t\tlet loop_rem = (n - loop_begin_idx) % loop_len;",
      "\t\t\t\tlet loop_rem = loop_rem.to_usize().unwrap();",
      "\t\t\t\tself.accumulate(self.loop_begin, loop_rem).0",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "ループ検出"
  },
  "dual_segment_tree.rs": {
    "prefix": "dual_segment_tree",
    "body": [
      "mod dual_segment_tree {",
      "\t#![allow(dead_code)]",
      "\t//! 双対セグメント木：区間加算・一点取得",
      "\tuse std::fmt::{self, Debug};",
      "\tuse std::ops::{",
      "\t\tBound::{Excluded, Included, Unbounded},",
      "\t\tRangeBounds,",
      "\t};",
      "\t/// 可換モノイド",
      "\tpub trait CommutativeMonoid {",
      "\t\t/// 元の型",
      "\t\ttype Val: fmt::Debug + Clone + PartialEq;",
      "\t\t/// 単位元",
      "\t\tconst E: Self::Val;",
      "\t\t/// 演算",
      "\t\tfn op(arg1: &Self::Val, arg2: &Self::Val) -> Self::Val;",
      "\t}",
      "\t/// 双対セグ木",
      "\t/// - 区間への作用",
      "\t/// - 一点の取得",
      "\t/// を行うセグメント木",
      "\tpub struct DualSegmentTree<M: CommutativeMonoid> {",
      "\t\tpub size: usize,",
      "\t\toffset: usize,",
      "\t\tdata: Vec<M::Val>,",
      "\t}",
      "\timpl<M: CommutativeMonoid> DualSegmentTree<M> {",
      "\t\t#[inline]",
      "\t\tfn parse_range<R: RangeBounds<usize>>(&self, range: &R) -> Option<(usize, usize)> {",
      "\t\t\tlet start = match range.start_bound() {",
      "\t\t\t\tUnbounded => 0,",
      "\t\t\t\tExcluded(&v) => v + 1,",
      "\t\t\t\tIncluded(&v) => v,",
      "\t\t\t};",
      "\t\t\tlet end = match range.end_bound() {",
      "\t\t\t\tUnbounded => self.size,",
      "\t\t\t\tExcluded(&v) => v,",
      "\t\t\t\tIncluded(&v) => v + 1,",
      "\t\t\t};",
      "\t\t\tif start <= end && end <= self.size {",
      "\t\t\t\tSome((start, end))",
      "\t\t\t} else {",
      "\t\t\t\tNone",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 双対セグメント木を初期化する",
      "\t\tpub fn new(n: usize) -> Self {",
      "\t\t\tlet offset = n;",
      "\t\t\tSelf {",
      "\t\t\t\tsize: n,",
      "\t\t\t\toffset,",
      "\t\t\t\tdata: vec![M::E; offset << 1],",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 配列から双対セグメント木を構築する",
      "\t\tpub fn build(arr: &Vec<M::Val>) -> Self {",
      "\t\t\tlet offset = arr.len();",
      "\t\t\tlet mut seg = Self::new(offset);",
      "\t\t\tseg.data[offset..].clone_from_slice(arr);",
      "\t\t\tseg",
      "\t\t}",
      "\t\t/// 区間更新:",
      "\t\t/// - 区間`range`を`x`で更新する",
      "\t\tpub fn apply_range<R: RangeBounds<usize> + Debug>(&mut self, range: R, x: M::Val) {",
      "\t\t\tlet Some((start, end)) = self.parse_range(&range) else {",
      "\t\t\t\tpanic!(\"The given range is wrong: {:?}\", range);",
      "\t\t\t};",
      "\t\t\t// 値の更新",
      "\t\t\tlet mut l = self.offset + start;",
      "\t\t\tlet mut r = self.offset + end;",
      "\t\t\twhile l < r {",
      "\t\t\t\tif l & 1 == 1 {",
      "\t\t\t\t\tlet tmp = M::op(&self.data[l], &x);",
      "\t\t\t\t\tself.data[l] = tmp;",
      "\t\t\t\t\tl += 1;",
      "\t\t\t\t}",
      "\t\t\t\tif r & 1 == 1 {",
      "\t\t\t\t\tr -= 1;",
      "\t\t\t\t\tlet tmp = M::op(&self.data[r], &x);",
      "\t\t\t\t\tself.data[r] = tmp;",
      "\t\t\t\t}",
      "\t\t\t\tl >>= 1;",
      "\t\t\t\tr >>= 1;",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 一点取得",
      "\t\tpub fn get_point(&self, index: usize) -> M::Val {",
      "\t\t\tlet mut i = index + self.offset;",
      "\t\t\tlet mut res = self.data[i].clone();",
      "\t\t\twhile i > 1 {",
      "\t\t\t\ti >>= 1;",
      "\t\t\t\tlet tmp = M::op(&self.data[i], &res);",
      "\t\t\t\tres = tmp;",
      "\t\t\t}",
      "\t\t\tres",
      "\t\t}",
      "\t}",
      "\timpl<M: CommutativeMonoid + Debug> Debug for DualSegmentTree<M> {",
      "\t\tfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "\t\t\twrite!(f, \"DualSegmentTree {{ [\").ok();",
      "\t\t\tfor i in 0..self.size {",
      "\t\t\t\tif i + 1 < self.size {",
      "\t\t\t\t\twrite!(f, \"{:?}, \", self.get_point(i)).ok();",
      "\t\t\t\t} else {",
      "\t\t\t\t\twrite!(f, \"{:?}\", self.get_point(i)).ok();",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\twrite!(f, \"] }}\")",
      "\t\t}",
      "\t}",
      "\tpub mod Alg {",
      "\t\tuse std::fmt::Debug;",
      "\t\tuse super::CommutativeMonoid;",
      "\t\t/// 整数の和",
      "\t\t#[derive(Debug)]",
      "\t\tpub struct Add;",
      "\t\timpl CommutativeMonoid for Add {",
      "\t\t\ttype Val = isize;",
      "\t\t\tconst E: Self::Val = 0;",
      "\t\t\tfn op(arg1: &Self::Val, arg2: &Self::Val) -> Self::Val {",
      "\t\t\t\targ1 + arg2",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// bit単位の排他的論理和",
      "\t\tpub struct Xor;",
      "\t\timpl CommutativeMonoid for Xor {",
      "\t\t\ttype Val = usize;",
      "\t\t\tconst E: Self::Val = 0;",
      "\t\t\tfn op(arg1: &Self::Val, arg2: &Self::Val) -> Self::Val {",
      "\t\t\t\targ1 ^ arg2",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// chmin操作",
      "\t\t#[derive(Debug)]",
      "\t\tpub struct Min;",
      "\t\timpl CommutativeMonoid for Min {",
      "\t\t\ttype Val = isize;",
      "\t\t\tconst E: Self::Val = isize::MAX;",
      "\t\t\tfn op(arg1: &Self::Val, arg2: &Self::Val) -> Self::Val {",
      "\t\t\t\t*arg1.min(arg2)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "双対セグメント木：区間加算・一点取得"
  },
  "macro_chmax.rs": {
    "prefix": "macro_chmax",
    "body": [
      "mod macro_chmax {",
      "\t#![allow(dead_code)]",
      "\t//! chmaxの実装",
      "\t/// `chmax!{x1, x2, ..., xn}`:`x1`,`x2`,...,`xn`のうち最大のものを、`x1`に代入する",
      "\t/// - 代入があったとき、`true`を返す",
      "\t#[macro_export]",
      "\tmacro_rules! chmax {",
      "\t\t( \\$a:expr, \\$b:expr \\$(,)* ) => {{",
      "\t\t\tif \\$a < \\$b {",
      "\t\t\t\t\\$a = \\$b;",
      "\t\t\t\ttrue",
      "\t\t\t} else {",
      "\t\t\t\tfalse",
      "\t\t\t}",
      "\t\t}};",
      "\t\t( \\$a:expr, \\$b:expr, \\$c:expr \\$(,\\$other:expr)* \\$(,)* ) => {{",
      "\t\t\tchmax! {",
      "\t\t\t\t\\$a,",
      "\t\t\t\t(\\$b).max(\\$c)",
      "\t\t\t\t\\$(,\\$other)*",
      "\t\t\t}",
      "\t\t}}",
      "\t}",
      "}"
    ],
    "description": "chmaxの実装"
  },
  "enum_pairs.rs": {
    "prefix": "enum_pairs",
    "body": [
      "mod enum_pairs {",
      "\t#![allow(dead_code)]",
      "\t//! N人をペアに分ける組合せを全列挙する",
      "\t/// ペアを列挙する",
      "\t#[derive(Debug)]",
      "\tpub struct PairsIterator<T: Clone> {",
      "\t\tstack: Vec<(Vec<T>, Vec<(T, T)>)>,",
      "\t}",
      "\timpl<T: Clone> FromIterator<T> for PairsIterator<T> {",
      "\t\tfn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {",
      "\t\t\tSelf {",
      "\t\t\t\tstack: vec![(iter.into_iter().collect::<Vec<T>>(), vec![])],",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\timpl<T: Clone> Iterator for PairsIterator<T> {",
      "\t\ttype Item = Vec<(T, T)>;",
      "\t\tfn next(&mut self) -> Option<Self::Item> {",
      "\t\t\tloop {",
      "\t\t\t\tlet Some((rem, pairs)) = self.stack.pop() else {",
      "\t\t\t\t\treturn None;",
      "\t\t\t\t};",
      "\t\t\t\tif rem.len() < 2 {",
      "\t\t\t\t\treturn Some(pairs);",
      "\t\t\t\t}",
      "\t\t\t\tfor i in (1..rem.len()).rev() {",
      "\t\t\t\t\tlet mut new_rem = rem.clone();",
      "\t\t\t\t\tlet snd = new_rem.remove(i);",
      "\t\t\t\t\tlet fst = new_rem.remove(0);",
      "\t\t\t\t\tlet mut new_pairs = pairs.clone();",
      "\t\t\t\t\tnew_pairs.push((fst, snd));",
      "\t\t\t\t\t// 新しい要素を追加",
      "\t\t\t\t\tself.stack.push((new_rem, new_pairs));",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\t/// (0〜n-1)のn個の要素からなる系列",
      "\t/// をペアにする組合せを列挙する",
      "\tpub fn pairs_usize(n: usize) -> PairsIterator<usize> {",
      "\t\t(0..n).collect()",
      "\t}",
      "}"
    ],
    "description": "N人をペアに分ける組合せを全列挙する"
  },
  "segment_tree_mutable.rs": {
    "prefix": "segment_tree_mutable",
    "body": [
      "mod segment_tree_mutable {",
      "\t#![allow(dead_code)]",
      "\t//! セグメント木（関数を渡す）",
      "\tuse std::fmt::{self, Debug};",
      "\tuse std::ops::{",
      "\t\tBound::{Excluded, Included, Unbounded},",
      "\t\tDeref, DerefMut, Index, RangeBounds,",
      "\t};",
      "\t/// # SegmentTree (Monoid)",
      "\t/// - 抽象化セグメント木",
      "\tpub struct SegmentTree<T, F>",
      "\twhere",
      "\t\tT: Debug + Clone + PartialEq,",
      "\t\tF: Fn(&T, &T) -> T,",
      "\t{",
      "\t\tpub size: usize,",
      "\t\toffset: usize,",
      "\t\te: T,",
      "\t\top: F,",
      "\t\tdata: Vec<T>,",
      "\t}",
      "\timpl<T, F> Index<usize> for SegmentTree<T, F>",
      "\twhere",
      "\t\tT: Debug + Clone + PartialEq,",
      "\t\tF: Fn(&T, &T) -> T,",
      "\t{",
      "\t\ttype Output = T;",
      "\t\tfn index(&self, idx: usize) -> &Self::Output {",
      "\t\t\t&self.data[self.offset + idx]",
      "\t\t}",
      "\t}",
      "\timpl<T, F> SegmentTree<T, F>",
      "\twhere",
      "\t\tT: Debug + Clone + PartialEq,",
      "\t\tF: Fn(&T, &T) -> T,",
      "\t{",
      "\t\t#[inline]",
      "\t\tfn parse_range<R: RangeBounds<usize>>(&self, range: R) -> Option<(usize, usize)> {",
      "\t\t\tlet start = match range.start_bound() {",
      "\t\t\t\tUnbounded => 0,",
      "\t\t\t\tExcluded(&v) => v + 1,",
      "\t\t\t\tIncluded(&v) => v,",
      "\t\t\t}",
      "\t\t\t.min(self.size);",
      "\t\t\tlet end = match range.end_bound() {",
      "\t\t\t\tUnbounded => self.size,",
      "\t\t\t\tExcluded(&v) => v,",
      "\t\t\t\tIncluded(&v) => v + 1,",
      "\t\t\t}",
      "\t\t\t.min(self.size);",
      "\t\t\tif start <= end {",
      "\t\t\t\tSome((start, end))",
      "\t\t\t} else {",
      "\t\t\t\tNone",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// セグメント木を初期化する",
      "\t\tpub fn new(n: usize, e: T, op: F) -> Self {",
      "\t\t\tlet offset = n.next_power_of_two();",
      "\t\t\tSelf {",
      "\t\t\t\tsize: n,",
      "\t\t\t\toffset,",
      "\t\t\t\te: e.clone(),",
      "\t\t\t\top,",
      "\t\t\t\tdata: vec![e; offset << 1],",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// セグメント木を配列から初期化する",
      "\t\tpub fn build(src: &[T], e: T, op: F) -> Self {",
      "\t\t\tlet mut seg = Self::new(src.len(), e, op);",
      "\t\t\tfor (i, v) in src.iter().enumerate() {",
      "\t\t\t\tseg.data[seg.offset + i] = v.clone();",
      "\t\t\t}",
      "\t\t\tfor i in (0..seg.offset).rev() {",
      "\t\t\t\tlet lch = i << 1;",
      "\t\t\t\tseg.data[i] = (seg.op)(&seg.data[lch], &seg.data[lch + 1]);",
      "\t\t\t}",
      "\t\t\tseg",
      "\t\t}",
      "\t\tpub fn update(&mut self, index: usize, value: T) {",
      "\t\t\tlet mut i = index + self.offset;",
      "\t\t\tself.data[i] = value;",
      "\t\t\twhile i > 1 {",
      "\t\t\t\ti >>= 1;",
      "\t\t\t\tlet lch = i << 1;",
      "\t\t\t\tself.data[i] = (self.op)(&self.data[lch], &self.data[lch + 1]);",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 可変な参照を返す",
      "\t\tpub fn get_mut(&mut self, i: usize) -> Option<ValMut<'_, T, F>> {",
      "\t\t\tif i < self.offset {",
      "\t\t\t\tlet default = self.index(i).clone();",
      "\t\t\t\tSome(ValMut {",
      "\t\t\t\t\tsegtree: self,",
      "\t\t\t\t\tidx: i,",
      "\t\t\t\t\tnew_val: default,",
      "\t\t\t\t})",
      "\t\t\t} else {",
      "\t\t\t\tNone",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 区間`range`の集約を行う",
      "\t\tpub fn get_range<R: RangeBounds<usize>>(&self, range: R) -> T {",
      "\t\t\tlet parsed = self.parse_range(range);",
      "\t\t\tif parsed.is_none() {",
      "\t\t\t\treturn self.e.clone();",
      "\t\t\t}",
      "\t\t\tlet (start, end) = parsed.unwrap();",
      "\t\t\t// 全体の値を取得",
      "\t\t\tif (start, end) == (0, self.size) {",
      "\t\t\t\treturn self.data[1].clone();",
      "\t\t\t}",
      "\t\t\t// 値の取得",
      "\t\t\tlet mut l = self.offset + start;",
      "\t\t\tlet mut r = self.offset + end;",
      "\t\t\tlet (mut res_l, mut res_r) = (self.e.clone(), self.e.clone());",
      "\t\t\twhile l < r {",
      "\t\t\t\tif l & 1 == 1 {",
      "\t\t\t\t\tres_l = (self.op)(&res_l, &self.data[l]);",
      "\t\t\t\t\tl += 1;",
      "\t\t\t\t}",
      "\t\t\t\tif r & 1 == 1 {",
      "\t\t\t\t\tr -= 1;",
      "\t\t\t\t\tres_r = (self.op)(&self.data[r], &res_r);",
      "\t\t\t\t}",
      "\t\t\t\tl >>= 1;",
      "\t\t\t\tr >>= 1;",
      "\t\t\t}",
      "\t\t\t(self.op)(&res_l, &res_r)",
      "\t\t}",
      "\t}",
      "\timpl<T: Debug, F> std::fmt::Debug for SegmentTree<T, F>",
      "\twhere",
      "\t\tT: Debug + Clone + PartialEq,",
      "\t\tF: Fn(&T, &T) -> T,",
      "\t{",
      "\t\tfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "\t\t\twrite!(f, \"SegmentTree {{ [\").ok();",
      "\t\t\tfor i in 0..self.size {",
      "\t\t\t\tif i + 1 < self.size {",
      "\t\t\t\t\twrite!(f, \"{:?}, \", self.data[self.offset + i]).ok();",
      "\t\t\t\t} else {",
      "\t\t\t\t\twrite!(f, \"{:?}\", self.data[self.offset + i]).ok();",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\twrite!(f, \"] }}\")",
      "\t\t}",
      "\t}",
      "\tpub struct ValMut<'a, T: 'a, F>",
      "\twhere",
      "\t\tT: Debug + Clone + PartialEq,",
      "\t\tF: Fn(&T, &T) -> T,",
      "\t{",
      "\t\tsegtree: &'a mut SegmentTree<T, F>,",
      "\t\tidx: usize,",
      "\t\tnew_val: T,",
      "\t}",
      "\timpl<T: Debug, F> fmt::Debug for ValMut<'_, T, F>",
      "\twhere",
      "\t\tT: Debug + Clone + PartialEq,",
      "\t\tF: Fn(&T, &T) -> T,",
      "\t{",
      "\t\tfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "\t\t\tf.debug_tuple(\"ValMut\")",
      "\t\t\t\t.field(&self.segtree.index(self.idx))",
      "\t\t\t\t.finish()",
      "\t\t}",
      "\t}",
      "\timpl<T, F> Drop for ValMut<'_, T, F>",
      "\twhere",
      "\t\tT: Debug + Clone + PartialEq,",
      "\t\tF: Fn(&T, &T) -> T,",
      "\t{",
      "\t\tfn drop(&mut self) {",
      "\t\t\tself.segtree.update(self.idx, self.new_val.clone());",
      "\t\t}",
      "\t}",
      "\timpl<T, F> Deref for ValMut<'_, T, F>",
      "\twhere",
      "\t\tT: Debug + Clone + PartialEq,",
      "\t\tF: Fn(&T, &T) -> T,",
      "\t{",
      "\t\ttype Target = T;",
      "\t\tfn deref(&self) -> &Self::Target {",
      "\t\t\t&self.segtree[self.idx]",
      "\t\t}",
      "\t}",
      "\timpl<T, F> DerefMut for ValMut<'_, T, F>",
      "\twhere",
      "\t\tT: Debug + Clone + PartialEq,",
      "\t\tF: Fn(&T, &T) -> T,",
      "\t{",
      "\t\tfn deref_mut(&mut self) -> &mut Self::Target {",
      "\t\t\t&mut self.new_val",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "セグメント木（関数を渡す）"
  },
  "acc2d_cyclic.rs": {
    "prefix": "acc2d_cyclic",
    "body": [
      "mod acc2d_cyclic {",
      "\t#![allow(dead_code)]",
      "\tuse std::{",
      "\t\tconvert::{TryFrom, TryInto},",
      "\t\tfmt::Debug,",
      "\t\tops::{",
      "\t\t\tBound::{Excluded, Included, Unbounded},",
      "\t\t\tMul, RangeBounds,",
      "\t\t},",
      "\t};",
      "\tuse num_traits::Num;",
      "\t/// 2次元累積和",
      "\tpub struct Acc2D<T: Num + Copy> {",
      "\t\tpub H: usize,",
      "\t\tpub W: usize,",
      "\t\tpub S: Vec<Vec<T>>,",
      "\t}",
      "\timpl<T> Acc2D<T>",
      "\twhere",
      "\t\tT: Num + Copy + TryFrom<usize> + Mul,",
      "\t\t<T as TryFrom<usize>>::Error: Debug,",
      "\t{",
      "\t\t#[inline]",
      "\t\tfn parse_range<R: RangeBounds<usize>>(&self, range: &R, max: usize) -> Option<(usize, usize)> {",
      "\t\t\tlet start = match range.start_bound() {",
      "\t\t\t\tUnbounded => 0,",
      "\t\t\t\tExcluded(&v) => v + 1,",
      "\t\t\t\tIncluded(&v) => v,",
      "\t\t\t};",
      "\t\t\tlet end = match range.end_bound() {",
      "\t\t\t\tUnbounded => max,",
      "\t\t\t\tExcluded(&v) => v,",
      "\t\t\t\tIncluded(&v) => v + 1,",
      "\t\t\t};",
      "\t\t\tif start <= end && end <= max {",
      "\t\t\t\tSome((start, end))",
      "\t\t\t} else {",
      "\t\t\t\tNone",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 2次元配列から累積和を初期化する",
      "\t\tpub fn new(array: &Vec<Vec<T>>) -> Self {",
      "\t\t\tlet (H, W) = (array.len(), array[0].len());",
      "\t\t\tlet mut S = vec![vec![T::zero(); W + 1]; H + 1];",
      "\t\t\tfor i in 0..H {",
      "\t\t\t\tfor j in 0..W {",
      "\t\t\t\t\tS[i + 1][j + 1] = array[i][j] + S[i][j + 1] + S[i + 1][j] - S[i][j];",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\tSelf { H, W, S }",
      "\t\t}",
      "\t\t/// 累積和の値を求める",
      "\t\tpub fn sum<R, C>(&self, row: R, col: C) -> T",
      "\t\twhere",
      "\t\t\tR: RangeBounds<usize> + Debug,",
      "\t\t\tC: RangeBounds<usize> + Debug,",
      "\t\t{",
      "\t\t\tlet Some((rs, re)) = self.parse_range(&row, self.H) else {",
      "\t\t\t\tpanic!(\"The given range is wrong (row): {:?}\", row);",
      "\t\t\t};",
      "\t\t\tlet Some((cs, ce)) = self.parse_range(&col, self.W) else {",
      "\t\t\t\tpanic!(\"The given range is wrong (col): {:?}\", col);",
      "\t\t\t};",
      "\t\t\tself.S[re][ce] + self.S[rs][cs] - self.S[re][cs] - self.S[rs][ce]",
      "\t\t}",
      "\t\t/// トーラスとみなしたときの和を求める",
      "\t\t/// ## Args",
      "\t\t/// - `(top,left)`：左上の座標",
      "\t\t/// - `(height,width)`：取得する区間",
      "\t\tpub fn sum_cyclic(&self, mut top: usize, mut left: usize, height: usize, width: usize) -> T {",
      "\t\t\ttop %= self.H;",
      "\t\t\tleft %= self.W;",
      "\t\t\t// 繰り返し回数",
      "\t\t\tlet hrep: T = (height / self.H).try_into().unwrap();",
      "\t\t\tlet wrep: T = (width / self.H).try_into().unwrap();",
      "\t\t\t// 右下の座標",
      "\t\t\tlet bottom = (top + height) % self.H;",
      "\t\t\tlet right = (left + width) % self.W;",
      "\t\t\t// 内部領域",
      "\t\t\tlet S_inner = self.sum(.., ..) * hrep * wrep;",
      "\t\t\t// 左右の領域",
      "\t\t\tlet S_lr = if left <= right {",
      "\t\t\t\tself.sum(.., left..right) * hrep",
      "\t\t\t} else {",
      "\t\t\t\t(self.sum(.., left..) + self.sum(.., ..right)) * hrep",
      "\t\t\t};",
      "\t\t\t// 上下の領域",
      "\t\t\tlet S_tb = if top <= bottom {",
      "\t\t\t\tself.sum(top..bottom, ..) * wrep",
      "\t\t\t} else {",
      "\t\t\t\t(self.sum(top.., ..) + self.sum(..bottom, ..)) * wrep",
      "\t\t\t};",
      "\t\t\t// 端の領域",
      "\t\t\tlet S_edge = match (top <= bottom, left <= right) {",
      "\t\t\t\t(true, true) => self.sum(top..bottom, left..right),",
      "\t\t\t\t(true, false) => self.sum(top..bottom, left..) + self.sum(top..bottom, ..right),",
      "\t\t\t\t(false, true) => self.sum(top.., left..right) + self.sum(..bottom, left..right),",
      "\t\t\t\t(false, false) => {",
      "\t\t\t\t\tself.sum(top.., left..)",
      "\t\t\t\t\t\t+ self.sum(top.., ..right)",
      "\t\t\t\t\t\t+ self.sum(..bottom, left..)",
      "\t\t\t\t\t\t+ self.sum(..bottom, ..right)",
      "\t\t\t\t}",
      "\t\t\t};",
      "\t\t\tS_inner + S_lr + S_tb + S_edge",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": ""
  },
  "weighted_union_find.rs": {
    "prefix": "weighted_union_find",
    "body": [
      "mod weighted_union_find {",
      "\t#![allow(dead_code)]",
      "\t//! 重み付きUnionFind",
      "\tuse std::fmt::Debug;",
      "\t/// ## アーベル群",
      "\tpub trait Abel {",
      "\t\ttype E: Debug + Clone;",
      "\t\tconst I: Self::E;",
      "\t\tfn op(x: &Self::E, y: &Self::E) -> Self::E;",
      "\t\tfn inv(x: &Self::E) -> Self::E;",
      "\t}",
      "\t/// # 重み付きUnionFind",
      "\tpub struct WeightedUnionFind<G: Abel> {",
      "\t\tpar: Vec<usize>,",
      "\t\trank: Vec<usize>,",
      "\t\tweight: Vec<G::E>,",
      "\t\tpub group_count: usize,",
      "\t}",
      "\timpl<G: Abel> WeightedUnionFind<G> {",
      "\t\t/// UnionFindを構築",
      "\t\tpub fn new(n: usize) -> Self {",
      "\t\t\tWeightedUnionFind {",
      "\t\t\t\tpar: (0..n).collect(),",
      "\t\t\t\trank: vec![1; n],",
      "\t\t\t\tweight: vec![G::I; n],",
      "\t\t\t\tgroup_count: n,",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 根を求める",
      "\t\tpub fn root(&mut self, x: usize) -> usize {",
      "\t\t\tif self.par[x] == x {",
      "\t\t\t\treturn x;",
      "\t\t\t}",
      "\t\t\tlet r = self.root(self.par[x]);",
      "\t\t\tlet parent = self.weight[self.par[x]].clone();",
      "\t\t\tlet child = self.weight.get_mut(x).unwrap();",
      "\t\t\t*child = G::op(child, &parent);",
      "\t\t\tself.par[x] = r; // 経路圧縮",
      "\t\t\tr",
      "\t\t}",
      "\t\t/// 重みを求める",
      "\t\tpub fn weight(&mut self, x: usize) -> G::E {",
      "\t\t\tself.root(x); // 経路圧縮",
      "\t\t\tself.weight[x].clone()",
      "\t\t}",
      "\t\t/// 同一の集合に所属するか判定",
      "\t\tpub fn issame(&mut self, x: usize, y: usize) -> bool {",
      "\t\t\tself.root(x) == self.root(y)",
      "\t\t}",
      "\t\t/// 重みの差を求める",
      "\t\t/// - 同じグループにいない場合にはNone",
      "\t\tpub fn diff(&mut self, x: usize, y: usize) -> Option<G::E> {",
      "\t\t\tif self.issame(x, y) {",
      "\t\t\t\tlet res = G::op(&self.weight(y), &G::inv(&self.weight(x)));",
      "\t\t\t\treturn Some(res);",
      "\t\t\t}",
      "\t\t\tNone",
      "\t\t}",
      "\t\t/// 要素を結合",
      "\t\tpub fn unite(&mut self, mut x: usize, mut y: usize, mut weight: G::E) -> bool {",
      "\t\t\t// x,yそれぞれについて重み差分を補正",
      "\t\t\tweight = G::op(&weight, &self.weight(x));",
      "\t\t\tweight = G::op(&weight, &G::inv(&self.weight(y)));",
      "\t\t\tx = self.root(x);",
      "\t\t\ty = self.root(y);",
      "\t\t\tif x == y {",
      "\t\t\t\treturn false;",
      "\t\t\t}",
      "\t\t\t// 要素数が大きい方を子にすることで、高さを均等に保つ",
      "\t\t\tif self.rank[x] < self.rank[y] {",
      "\t\t\t\tstd::mem::swap(&mut x, &mut y);",
      "\t\t\t\tweight = G::inv(&weight);",
      "\t\t\t}",
      "\t\t\tself.par[y] = x;",
      "\t\t\tself.rank[x] += self.rank[y];",
      "\t\t\tself.group_count -= 1;",
      "\t\t\t// 重みの更新",
      "\t\t\tself.weight[y] = weight;",
      "\t\t\ttrue",
      "\t\t}",
      "\t\tpub fn size(&mut self, x: usize) -> usize {",
      "\t\t\tlet root = self.root(x);",
      "\t\t\tself.rank[root]",
      "\t\t}",
      "\t}",
      "\tpub mod Alg {",
      "\t\tuse super::Abel;",
      "\t\tpub struct Add;",
      "\t\timpl Abel for Add {",
      "\t\t\ttype E = isize;",
      "\t\t\tconst I: Self::E = 0;",
      "\t\t\tfn op(x: &Self::E, y: &Self::E) -> Self::E {",
      "\t\t\t\tx + y",
      "\t\t\t}",
      "\t\t\tfn inv(x: &Self::E) -> Self::E {",
      "\t\t\t\t-x",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "重み付きUnionFind"
  },
  "powmod.rs": {
    "prefix": "powmod",
    "body": [
      "mod powmod {",
      "\t#![allow(dead_code)]",
      "\t//! あまりを取る累乗",
      "\t/// 余りをとる累乗",
      "\tpub fn powmod(mut a: usize, mut b: usize, m: usize) -> usize {",
      "\t\tlet mut res = 1;",
      "\t\twhile b > 0 {",
      "\t\t\tif b & 1 == 1 {",
      "\t\t\t\tres = (res * a) % m;",
      "\t\t\t}",
      "\t\t\ta = (a * a) % m;",
      "\t\t\tb >>= 1;",
      "\t\t}",
      "\t\tres",
      "\t}",
      "}"
    ],
    "description": "あまりを取る累乗"
  },
  "miller_rabin_test.rs": {
    "prefix": "miller_rabin_test",
    "body": [
      "mod miller_rabin_test {",
      "\t#![allow(dead_code)]",
      "\t//! ミラー・ラビン素数判定法",
      "\t/// 余りをとる累乗",
      "\tpub fn powmod(a: usize, b: usize, m: usize) -> usize {",
      "\t\tlet (mut a, mut b, m) = (a as u128, b as u128, m as u128);",
      "\t\tlet mut res = 1;",
      "\t\twhile b > 0 {",
      "\t\t\tif b & 1 == 1 {",
      "\t\t\t\tres = (res * a) % m;",
      "\t\t\t}",
      "\t\t\ta = (a * a) % m;",
      "\t\t\tb >>= 1;",
      "\t\t}",
      "\t\tres as usize",
      "\t}",
      "\t/// ## ミラーラビン素数判定法",
      "\t/// 参考: <https://zenn.dev/kaki_xxx/articles/40a92b43200215>",
      "\tpub fn is_prime_MR(N: usize) -> bool {",
      "\t\tif N <= 2 {",
      "\t\t\treturn N == 2;",
      "\t\t}",
      "\t\tif N % 2 == 0 {",
      "\t\t\treturn false;",
      "\t\t}",
      "\t\tlet (mut s, mut d) = (0, N - 1);",
      "\t\twhile d % 2 == 0 {",
      "\t\t\ts += 1;",
      "\t\t\td >>= 1;",
      "\t\t}",
      "\t\t// n < 2^64 の場合、以下を調べれば十分",
      "\t\tlet A = [2, 325, 9375, 28178, 450775, 9780504, 1795265022];",
      "\t\tfor &a in &A {",
      "\t\t\tif a % N == 0 {",
      "\t\t\t\tbreak;",
      "\t\t\t}",
      "\t\t\tlet mut t = 0;",
      "\t\t\tlet mut x = powmod(a, d, N);",
      "\t\t\tif x != 1 {",
      "\t\t\t\twhile t < s {",
      "\t\t\t\t\tif x == N - 1 {",
      "\t\t\t\t\t\tbreak;",
      "\t\t\t\t\t}",
      "\t\t\t\t\tx = ((x as u128).pow(2) % (N as u128)) as usize;",
      "\t\t\t\t\tt += 1;",
      "\t\t\t\t}",
      "\t\t\t\tif t == s {",
      "\t\t\t\t\treturn false;",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t}",
      "\t\ttrue",
      "\t}",
      "}"
    ],
    "description": "ミラー・ラビン素数判定法"
  },
  "factors_all.rs": {
    "prefix": "factors_all",
    "body": [
      "mod factors_all {",
      "\t#![allow(dead_code)]",
      "\t//! 高速な約数列挙",
      "\t/// ## 高速約数列挙",
      "\t/// `1 ~ N`までの数の約数を高速に列挙する",
      "\t/// 計算量：`O(nloglogn)`",
      "\tpub fn factors_all(n: usize) -> Vec<Vec<usize>> {",
      "\t\tlet mut res = vec![vec![]; n + 1];",
      "\t\tfor i in 1..=n {",
      "\t\t\tfor j in 1.. {",
      "\t\t\t\tif i * j > n {",
      "\t\t\t\t\tbreak;",
      "\t\t\t\t}",
      "\t\t\t\tres[i * j].push(i);",
      "\t\t\t}",
      "\t\t}",
      "\t\tres",
      "\t}",
      "}"
    ],
    "description": "高速な約数列挙"
  },
  "union_find.rs": {
    "prefix": "union_find",
    "body": [
      "mod union_find {",
      "\t#![allow(dead_code)]",
      "\t//! UnionFind木",
      "\t/// UnionFind木",
      "\tpub struct UnionFind {",
      "\t\tpar: Vec<usize>,",
      "\t\tsiz: Vec<usize>,",
      "\t\t/// 連結成分の個数",
      "\t\tcount: usize,",
      "\t}",
      "\timpl UnionFind {",
      "\t\t/// UnionFindを新規作成",
      "\t\tpub fn new(n: usize) -> Self {",
      "\t\t\tUnionFind {",
      "\t\t\t\tpar: (0..n).collect(),",
      "\t\t\t\tsiz: vec![1; n],",
      "\t\t\t\tcount: n,",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 根を求める",
      "\t\tpub fn get_root(&mut self, x: usize) -> usize {",
      "\t\t\tif self.par[x] == x {",
      "\t\t\t\treturn x;",
      "\t\t\t}",
      "\t\t\tself.par[x] = self.get_root(self.par[x]); // 経路圧縮",
      "\t\t\tself.par[x]",
      "\t\t}",
      "\t\t/// 同一の集合に所属するか判定",
      "\t\tpub fn is_same(&mut self, x: usize, y: usize) -> bool {",
      "\t\t\tself.get_root(x) == self.get_root(y)",
      "\t\t}",
      "\t\t/// 要素を結合",
      "\t\tpub fn unite(&mut self, mut parent: usize, mut child: usize) -> bool {",
      "\t\t\tparent = self.get_root(parent);",
      "\t\t\tchild = self.get_root(child);",
      "\t\t\tif parent == child {",
      "\t\t\t\treturn false;",
      "\t\t\t}",
      "\t\t\t// 要素数が大きい方を子にすることで、高さを均等に保つ",
      "\t\t\tif self.siz[parent] < self.siz[child] {",
      "\t\t\t\tstd::mem::swap(&mut parent, &mut child);",
      "\t\t\t}",
      "\t\t\tself.par[child] = parent;",
      "\t\t\tself.siz[parent] += self.siz[child];",
      "\t\t\tself.count -= 1;",
      "\t\t\ttrue",
      "\t\t}",
      "\t\t/// 連結成分の大きさを求める",
      "\t\tpub fn get_size(&mut self, x: usize) -> usize {",
      "\t\t\tlet get_root = self.get_root(x);",
      "\t\t\tself.siz[get_root]",
      "\t\t}",
      "\t\t/// 連結成分の数を返す",
      "\t\tpub fn group_count(&self) -> usize {",
      "\t\t\tself.count",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "UnionFind木"
  },
  "pollard_rho_algorithm.rs": {
    "prefix": "pollard_rho_algorithm",
    "body": [
      "mod miller_rabin_test {",
      "\t#![allow(dead_code)]",
      "\t//! ミラー・ラビン素数判定法",
      "\t/// 余りをとる累乗",
      "\tpub fn powmod(a: usize, b: usize, m: usize) -> usize {",
      "\t\tlet (mut a, mut b, m) = (a as u128, b as u128, m as u128);",
      "\t\tlet mut res = 1;",
      "\t\twhile b > 0 {",
      "\t\t\tif b & 1 == 1 {",
      "\t\t\t\tres = (res * a) % m;",
      "\t\t\t}",
      "\t\t\ta = (a * a) % m;",
      "\t\t\tb >>= 1;",
      "\t\t}",
      "\t\tres as usize",
      "\t}",
      "\t/// ## ミラーラビン素数判定法",
      "\t/// 参考: <https://zenn.dev/kaki_xxx/articles/40a92b43200215>",
      "\tpub fn is_prime_MR(N: usize) -> bool {",
      "\t\tif N <= 2 {",
      "\t\t\treturn N == 2;",
      "\t\t}",
      "\t\tif N % 2 == 0 {",
      "\t\t\treturn false;",
      "\t\t}",
      "\t\tlet (mut s, mut d) = (0, N - 1);",
      "\t\twhile d % 2 == 0 {",
      "\t\t\ts += 1;",
      "\t\t\td >>= 1;",
      "\t\t}",
      "\t\t// n < 2^64 の場合、以下を調べれば十分",
      "\t\tlet A = [2, 325, 9375, 28178, 450775, 9780504, 1795265022];",
      "\t\tfor &a in &A {",
      "\t\t\tif a % N == 0 {",
      "\t\t\t\tbreak;",
      "\t\t\t}",
      "\t\t\tlet mut t = 0;",
      "\t\t\tlet mut x = powmod(a, d, N);",
      "\t\t\tif x != 1 {",
      "\t\t\t\twhile t < s {",
      "\t\t\t\t\tif x == N - 1 {",
      "\t\t\t\t\t\tbreak;",
      "\t\t\t\t\t}",
      "\t\t\t\t\tx = ((x as u128).pow(2) % (N as u128)) as usize;",
      "\t\t\t\t\tt += 1;",
      "\t\t\t\t}",
      "\t\t\t\tif t == s {",
      "\t\t\t\t\treturn false;",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t}",
      "\t\ttrue",
      "\t}",
      "}",
      "",
      "mod pollard_rho_algorithm {",
      "\t#![allow(dead_code)]",
      "\t//! ポラード・ロー法による素因数分解",
      "\tuse crate::miller_rabin_test::is_prime_MR;",
      "\t/// `a`,`b`の最大公約数を求める",
      "\tpub fn gcd(a: usize, b: usize) -> usize {",
      "\t\tif b == 0 {",
      "\t\t\ta",
      "\t\t} else {",
      "\t\t\tgcd(b, a % b)",
      "\t\t}",
      "\t}",
      "\t/// ## pollard_rho",
      "\t/// ポラード・ロー法を適用し、約数を見つける",
      "\tpub fn pollard_rho(N: usize) -> usize {",
      "\t\tif N % 2 == 0 {",
      "\t\t\treturn 2;",
      "\t\t}",
      "\t\tif is_prime_MR(N) {",
      "\t\t\treturn N;",
      "\t\t}",
      "\t\tlet f = |x: usize| -> usize { (((x as u128).pow(2) + 1) % N as u128) as usize };",
      "\t\tlet mut step = 0;",
      "\t\tloop {",
      "\t\t\tstep += 1;",
      "\t\t\tlet mut x = step;",
      "\t\t\tlet mut y = f(x);",
      "\t\t\tloop {",
      "\t\t\t\tlet p = gcd(N + y - x, N);",
      "\t\t\t\tif p == 0 || p == N {",
      "\t\t\t\t\tbreak;",
      "\t\t\t\t}",
      "\t\t\t\tif p != 1 {",
      "\t\t\t\t\treturn p;",
      "\t\t\t\t}",
      "\t\t\t\tx = f(x);",
      "\t\t\t\ty = f(f(y));",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\t/// ## factorize",
      "\t/// ポラード・ロー法による高速素因数分解",
      "\t/// `O(n^(1/4))`",
      "\tpub fn factorize(N: usize) -> Vec<usize> {",
      "\t\tif N == 1 {",
      "\t\t\treturn vec![];",
      "\t\t}",
      "\t\tlet p = pollard_rho(N);",
      "\t\tif p == N {",
      "\t\t\treturn vec![N];",
      "\t\t}",
      "\t\tlet mut left = factorize(p);",
      "\t\tlet mut right = factorize(N / p);",
      "\t\tleft.append(&mut right);",
      "\t\tleft.sort();",
      "\t\tleft",
      "\t}",
      "}"
    ],
    "description": "ポラード・ロー法による素因数分解"
  },
  "dynamic_segment_tree.rs": {
    "prefix": "dynamic_segment_tree",
    "body": [
      "mod monoid {",
      "\t#![allow(dead_code)]",
      "\t//! モノイド",
      "\tuse std::fmt::Debug;",
      "\t/// モノイド",
      "\tpub trait Monoid {",
      "\t\t/// 元の型",
      "\t\ttype Val: Debug + Clone + PartialEq;",
      "\t\t/// 単位元",
      "\t\tconst E: Self::Val;",
      "\t\t/// 演算",
      "\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val;",
      "\t}",
      "\t/// 各種モノイド",
      "\tpub mod examples {",
      "\t\tuse super::Monoid;",
      "\t\t/// 和",
      "\t\tpub struct Add;",
      "\t\timpl Monoid for Add {",
      "\t\t\ttype Val = isize;",
      "\t\t\tconst E: Self::Val = 0;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tleft + right",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 積",
      "\t\tpub struct Mul;",
      "\t\timpl Monoid for Mul {",
      "\t\t\ttype Val = isize;",
      "\t\t\tconst E: Self::Val = 1;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tleft * right",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// bit単位の排他的論理和",
      "\t\tpub struct Xor;",
      "\t\timpl Monoid for Xor {",
      "\t\t\ttype Val = usize;",
      "\t\t\tconst E: Self::Val = 0;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tleft ^ right",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 最小値",
      "\t\tpub struct Min;",
      "\t\timpl Monoid for Min {",
      "\t\t\ttype Val = isize;",
      "\t\t\tconst E: Self::Val = (1 << 31) - 1;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\t*left.min(right)",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 最大値",
      "\t\tpub struct Max;",
      "\t\timpl Monoid for Max {",
      "\t\t\ttype Val = isize;",
      "\t\t\tconst E: Self::Val = -((1 << 31) - 1);",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\t*left.max(right)",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 最小公倍数",
      "\t\tpub struct GCD;",
      "\t\timpl Monoid for GCD {",
      "\t\t\ttype Val = usize;",
      "\t\t\tconst E: Self::Val = 0;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tgcd(*left, *right)",
      "\t\t\t}",
      "\t\t}",
      "\t\tpub fn gcd(a: usize, b: usize) -> usize {",
      "\t\t\tif b == 0 {",
      "\t\t\t\ta",
      "\t\t\t} else {",
      "\t\t\t\tgcd(b, a % b)",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// アフィン変換（浮動小数点数）",
      "\t\tstruct Affine;",
      "\t\timpl Monoid for Affine {",
      "\t\t\ttype Val = (f64, f64);",
      "\t\t\tconst E: Self::Val = (1.0, 0.0);",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tlet &(a1, b1) = left;",
      "\t\t\t\tlet &(a2, b2) = right;",
      "\t\t\t\t(a2 * a1, a2 * b1 + b2)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "}",
      "",
      "mod dynamic_segment_tree {",
      "\t#![allow(dead_code)]",
      "\t//! AA木による動的セグ木",
      "\t//! - 遅延評価なし",
      "\tuse crate::monoid;",
      "\tpub use dynamic_segment_tree::*;",
      "\tmod dynamic_segment_tree {",
      "\t\t//! AA木による動的セグ木",
      "\t\t//! - 遅延評価なし",
      "\t\tuse std::{",
      "\t\t\tfmt::{self, Debug},",
      "\t\t\tops::{Bound::Unbounded, Deref, DerefMut, RangeBounds},",
      "\t\t};",
      "\t\tuse super::{",
      "\t\t\tmonoid::Monoid,",
      "\t\t\tnode::{delete, get, get_range, insert, Node, NodeInner},",
      "\t\t};",
      "\t\t/// 動的セグメント木",
      "\t\t/// - 平行2分木（AA木）",
      "\t\t/// - 遅延評価なし",
      "\t\tpub struct DynamicSegmentTree<K: Ord, M: Monoid> {",
      "\t\t\tpub root: Node<K, M>,",
      "\t\t\tsize: usize,",
      "\t\t\t/// getメソッドで返すための一時的な単位元",
      "\t\t\ttmp_e: M::Val,",
      "\t\t}",
      "\t\timpl<K: Ord, M: Monoid> DynamicSegmentTree<K, M> {",
      "\t\t\t/// 動的セグ木の初期化",
      "\t\t\tpub fn new() -> Self {",
      "\t\t\t\tSelf {",
      "\t\t\t\t\troot: None,",
      "\t\t\t\t\tsize: 0,",
      "\t\t\t\t\ttmp_e: M::E,",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\t/// 1点取得（不変参照）",
      "\t\t\t/// - 値 `key` を持つノードの不変参照を取得する",
      "\t\t\tpub fn get(&self, key: &K) -> &M::Val {",
      "\t\t\t\tif let Some(NodeInner { value, .. }) = get(&self.root, key) {",
      "\t\t\t\t\tvalue",
      "\t\t\t\t} else {",
      "\t\t\t\t\t&self.tmp_e",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\t/// 1点取得（可変参照）",
      "\t\t\t/// - 値 `key` を持つノードの可変参照を取得する",
      "\t\t\tpub fn get_mut(&mut self, key: K) -> NodeEntry<'_, K, M> {",
      "\t\t\t\tlet (new_root, old_key_val) = delete(self.root.take(), &key);",
      "\t\t\t\tself.root = new_root;",
      "\t\t\t\tif let Some((key, value)) = old_key_val {",
      "\t\t\t\t\tNodeEntry {",
      "\t\t\t\t\t\troot: &mut self.root,",
      "\t\t\t\t\t\tkey: Some(key),",
      "\t\t\t\t\t\tvalue: Some(value),",
      "\t\t\t\t\t}",
      "\t\t\t\t} else {",
      "\t\t\t\t\t// ノードの新規作成",
      "\t\t\t\t\tself.size += 1;",
      "\t\t\t\t\tNodeEntry {",
      "\t\t\t\t\t\troot: &mut self.root,",
      "\t\t\t\t\t\tkey: Some(key),",
      "\t\t\t\t\t\tvalue: Some(M::E),",
      "\t\t\t\t\t}",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\t/// 要素の更新",
      "\t\t\t/// - `key`：更新するキー",
      "\t\t\t/// - `value`：更新後の値",
      "\t\t\tpub fn insert(&mut self, key: K, value: M::Val) {",
      "\t\t\t\tlet (new_root, old_key_value) = insert(self.root.take(), key, value);",
      "\t\t\t\tself.root = new_root;",
      "\t\t\t\t// 要素が追加された場合",
      "\t\t\t\tif old_key_value.is_none() {",
      "\t\t\t\t\tself.size += 1;",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\t/// 要素の削除",
      "\t\t\t/// - `key`：削除するキー",
      "\t\t\tpub fn remove(&mut self, key: &K) -> Option<M::Val> {",
      "\t\t\t\tlet (new_root, old_key_value) = delete(self.root.take(), key);",
      "\t\t\t\tself.root = new_root;",
      "\t\t\t\t// 削除された要素を返す",
      "\t\t\t\tif let Some((_, old_value)) = old_key_value {",
      "\t\t\t\t\tself.size -= 1;",
      "\t\t\t\t\tSome(old_value)",
      "\t\t\t\t} else {",
      "\t\t\t\t\tNone",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\t/// 区間の取得",
      "\t\t\t/// - 区間 `range` の要素を集約する",
      "\t\t\tpub fn get_range<R: RangeBounds<K>>(&self, range: R) -> M::Val {",
      "\t\t\t\tlet l = range.start_bound();",
      "\t\t\t\tlet r = range.end_bound();",
      "\t\t\t\tget_range(&self.root, l, r, Unbounded, Unbounded)",
      "\t\t\t}",
      "\t\t\t/// 要素数を取得",
      "\t\t\tpub fn len(&self) -> usize {",
      "\t\t\t\tself.size",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// ノードの可変参照",
      "\t\tpub struct NodeEntry<'a, K: Ord, M: 'a + Monoid> {",
      "\t\t\troot: &'a mut Node<K, M>,",
      "\t\t\tkey: Option<K>,",
      "\t\t\tvalue: Option<M::Val>,",
      "\t\t}",
      "\t\timpl<K: Ord + Debug, M: Monoid> Debug for NodeEntry<'_, K, M> {",
      "\t\t\tfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "\t\t\t\tf.debug_struct(\"NodeEntry\")",
      "\t\t\t\t\t.field(\"key\", &self.key.as_ref().unwrap())",
      "\t\t\t\t\t.field(\"value\", &self.value.as_ref().unwrap())",
      "\t\t\t\t\t.finish()",
      "\t\t\t}",
      "\t\t}",
      "\t\timpl<K: Ord, M: Monoid> Drop for NodeEntry<'_, K, M> {",
      "\t\t\tfn drop(&mut self) {",
      "\t\t\t\tlet root = self.root.take();",
      "\t\t\t\tlet key = self.key.take().unwrap();",
      "\t\t\t\tlet value = self.value.take().unwrap();",
      "\t\t\t\t(*self.root, _) = insert(root, key, value);",
      "\t\t\t}",
      "\t\t}",
      "\t\timpl<K: Ord, M: Monoid> Deref for NodeEntry<'_, K, M> {",
      "\t\t\ttype Target = M::Val;",
      "\t\t\tfn deref(&self) -> &Self::Target {",
      "\t\t\t\tself.value.as_ref().unwrap()",
      "\t\t\t}",
      "\t\t}",
      "\t\timpl<K: Ord, M: Monoid> DerefMut for NodeEntry<'_, K, M> {",
      "\t\t\tfn deref_mut(&mut self) -> &mut Self::Target {",
      "\t\t\t\tself.value.as_mut().unwrap()",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\tmod node {",
      "\t\t//! セグ木のノード",
      "\t\t#![allow(non_snake_case)]",
      "\t\tuse crate::monoid::Monoid;",
      "\t\tuse std::{",
      "\t\t\tcmp::Ordering,",
      "\t\t\tfmt::Debug,",
      "\t\t\tmem,",
      "\t\t\tops::Bound::{self, *},",
      "\t\t};",
      "\t\t/// AA木のノード",
      "\t\tpub type Node<K, M> = Option<Box<NodeInner<K, M>>>;",
      "\t\tpub struct NodeInner<K: Ord, M: Monoid> {",
      "\t\t\t/// キー",
      "\t\t\tpub key: K,",
      "\t\t\t/// ノードが持つ値",
      "\t\t\tpub value: M::Val,",
      "\t\t\t/// 部分木を集約した値",
      "\t\t\tpub sum: M::Val,",
      "\t\t\t/// ノードの高さ",
      "\t\t\tpub level: usize,",
      "\t\t\tpub left: Node<K, M>,",
      "\t\t\tpub right: Node<K, M>,",
      "\t\t}",
      "\t\timpl<K: Ord, M: Monoid> NodeInner<K, M> {",
      "\t\t\t/// ノードの作成",
      "\t\t\tpub fn new(key: K, value: M::Val) -> Node<K, M> {",
      "\t\t\t\tSome(Box::new(NodeInner {",
      "\t\t\t\t\tkey,",
      "\t\t\t\t\tvalue: value.clone(),",
      "\t\t\t\t\tsum: value,",
      "\t\t\t\t\tlevel: 1,",
      "\t\t\t\t\tleft: None,",
      "\t\t\t\t\tright: None,",
      "\t\t\t\t}))",
      "\t\t\t}",
      "\t\t\t/// ノードの値を再計算する",
      "\t\t\tfn eval(&mut self) {",
      "\t\t\t\t// ノードの値を再計算",
      "\t\t\t\tself.sum = match (&self.left, &self.right) {",
      "\t\t\t\t\t(Some(l), Some(r)) => M::op(&M::op(&l.sum, &self.value), &r.sum),",
      "\t\t\t\t\t(Some(l), _) => M::op(&l.sum, &self.value),",
      "\t\t\t\t\t(_, Some(r)) => M::op(&self.value, &r.sum),",
      "\t\t\t\t\t_ => self.value.clone(),",
      "\t\t\t\t};",
      "\t\t\t}",
      "\t\t}",
      "\t\timpl<K, M> Debug for NodeInner<K, M>",
      "\t\twhere",
      "\t\t\tK: Ord + Debug,",
      "\t\t\tM: Monoid,",
      "\t\t\tM::Val: Debug,",
      "\t\t{",
      "\t\t\tfn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
      "\t\t\t\tf.debug_struct(\"Node\")",
      "\t\t\t\t\t.field(\"key\", &self.key)",
      "\t\t\t\t\t.field(\"value\", &self.value)",
      "\t\t\t\t\t.field(\"sum\", &self.sum)",
      "\t\t\t\t\t.finish()",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// skew操作",
      "\t\t/// ```text",
      "\t\t///   |\t\t⇓\t\t   ⇓\t\t",
      "\t\t/// 2 |\tL ← T\t\t   L → T\t",
      "\t\t///   |   ↙ ↘   ↘   ==>   ↙   ↙ ↘   ",
      "\t\t/// 1 |  A   B   R\t   A   B   R  ",
      "\t\t/// ```",
      "\t\tfn skew<K: Ord, M: Monoid>(node: Node<K, M>) -> Node<K, M> {",
      "\t\t\tlet Some(mut T) = node else {",
      "\t\t\t\treturn None;",
      "\t\t\t};",
      "\t\t\tif T.left.is_none() {",
      "\t\t\t\tSome(T)",
      "\t\t\t} else if T.level == T.left.as_ref().unwrap().level {",
      "\t\t\t\tlet mut L = T.left.unwrap();",
      "\t\t\t\t// Tを更新",
      "\t\t\t\tT.left = L.right;",
      "\t\t\t\tT.eval();",
      "\t\t\t\t// Lを更新",
      "\t\t\t\tL.right = Some(T);",
      "\t\t\t\tL.eval();",
      "\t\t\t\tSome(L)",
      "\t\t\t} else {",
      "\t\t\t\tSome(T)",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// split操作",
      "\t\t/// ```text",
      "\t\t///   |\t\t\t\t\t\t ⇓\t",
      "\t\t/// 3 |\t\t\t\t\t\t R\t",
      "\t\t///   |\t⇓\t\t\t\t   ↙ ↘   ",
      "\t\t/// 2 |\tT → R → X   ==>\tT   X  ",
      "\t\t///   |   ↙   ↙\t\t\t  ↙ ↘\t ",
      "\t\t/// 1 |  A   B\t\t\t  A   B\t",
      "\t\t/// ```",
      "\t\tfn split<K: Ord, M: Monoid>(node: Node<K, M>) -> Node<K, M> {",
      "\t\t\tlet Some(mut T) = node else {",
      "\t\t\t\treturn None;",
      "\t\t\t};",
      "\t\t\tif T.right.is_none() || T.right.as_ref().unwrap().right.is_none() {",
      "\t\t\t\tSome(T)",
      "\t\t\t} else if T.level == T.right.as_ref().unwrap().right.as_ref().unwrap().level {",
      "\t\t\t\tlet mut R = T.right.unwrap();",
      "\t\t\t\t// Tを更新",
      "\t\t\t\tT.right = R.left;",
      "\t\t\t\tT.eval();",
      "\t\t\t\t// Rを更新",
      "\t\t\t\tR.left = Some(T);",
      "\t\t\t\tR.eval();",
      "\t\t\t\tR.level += 1; // Rのレベルを1上げる",
      "\t\t\t\tSome(R)",
      "\t\t\t} else {",
      "\t\t\t\tSome(T)",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 値 `key` を持つノードの不変参照を取得する",
      "\t\tpub fn get<'a, K: Ord, M: Monoid>(",
      "\t\t\troot: &'a Node<K, M>,",
      "\t\t\tkey: &K,",
      "\t\t) -> Option<&'a NodeInner<K, M>> {",
      "\t\t\tlet Some(T) = root else {",
      "\t\t\t\treturn None;",
      "\t\t\t};",
      "\t\t\tmatch key.cmp(&T.key) {",
      "\t\t\t\tOrdering::Less => get(&T.left, key),",
      "\t\t\t\tOrdering::Greater => get(&T.right, key),",
      "\t\t\t\tOrdering::Equal => Some(T),",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 区間",
      "\t\ttype Segment<K> = (Bound<K>, Bound<K>);",
      "\t\t/// 区間 `x` と `y` が共通部分を持たないか判定",
      "\t\tfn has_no_intersection<K: Ord>((l, r): Segment<&K>, (begin, end): Segment<&K>) -> bool {",
      "\t\t\t(match (r, begin) {",
      "\t\t\t\t(Included(r), Included(b)) => r < b,",
      "\t\t\t\t(Included(r), Excluded(b)) => r <= b,",
      "\t\t\t\t(Excluded(r), Included(b)) => r <= b,",
      "\t\t\t\t(Excluded(r), Excluded(b)) => r <= b,",
      "\t\t\t\t_ => false,",
      "\t\t\t} || match (end, l) {",
      "\t\t\t\t(Included(e), Included(l)) => e < l,",
      "\t\t\t\t(Included(e), Excluded(l)) => e <= l,",
      "\t\t\t\t(Excluded(e), Included(l)) => e <= l,",
      "\t\t\t\t(Excluded(e), Excluded(l)) => e <= l,",
      "\t\t\t\t_ => false,",
      "\t\t\t})",
      "\t\t}",
      "\t\t/// 区間 `x`（引数1） が区間 `y`（引数2） を包含するか",
      "\t\tfn includes<K: Ord>((l, r): Segment<&K>, (begin, end): Segment<&K>) -> bool {",
      "\t\t\t(match (l, begin) {",
      "\t\t\t\t(Unbounded, _) => true,",
      "\t\t\t\t(_, Unbounded) => false,",
      "\t\t\t\t(Included(l), Included(b)) => l <= b,",
      "\t\t\t\t(Included(l), Excluded(b)) => l <= b,",
      "\t\t\t\t(Excluded(l), Included(b)) => l < b,",
      "\t\t\t\t(Excluded(l), Excluded(b)) => l <= b,",
      "\t\t\t} && match (end, r) {",
      "\t\t\t\t(_, Unbounded) => true,",
      "\t\t\t\t(Unbounded, _) => false,",
      "\t\t\t\t(Included(e), Included(r)) => e <= r,",
      "\t\t\t\t(Included(e), Excluded(r)) => e < r,",
      "\t\t\t\t(Excluded(e), Included(r)) => e <= r,",
      "\t\t\t\t(Excluded(e), Excluded(r)) => e <= r,",
      "\t\t\t})",
      "\t\t}",
      "\t\t/// 区間 `[l,r)` 中のノードの値を集約する",
      "\t\tpub fn get_range<K: Ord, M: Monoid>(",
      "\t\t\troot: &Node<K, M>,",
      "\t\t\tl: Bound<&K>,",
      "\t\t\tr: Bound<&K>,",
      "\t\t\tbegin: Bound<&K>,",
      "\t\t\tend: Bound<&K>,",
      "\t\t) -> M::Val {",
      "\t\t\tlet Some(T) = root else {",
      "\t\t\t\treturn M::E;",
      "\t\t\t};",
      "\t\t\t// 区間を含まない",
      "\t\t\tif has_no_intersection((l, r), (begin, end)) {",
      "\t\t\t\tM::E",
      "\t\t\t}",
      "\t\t\t// 区間を包含する",
      "\t\t\telse if includes((l, r), (begin, end)) {",
      "\t\t\t\tT.sum.clone()",
      "\t\t\t}",
      "\t\t\t// 区間が一部重なる",
      "\t\t\telse {",
      "\t\t\t\tlet mid = &T.key;",
      "\t\t\t\tlet l_val = get_range(&T.left, l, r, begin, Excluded(mid));",
      "\t\t\t\tlet m_val = if includes((l, r), (Included(mid), Included(mid))) {",
      "\t\t\t\t\tT.value.clone()",
      "\t\t\t\t} else {",
      "\t\t\t\t\tM::E",
      "\t\t\t\t};",
      "\t\t\t\tlet r_val = get_range(&T.right, l, r, Excluded(mid), end);",
      "\t\t\t\tM::op(&M::op(&l_val, &m_val), &r_val)",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 値 `key` に `value` を挿入する",
      "\t\t/// - 値がすでに存在する場合には更新し，もとの値を返す",
      "\t\tpub fn insert<K: Ord, M: Monoid>(",
      "\t\t\troot: Node<K, M>,",
      "\t\t\tkey: K,",
      "\t\t\tvalue: M::Val,",
      "\t\t) -> (Node<K, M>, Option<(K, M::Val)>) {",
      "\t\t\tlet Some(mut T) = root else {",
      "\t\t\t\treturn (NodeInner::new(key, value), None);",
      "\t\t\t};",
      "\t\t\t// 挿入",
      "\t\t\tlet old_key_value = match key.cmp(&T.key) {",
      "\t\t\t\tOrdering::Less => {",
      "\t\t\t\t\tlet (new_left, old_key_value) = insert(T.left, key, value);",
      "\t\t\t\t\tT.left = new_left;",
      "\t\t\t\t\told_key_value",
      "\t\t\t\t}",
      "\t\t\t\tOrdering::Greater => {",
      "\t\t\t\t\tlet (new_right, old_key_value) = insert(T.right, key, value);",
      "\t\t\t\t\tT.right = new_right;",
      "\t\t\t\t\told_key_value",
      "\t\t\t\t}",
      "\t\t\t\tOrdering::Equal => Some((",
      "\t\t\t\t\tmem::replace(&mut T.key, key),",
      "\t\t\t\t\tmem::replace(&mut T.value, value),",
      "\t\t\t\t)),",
      "\t\t\t};",
      "\t\t\t// ノードの評価",
      "\t\t\tT.eval();",
      "\t\t\t// 再平衡化",
      "\t\t\tlet mut root = Some(T);",
      "\t\t\troot = skew(root);",
      "\t\t\troot = split(root);",
      "\t\t\t(root, old_key_value)",
      "\t\t}",
      "\t\t/// 値 `key` をもつノードを削除し，削除されたノードを返す",
      "\t\t/// - `root`：削除する木の根",
      "\t\tpub fn delete<K: Ord, M: Monoid>(",
      "\t\t\troot: Node<K, M>,",
      "\t\t\tkey: &K,",
      "\t\t) -> (Node<K, M>, Option<(K, M::Val)>) {",
      "\t\t\tlet Some(mut T) = root else {",
      "\t\t\t\treturn (None, None);",
      "\t\t\t};",
      "\t\t\tlet (mut new_root, old_key_value) = match key.cmp(&T.key) {",
      "\t\t\t\tOrdering::Less => {",
      "\t\t\t\t\tlet (new_left, old_key_value) = delete(T.left, key);",
      "\t\t\t\t\tT.left = new_left;",
      "\t\t\t\t\t(Some(T), old_key_value)",
      "\t\t\t\t}",
      "\t\t\t\tOrdering::Greater => {",
      "\t\t\t\t\tlet (new_right, old_key_value) = delete(T.right, key);",
      "\t\t\t\t\tT.right = new_right;",
      "\t\t\t\t\t(Some(T), old_key_value)",
      "\t\t\t\t}",
      "\t\t\t\tOrdering::Equal => {",
      "\t\t\t\t\tif T.left.is_none() {",
      "\t\t\t\t\t\t(T.right, Some((T.key, T.value)))",
      "\t\t\t\t\t} else if T.right.is_none() {",
      "\t\t\t\t\t\t(T.left, Some((T.key, T.value)))",
      "\t\t\t\t\t} else {",
      "\t\t\t\t\t\t// 左右の子を持つ場合，左の子の最大値を現在のノードに代入",
      "\t\t\t\t\t\tlet (new_left, right_most) = delete_and_get_max(T.left.take());",
      "\t\t\t\t\t\tif let Some(L) = new_left {",
      "\t\t\t\t\t\t\tT.left.replace(L);",
      "\t\t\t\t\t\t}",
      "\t\t\t\t\t\tlet Some(right_most) = right_most else {",
      "\t\t\t\t\t\t\tunreachable!(\"T.left is not None\");",
      "\t\t\t\t\t\t};",
      "\t\t\t\t\t\tlet old_key_value = (",
      "\t\t\t\t\t\t\tmem::replace(&mut T.key, right_most.key),",
      "\t\t\t\t\t\t\tmem::replace(&mut T.value, right_most.value),",
      "\t\t\t\t\t\t);",
      "\t\t\t\t\t\t(Some(T), Some(old_key_value))",
      "\t\t\t\t\t}",
      "\t\t\t\t}",
      "\t\t\t};",
      "\t\t\t// 評価",
      "\t\t\tif let Some(T) = &mut new_root {",
      "\t\t\t\tT.eval();",
      "\t\t\t}",
      "\t\t\t// バランスの修正",
      "\t\t\tlet rebalanced = rebarance(new_root);",
      "\t\t\t(rebalanced, old_key_value)",
      "\t\t}",
      "\t\t/// 削除後の頂点を再平衡化",
      "\t\tfn rebarance<K: Ord, M: Monoid>(root: Node<K, M>) -> Node<K, M> {",
      "\t\t\tlet Some(mut T) = root else {",
      "\t\t\t\treturn None;",
      "\t\t\t};",
      "\t\t\tlet left_level = T.left.as_ref().map_or(0, |node| node.level);",
      "\t\t\tlet right_level = T.right.as_ref().map_or(0, |node| node.level);",
      "\t\t\tif left_level.min(right_level) < T.level - 1 {",
      "\t\t\t\tT.level -= 1;",
      "\t\t\t\t// 右が大きい場合，下げる",
      "\t\t\t\tif right_level > T.level {",
      "\t\t\t\t\tT.right.as_mut().unwrap().level = T.level;",
      "\t\t\t\t}",
      "\t\t\t\t// 同じレベルのノードをskew",
      "\t\t\t\tT = skew(Some(T)).unwrap();",
      "\t\t\t\tT.right = skew(T.right);",
      "\t\t\t\tif let Some(mut right) = T.right.take() {",
      "\t\t\t\t\tright.right = skew(right.right);",
      "\t\t\t\t\tT.right.replace(right);",
      "\t\t\t\t}",
      "\t\t\t\t// 同じレベルのノードをsplit",
      "\t\t\t\tT = split(Some(T)).unwrap();",
      "\t\t\t\tT.right = split(T.right);",
      "\t\t\t\t// ノードの再評価",
      "\t\t\t\tT.eval();",
      "\t\t\t}",
      "\t\t\tSome(T)",
      "\t\t}",
      "\t\t/// nodeを根とする木のうち，値が最大のものを削除する",
      "\t\t/// - 戻り値：(新しい根, 削除されたノード)",
      "\t\tfn delete_and_get_max<K: Ord, M: Monoid>(",
      "\t\t\troot: Node<K, M>,",
      "\t\t) -> (Node<K, M>, Option<NodeInner<K, M>>) {",
      "\t\t\tlet Some(mut T) = root else {",
      "\t\t\t\treturn (None, None);",
      "\t\t\t};",
      "\t\t\t// 右の子の取り出し",
      "\t\t\tlet (new_right, right_most) = delete_and_get_max(T.right.take());",
      "\t\t\tlet Some(right_most) = right_most else {",
      "\t\t\t\treturn (None, Some(*T));",
      "\t\t\t};",
      "\t\t\tif let Some(R) = new_right {",
      "\t\t\t\tT.right.replace(R);",
      "\t\t\t}",
      "\t\t\t// ノードを再評価",
      "\t\t\tT.eval();",
      "\t\t\tlet mut new_root = Some(T);",
      "\t\t\t// 削除したので，再平衡化",
      "\t\t\tnew_root = rebarance(new_root);",
      "\t\t\t(new_root, Some(right_most))",
      "\t\t}",
      "\t}",
      "\tmod print_util {",
      "\t\t//! 木を整形して表示するための関数",
      "\t\tuse super::{dynamic_segment_tree::DynamicSegmentTree, monoid::Monoid, node::Node};",
      "\t\tuse std::fmt::Debug;",
      "\t\tconst GREEN: &str = \"\\x1b[92m\";",
      "\t\tconst BLUE: &str = \"\\x1b[94m\";",
      "\t\tconst END: &str = \"\\x1b[0m\";",
      "\t\tconst LEFT: &str = \" ┌──\";",
      "\t\tconst MID: &str = \" │  \";",
      "\t\tconst RIGHT: &str = \" └──\";",
      "\t\tconst NULL: &str = \"\";",
      "\t\tconst BLANK: &str = \"\t\";",
      "\t\timpl<K: Ord + Debug, M: Monoid> DynamicSegmentTree<K, M> {",
      "\t\t\t/// 2分木として出力する",
      "\t\t\tpub fn print_as_binary_tree(&self) {",
      "\t\t\t\t#![cfg(debug_assertions)]",
      "\t\t\t\teprintln!(\"{BLUE}┌─ BinaryTree ──────────────────────{END}\");",
      "\t\t\t\tfmt_inner_binary_tree(&self.root, &mut vec![], NULL);",
      "\t\t\t\teprintln!(\"{BLUE}└───────────────────────────────────{END}\");",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// print recursive",
      "\t\tfn fmt_inner_binary_tree<K, M: Monoid>(",
      "\t\t\tnode: &Node<K, M>,",
      "\t\t\tfill: &mut Vec<&'static str>,",
      "\t\t\tlast: &'static str,",
      "\t\t) where",
      "\t\t\tK: Ord + Debug,",
      "\t\t\tM::Val: Debug,",
      "\t\t{",
      "\t\t\tif let Some(node) = node.as_ref() {",
      "\t\t\t\t// 表示の調整",
      "\t\t\t\tlet mut tmp = None;",
      "\t\t\t\tif fill.last().is_some_and(|x| x == &last) {",
      "\t\t\t\t\ttmp = fill.pop();",
      "\t\t\t\t\tfill.push(BLANK);",
      "\t\t\t\t} else if fill.last().is_some_and(|x| x != &NULL && x != &BLANK) {",
      "\t\t\t\t\ttmp = fill.pop();",
      "\t\t\t\t\tfill.push(MID);",
      "\t\t\t\t}",
      "\t\t\t\tfill.push(last);",
      "\t\t\t\t// 左の子",
      "\t\t\t\tfmt_inner_binary_tree(&node.left, fill, LEFT);",
      "\t\t\t\t// 自分を出力",
      "\t\t\t\teprintln!(",
      "\t\t\t\t\t\"{BLUE}│{END}{} {:?}\",",
      "\t\t\t\t\tfill.iter().fold(String::new(), |s, x| s + x),",
      "\t\t\t\t\tnode",
      "\t\t\t\t);",
      "\t\t\t\t// 右の子",
      "\t\t\t\tfmt_inner_binary_tree(&node.right, fill, RIGHT);",
      "\t\t\t\tfill.pop();",
      "\t\t\t\t// 戻す",
      "\t\t\t\tif let Some(tmp) = tmp {",
      "\t\t\t\t\tfill.pop();",
      "\t\t\t\t\tfill.push(tmp);",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "AA木による動的セグ木\n- 遅延評価なし"
  },
  "monoid.rs": {
    "prefix": "monoid",
    "body": [
      "mod monoid {",
      "\t#![allow(dead_code)]",
      "\t//! モノイド",
      "\tuse std::fmt::Debug;",
      "\t/// モノイド",
      "\tpub trait Monoid {",
      "\t\t/// 元の型",
      "\t\ttype Val: Debug + Clone + PartialEq;",
      "\t\t/// 単位元",
      "\t\tconst E: Self::Val;",
      "\t\t/// 演算",
      "\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val;",
      "\t}",
      "\t/// 各種モノイド",
      "\tpub mod examples {",
      "\t\tuse super::Monoid;",
      "\t\t/// 和",
      "\t\tpub struct Add;",
      "\t\timpl Monoid for Add {",
      "\t\t\ttype Val = isize;",
      "\t\t\tconst E: Self::Val = 0;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tleft + right",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 積",
      "\t\tpub struct Mul;",
      "\t\timpl Monoid for Mul {",
      "\t\t\ttype Val = isize;",
      "\t\t\tconst E: Self::Val = 1;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tleft * right",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// bit単位の排他的論理和",
      "\t\tpub struct Xor;",
      "\t\timpl Monoid for Xor {",
      "\t\t\ttype Val = usize;",
      "\t\t\tconst E: Self::Val = 0;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tleft ^ right",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 最小値",
      "\t\tpub struct Min;",
      "\t\timpl Monoid for Min {",
      "\t\t\ttype Val = isize;",
      "\t\t\tconst E: Self::Val = (1 << 31) - 1;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\t*left.min(right)",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 最大値",
      "\t\tpub struct Max;",
      "\t\timpl Monoid for Max {",
      "\t\t\ttype Val = isize;",
      "\t\t\tconst E: Self::Val = -((1 << 31) - 1);",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\t*left.max(right)",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 最小公倍数",
      "\t\tpub struct GCD;",
      "\t\timpl Monoid for GCD {",
      "\t\t\ttype Val = usize;",
      "\t\t\tconst E: Self::Val = 0;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tgcd(*left, *right)",
      "\t\t\t}",
      "\t\t}",
      "\t\tpub fn gcd(a: usize, b: usize) -> usize {",
      "\t\t\tif b == 0 {",
      "\t\t\t\ta",
      "\t\t\t} else {",
      "\t\t\t\tgcd(b, a % b)",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// アフィン変換（浮動小数点数）",
      "\t\tstruct Affine;",
      "\t\timpl Monoid for Affine {",
      "\t\t\ttype Val = (f64, f64);",
      "\t\t\tconst E: Self::Val = (1.0, 0.0);",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tlet &(a1, b1) = left;",
      "\t\t\t\tlet &(a2, b2) = right;",
      "\t\t\t\t(a2 * a1, a2 * b1 + b2)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "モノイド"
  },
  "factorize.rs": {
    "prefix": "factorize",
    "body": [
      "mod factorize {",
      "\t#![allow(dead_code)]",
      "\t//! 素因数分解",
      "\t/// 非負整数 `n` を素因数分解し、`(素因数,指数)`のペアを返す",
      "\t/// - 計算量：`O(√n)`",
      "\tpub fn factorize(mut n: usize) -> Vec<(usize, usize)> {",
      "\t\tlet mut res = Vec::new();",
      "\t\tfor i in 2.. {",
      "\t\t\tif i * i > n {",
      "\t\t\t\tbreak;",
      "\t\t\t}",
      "\t\t\tlet mut cnt = 0;",
      "\t\t\twhile n % i == 0 {",
      "\t\t\t\tn /= i;",
      "\t\t\t\tcnt += 1;",
      "\t\t\t}",
      "\t\t\tif cnt >= 1 {",
      "\t\t\t\tres.push((i, cnt));",
      "\t\t\t}",
      "\t\t}",
      "\t\tif n > 1 {",
      "\t\t\tres.push((n, 1));",
      "\t\t}",
      "\t\tres",
      "\t}",
      "}"
    ],
    "description": "素因数分解"
  },
  "dijkstra.rs": {
    "prefix": "dijkstra",
    "body": [
      "mod dijkstra {",
      "\t#![allow(dead_code)]",
      "\t//! ダイクストラ法",
      "\tuse std::cmp::Reverse;",
      "\tuse std::collections::BinaryHeap;",
      "\t/// Dijkstra法",
      "\t/// - グラフ`graph`が与えられたとき、スタート地点`s`から各頂点への最短路を求める",
      "\tpub fn dijkstra(graph: &Vec<Vec<(usize, usize)>>, s: usize) -> Vec<usize> {",
      "\t\tconst INF: usize = 1001001001001001001;",
      "\t\tlet n: usize = graph.len();",
      "\t\tlet mut dist: Vec<usize> = vec![INF; n];",
      "\t\tlet mut pq: BinaryHeap<Reverse<(usize, usize)>> = BinaryHeap::new();",
      "\t\t// 初期化",
      "\t\tdist[s] = 0;",
      "\t\tpq.push(Reverse((dist[s], s)));",
      "\t\t// 更新",
      "\t\twhile let Some(Reverse((cost, u))) = pq.pop() {",
      "\t\t\tif dist[u] < cost {",
      "\t\t\t\tcontinue;",
      "\t\t\t}",
      "\t\t\tfor &(v, weight) in &graph[u] {",
      "\t\t\t\tif dist[v] > dist[u] + weight {",
      "\t\t\t\t\tdist[v] = dist[u] + weight;",
      "\t\t\t\t\tpq.push(Reverse((dist[v], v)));",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t}",
      "\t\tdist",
      "\t}",
      "}"
    ],
    "description": "ダイクストラ法"
  },
  "trie.rs": {
    "prefix": "trie",
    "body": [
      "mod trie {",
      "\t#![allow(dead_code)]",
      "\t//! トライ木",
      "\tuse std::fmt::Debug;",
      "\t// 定数",
      "\tconst ORIGIN: char = 'a'; // 基準となる文字",
      "\tconst ORIGIN_ID: usize = ORIGIN as u32 as usize; // 基準となる文字のID",
      "\tconst KINDS: usize = 26; // 文字の種類数",
      "\ttype NodePointer<T> = Option<Box<TrieNode<T>>>;",
      "\t/// 何番目の文字かを判定する",
      "\tfn ord(c: char) -> usize {",
      "\t\tlet num = c as u32 as usize;",
      "\t\tnum - ORIGIN_ID",
      "\t}",
      "\t/// i番目の文字を返す",
      "\tfn chr(i: usize) -> char {",
      "\t\t(ORIGIN_ID + i) as u8 as char",
      "\t}",
      "\t/// # TrieNode",
      "\t/// - トライ木のノード",
      "\t#[derive(Debug, Clone)]",
      "\tstruct TrieNode<T> {",
      "\t\tdata: Option<T>,",
      "\t\tchildren: Vec<NodePointer<T>>,",
      "\t}",
      "\timpl<T> TrieNode<T>",
      "\twhere",
      "\t\tT: Clone,",
      "\t{",
      "\t\tpub fn new(data: Option<T>) -> Self {",
      "\t\t\tSelf {",
      "\t\t\t\tdata,",
      "\t\t\t\tchildren: vec![NodePointer::None; KINDS],",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\t/// # Trie",
      "\t/// - トライ木の実装",
      "\t#[derive(Debug)]",
      "\tpub struct Trie<T> {",
      "\t\troot: NodePointer<T>,",
      "\t}",
      "\timpl<T> Trie<T>",
      "\twhere",
      "\t\tT: Clone + Debug,",
      "\t{",
      "\t\t// self.originを基準にした文字の番号を返す",
      "\t\t// fn ord()",
      "\t\tpub fn new() -> Self {",
      "\t\t\tTrie {",
      "\t\t\t\troot: Some(Box::new(TrieNode {",
      "\t\t\t\t\tdata: None,",
      "\t\t\t\t\tchildren: vec![NodePointer::None; KINDS],",
      "\t\t\t\t})),",
      "\t\t\t}",
      "\t\t}",
      "\t\tpub fn insert(&mut self, key: &str, data: T) {",
      "\t\t\t*self.get_or_insert_mut(key) = Some(data);",
      "\t\t}",
      "\t\tpub fn get(&self, key: &str) -> Option<&T> {",
      "\t\t\tlet mut node = &self.root;",
      "\t\t\tfor c in key.chars().map(ord) {",
      "\t\t\t\tnode = &node.as_ref()?.children[c];",
      "\t\t\t}",
      "\t\t\tnode.as_deref()?.data.as_ref()",
      "\t\t}",
      "\t\tpub fn get_mut(&mut self, key: &str) -> Option<&mut T> {",
      "\t\t\tlet mut node = &mut self.root;",
      "\t\t\tfor c in key.chars().map(ord) {",
      "\t\t\t\tnode = node.as_mut()?.children.get_mut(c).unwrap();",
      "\t\t\t}",
      "\t\t\tnode.as_deref_mut()?.data.as_mut()",
      "\t\t}",
      "\t\tpub fn get_or_insert_mut(&mut self, key: &str) -> &mut Option<T> {",
      "\t\t\tlet mut node = &mut self.root;",
      "\t\t\tfor c in key.chars().map(ord).chain(KINDS..=KINDS) {",
      "\t\t\t\t// データの挿入",
      "\t\t\t\tif c == KINDS {",
      "\t\t\t\t\tif node.as_ref().is_none() {",
      "\t\t\t\t\t\t*node = Some(Box::new(TrieNode::new(None)));",
      "\t\t\t\t\t}",
      "\t\t\t\t\tbreak;",
      "\t\t\t\t}",
      "\t\t\t\tif node.as_ref().is_none() {",
      "\t\t\t\t\t*node = Some(Box::new(TrieNode::new(None)));",
      "\t\t\t\t}",
      "\t\t\t\tnode = node.as_mut().unwrap().children.get_mut(c).unwrap();",
      "\t\t\t}",
      "\t\t\t&mut node.as_deref_mut().unwrap().data",
      "\t\t}",
      "\t\tpub fn traverse(&self) -> Vec<(String, &T)> {",
      "\t\t\tlet mut res = vec![];",
      "\t\t\tlet mut cur = String::new();",
      "\t\t\ttraverse_inner(&self.root, &mut cur, &mut res);",
      "\t\t\tres",
      "\t\t}",
      "\t}",
      "\t/// trieを順に探索する",
      "\tfn traverse_inner<'a, T>(",
      "\t\tnode: &'a NodePointer<T>,",
      "\t\tcur: &mut String,",
      "\t\tlist: &mut Vec<(String, &'a T)>,",
      "\t) {",
      "\t\tif let Some(value) = node.as_ref().unwrap().data.as_ref() {",
      "\t\t\tlet key = cur.clone();",
      "\t\t\tlist.push((key, value));",
      "\t\t}",
      "\t\tif let Some(node) = node.as_deref() {",
      "\t\t\tfor (i, child) in node.children.iter().enumerate() {",
      "\t\t\t\tif child.as_ref().is_some() {",
      "\t\t\t\t\tcur.push(chr(i));",
      "\t\t\t\t\ttraverse_inner(child, cur, list);",
      "\t\t\t\t\tcur.pop();",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "トライ木"
  },
  "segment_tree.rs": {
    "prefix": "segment_tree",
    "body": [
      "mod monoid {",
      "\t#![allow(dead_code)]",
      "\t//! モノイド",
      "\tuse std::fmt::Debug;",
      "\t/// モノイド",
      "\tpub trait Monoid {",
      "\t\t/// 元の型",
      "\t\ttype Val: Debug + Clone + PartialEq;",
      "\t\t/// 単位元",
      "\t\tconst E: Self::Val;",
      "\t\t/// 演算",
      "\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val;",
      "\t}",
      "\t/// 各種モノイド",
      "\tpub mod examples {",
      "\t\tuse super::Monoid;",
      "\t\t/// 和",
      "\t\tpub struct Add;",
      "\t\timpl Monoid for Add {",
      "\t\t\ttype Val = isize;",
      "\t\t\tconst E: Self::Val = 0;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tleft + right",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 積",
      "\t\tpub struct Mul;",
      "\t\timpl Monoid for Mul {",
      "\t\t\ttype Val = isize;",
      "\t\t\tconst E: Self::Val = 1;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tleft * right",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// bit単位の排他的論理和",
      "\t\tpub struct Xor;",
      "\t\timpl Monoid for Xor {",
      "\t\t\ttype Val = usize;",
      "\t\t\tconst E: Self::Val = 0;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tleft ^ right",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 最小値",
      "\t\tpub struct Min;",
      "\t\timpl Monoid for Min {",
      "\t\t\ttype Val = isize;",
      "\t\t\tconst E: Self::Val = (1 << 31) - 1;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\t*left.min(right)",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 最大値",
      "\t\tpub struct Max;",
      "\t\timpl Monoid for Max {",
      "\t\t\ttype Val = isize;",
      "\t\t\tconst E: Self::Val = -((1 << 31) - 1);",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\t*left.max(right)",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 最小公倍数",
      "\t\tpub struct GCD;",
      "\t\timpl Monoid for GCD {",
      "\t\t\ttype Val = usize;",
      "\t\t\tconst E: Self::Val = 0;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tgcd(*left, *right)",
      "\t\t\t}",
      "\t\t}",
      "\t\tpub fn gcd(a: usize, b: usize) -> usize {",
      "\t\t\tif b == 0 {",
      "\t\t\t\ta",
      "\t\t\t} else {",
      "\t\t\t\tgcd(b, a % b)",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// アフィン変換（浮動小数点数）",
      "\t\tstruct Affine;",
      "\t\timpl Monoid for Affine {",
      "\t\t\ttype Val = (f64, f64);",
      "\t\t\tconst E: Self::Val = (1.0, 0.0);",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tlet &(a1, b1) = left;",
      "\t\t\t\tlet &(a2, b2) = right;",
      "\t\t\t\t(a2 * a1, a2 * b1 + b2)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "}",
      "",
      "mod segment_tree {",
      "\t#![allow(dead_code)]",
      "\t//! セグメント木",
      "\tuse crate::monoid::Monoid;",
      "\tuse std::fmt::{self, Debug};",
      "\tuse std::ops::{",
      "\t\tBound::{Excluded, Included, Unbounded},",
      "\t\tDeref, DerefMut, Index, RangeBounds,",
      "\t};",
      "\t/// # SegmentTree (Monoid)",
      "\t/// - 抽象化セグメント木",
      "\tpub struct SegmentTree<M: Monoid> {",
      "\t\tpub size: usize,",
      "\t\toffset: usize,",
      "\t\tdata: Vec<M::Val>,",
      "\t}",
      "\timpl<M: Monoid> Index<usize> for SegmentTree<M> {",
      "\t\ttype Output = M::Val;",
      "\t\tfn index(&self, idx: usize) -> &Self::Output {",
      "\t\t\t&self.data[self.offset + idx]",
      "\t\t}",
      "\t}",
      "\timpl<M: Monoid> SegmentTree<M> {",
      "\t\t#[inline]",
      "\t\tfn parse_range<R: RangeBounds<usize>>(&self, range: &R) -> Option<(usize, usize)> {",
      "\t\t\tlet start = match range.start_bound() {",
      "\t\t\t\tUnbounded => 0,",
      "\t\t\t\tExcluded(&v) => v + 1,",
      "\t\t\t\tIncluded(&v) => v,",
      "\t\t\t};",
      "\t\t\tlet end = match range.end_bound() {",
      "\t\t\t\tUnbounded => self.size,",
      "\t\t\t\tExcluded(&v) => v,",
      "\t\t\t\tIncluded(&v) => v + 1,",
      "\t\t\t};",
      "\t\t\tif start <= end && end <= self.size {",
      "\t\t\t\tSome((start, end))",
      "\t\t\t} else {",
      "\t\t\t\tNone",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// セグメント木を初期化する",
      "\t\tpub fn new(n: usize) -> Self {",
      "\t\t\tlet offset = n;",
      "\t\t\tSelf {",
      "\t\t\t\tsize: n,",
      "\t\t\t\toffset,",
      "\t\t\t\tdata: vec![M::E; offset << 1],",
      "\t\t\t}",
      "\t\t}",
      "\t\tpub fn update(&mut self, index: usize, value: M::Val) {",
      "\t\t\tlet mut i = index + self.offset;",
      "\t\t\tself.data[i] = value;",
      "\t\t\twhile i > 1 {",
      "\t\t\t\ti >>= 1;",
      "\t\t\t\tlet lch = i << 1;",
      "\t\t\t\tself.data[i] = M::op(&self.data[lch], &self.data[lch + 1]);",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 可変な参照を返す",
      "\t\tpub fn get_mut(&mut self, i: usize) -> Option<ValMut<'_, M>> {",
      "\t\t\tif i < self.offset {",
      "\t\t\t\tlet default = self.index(i).clone();",
      "\t\t\t\tSome(ValMut {",
      "\t\t\t\t\tsegtree: self,",
      "\t\t\t\t\tidx: i,",
      "\t\t\t\t\tnew_val: default,",
      "\t\t\t\t})",
      "\t\t\t} else {",
      "\t\t\t\tNone",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 区間`range`の集約を行う",
      "\t\tpub fn get_range<R: RangeBounds<usize> + Debug>(&self, range: R) -> M::Val {",
      "\t\t\tlet Some((start, end)) = self.parse_range(&range) else {",
      "\t\t\t\tpanic!(\"The given range is wrong: {:?}\", range);",
      "\t\t\t};",
      "\t\t\t// 値の取得",
      "\t\t\tlet mut l = self.offset + start;",
      "\t\t\tlet mut r = self.offset + end;",
      "\t\t\tlet (mut res_l, mut res_r) = (M::E, M::E);",
      "\t\t\twhile l < r {",
      "\t\t\t\tif l & 1 == 1 {",
      "\t\t\t\t\tres_l = M::op(&res_l, &self.data[l]);",
      "\t\t\t\t\tl += 1;",
      "\t\t\t\t}",
      "\t\t\t\tif r & 1 == 1 {",
      "\t\t\t\t\tr -= 1;",
      "\t\t\t\t\tres_r = M::op(&self.data[r], &res_r);",
      "\t\t\t\t}",
      "\t\t\t\tl >>= 1;",
      "\t\t\t\tr >>= 1;",
      "\t\t\t}",
      "\t\t\tM::op(&res_l, &res_r)",
      "\t\t}",
      "\t}",
      "\timpl<M: Monoid> From<&Vec<M::Val>> for SegmentTree<M> {",
      "\t\tfn from(src: &Vec<M::Val>) -> Self {",
      "\t\t\tlet mut seg = Self::new(src.len());",
      "\t\t\tfor (i, v) in src.iter().enumerate() {",
      "\t\t\t\tseg.data[seg.offset + i] = v.clone();",
      "\t\t\t}",
      "\t\t\tfor i in (0..seg.offset).rev() {",
      "\t\t\t\tlet lch = i << 1;",
      "\t\t\t\tseg.data[i] = M::op(&seg.data[lch], &seg.data[lch + 1]);",
      "\t\t\t}",
      "\t\t\tseg",
      "\t\t}",
      "\t}",
      "\timpl<M: Monoid> Debug for SegmentTree<M> {",
      "\t\tfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "\t\t\twrite!(f, \"SegmentTree {{ [\").ok();",
      "\t\t\tfor i in 0..self.size {",
      "\t\t\t\tif i + 1 < self.size {",
      "\t\t\t\t\twrite!(f, \"{:?}, \", self.data[self.offset + i]).ok();",
      "\t\t\t\t} else {",
      "\t\t\t\t\twrite!(f, \"{:?}\", self.data[self.offset + i]).ok();",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\twrite!(f, \"] }}\")",
      "\t\t}",
      "\t}",
      "\tpub struct ValMut<'a, M: 'a + Monoid> {",
      "\t\tsegtree: &'a mut SegmentTree<M>,",
      "\t\tidx: usize,",
      "\t\tnew_val: M::Val,",
      "\t}",
      "\timpl<M: Monoid> Debug for ValMut<'_, M> {",
      "\t\tfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "\t\t\tf.debug_tuple(\"ValMut\").field(&self.new_val).finish()",
      "\t\t}",
      "\t}",
      "\timpl<M: Monoid> Drop for ValMut<'_, M> {",
      "\t\tfn drop(&mut self) {",
      "\t\t\tself.segtree.update(self.idx, self.new_val.clone());",
      "\t\t}",
      "\t}",
      "\timpl<M: Monoid> Deref for ValMut<'_, M> {",
      "\t\ttype Target = M::Val;",
      "\t\tfn deref(&self) -> &Self::Target {",
      "\t\t\t&self.new_val",
      "\t\t}",
      "\t}",
      "\timpl<M: Monoid> DerefMut for ValMut<'_, M> {",
      "\t\tfn deref_mut(&mut self) -> &mut Self::Target {",
      "\t\t\t&mut self.new_val",
      "\t\t}",
      "\t}",
      "\timpl<M> SegmentTree<M>",
      "\twhere",
      "\t\tM: Monoid,",
      "\t\tM::Val: Debug,",
      "\t{",
      "\t\t/// セグ木を簡易的に表示する",
      "\t\t/// **サイズが2べきのときのみ**",
      "\t\tpub fn show(&self) {",
      "\t\t\t#![cfg(debug_assertions)]",
      "\t\t\tlet mut i = 1;",
      "\t\t\tlet mut w = 1;",
      "\t\t\twhile i + w <= 2 * self.offset {",
      "\t\t\t\teprintln!(\"{:?}\", &self.data[i..i + w]);",
      "\t\t\t\ti += w;",
      "\t\t\t\tw <<= 1;",
      "\t\t\t}",
      "\t\t\teprintln!();",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "セグメント木"
  },
  "lazy_segment_tree.rs": {
    "prefix": "lazy_segment_tree",
    "body": [
      "mod extmonoid {",
      "\t#![allow(dead_code)]",
      "\t//! 作用付きモノイド",
      "\t/// 作用付きモノイド",
      "\tpub trait ExtMonoid {",
      "\t\t/// 要素のデータ型",
      "\t\ttype X: Clone + PartialEq;",
      "\t\t/// 作用素のデータ型",
      "\t\ttype M: Clone + PartialEq;",
      "\t\t/// 要素Xの単位元",
      "\t\tconst IX: Self::X;",
      "\t\t/// 作用素Mの単位元",
      "\t\tconst IM: Self::M;",
      "\t\t/// 要素同士の演算",
      "\t\tfn operate_x(x: &Self::X, y: &Self::X) -> Self::X;",
      "\t\t/// 要素に対する作用",
      "\t\tfn apply(x: &Self::X, y: &Self::M) -> Self::X;",
      "\t\t/// 作用素同士の演算",
      "\t\tfn operate_m(x: &Self::M, y: &Self::M) -> Self::M;",
      "\t\t/// 作用素の集約",
      "\t\tfn aggregate(x: &Self::M, p: usize) -> Self::M;",
      "\t}",
      "\t/// （遅延セグ木）作用付きモノイド",
      "\tpub mod examples {",
      "\t\tuse super::ExtMonoid;",
      "\t\t/// ## RSQandRAQ",
      "\t\t/// - 区間加算",
      "\t\t/// - 区間和",
      "\t\t#[derive(Debug)]",
      "\t\tpub struct RSQandRAQ;",
      "\t\timpl ExtMonoid for RSQandRAQ {",
      "\t\t\ttype X = isize;",
      "\t\t\ttype M = isize;",
      "\t\t\tconst IX: Self::X = 0;",
      "\t\t\tconst IM: Self::M = 0;",
      "\t\t\tfn operate_x(x: &Self::X, y: &Self::X) -> Self::X {",
      "\t\t\t\tx + y",
      "\t\t\t}",
      "\t\t\tfn apply(x: &Self::X, y: &Self::M) -> Self::X {",
      "\t\t\t\tx + y",
      "\t\t\t}",
      "\t\t\tfn operate_m(x: &Self::M, y: &Self::M) -> Self::M {",
      "\t\t\t\tx + y",
      "\t\t\t}",
      "\t\t\tfn aggregate(x: &Self::M, p: usize) -> Self::M {",
      "\t\t\t\tx * p as isize",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// ## RMQandRUQ",
      "\t\t/// - 区間更新",
      "\t\t/// - 区間最小値",
      "\t\t#[derive(Debug)]",
      "\t\tpub struct RMQandRUQ;",
      "\t\timpl ExtMonoid for RMQandRUQ {",
      "\t\t\ttype X = isize;",
      "\t\t\ttype M = isize;",
      "\t\t\tconst IM: Self::M = (1 << 31) - 1;",
      "\t\t\tconst IX: Self::X = (1 << 31) - 1;",
      "\t\t\tfn operate_x(x: &Self::X, y: &Self::X) -> Self::X {",
      "\t\t\t\t*x.min(y)",
      "\t\t\t}",
      "\t\t\tfn apply(_x: &Self::X, y: &Self::M) -> Self::X {",
      "\t\t\t\t*y",
      "\t\t\t}",
      "\t\t\tfn operate_m(_x: &Self::M, y: &Self::M) -> Self::M {",
      "\t\t\t\t*y",
      "\t\t\t}",
      "\t\t\tfn aggregate(x: &Self::M, _p: usize) -> Self::M {",
      "\t\t\t\t*x",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// ## RMQandRAQ",
      "\t\t/// - 区間加算",
      "\t\t/// - 区間最小値",
      "\t\t#[derive(Debug)]",
      "\t\tpub struct RMQandRAQ;",
      "\t\timpl ExtMonoid for RMQandRAQ {",
      "\t\t\ttype X = isize;",
      "\t\t\ttype M = isize;",
      "\t\t\tconst IM: Self::M = 0;",
      "\t\t\tconst IX: Self::X = 1 << 31;",
      "\t\t\tfn operate_x(x: &Self::X, y: &Self::X) -> Self::X {",
      "\t\t\t\t*x.min(y)",
      "\t\t\t}",
      "\t\t\tfn apply(x: &Self::X, y: &Self::M) -> Self::X {",
      "\t\t\t\tx + y",
      "\t\t\t}",
      "\t\t\tfn operate_m(x: &Self::M, y: &Self::M) -> Self::M {",
      "\t\t\t\tx + y",
      "\t\t\t}",
      "\t\t\tfn aggregate(x: &Self::M, _p: usize) -> Self::M {",
      "\t\t\t\t*x",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// ## RSQandRUQ",
      "\t\t/// - 区間更新",
      "\t\t/// - 区間和取得",
      "\t\t#[derive(Debug)]",
      "\t\tpub struct RSQandRUQ;",
      "\t\timpl ExtMonoid for RSQandRUQ {",
      "\t\t\ttype X = isize;",
      "\t\t\ttype M = Option<isize>;",
      "\t\t\tconst IX: Self::X = 0;",
      "\t\t\tconst IM: Self::M = None;",
      "\t\t\tfn operate_x(x: &Self::X, y: &Self::X) -> Self::X {",
      "\t\t\t\tx + y",
      "\t\t\t}",
      "\t\t\tfn apply(_x: &Self::X, y: &Self::M) -> Self::X {",
      "\t\t\t\ty.unwrap()",
      "\t\t\t}",
      "\t\t\tfn operate_m(_x: &Self::M, y: &Self::M) -> Self::M {",
      "\t\t\t\t*y",
      "\t\t\t}",
      "\t\t\tfn aggregate(x: &Self::M, p: usize) -> Self::M {",
      "\t\t\t\tx.map(|x| x * p as isize)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "}",
      "",
      "mod lazy_segment_tree {",
      "\t#![allow(dead_code)]",
      "\t//! 遅延評価セグメント木",
      "\tuse crate::extmonoid::ExtMonoid;",
      "\tuse core::fmt;",
      "\tuse std::{",
      "\t\tfmt::Debug,",
      "\t\tops::{",
      "\t\t\tBound::{Excluded, Included, Unbounded},",
      "\t\t\tRangeBounds,",
      "\t\t},",
      "\t};",
      "\t/// 遅延評価セグメント木",
      "\t#[derive(Debug)]",
      "\tpub struct LazySegmentTree<M: ExtMonoid> {",
      "\t\tpub size: usize,",
      "\t\toffset: usize,",
      "\t\tdata: Vec<M::X>,",
      "\t\tlazy: Vec<M::M>,",
      "\t}",
      "\timpl<M: ExtMonoid> LazySegmentTree<M> {",
      "\t\t#[inline]",
      "\t\tfn parse_range<R: RangeBounds<usize>>(&self, range: &R) -> Option<(usize, usize)> {",
      "\t\t\tlet start = match range.start_bound() {",
      "\t\t\t\tUnbounded => 0,",
      "\t\t\t\tExcluded(&v) => v + 1,",
      "\t\t\t\tIncluded(&v) => v,",
      "\t\t\t};",
      "\t\t\tlet end = match range.end_bound() {",
      "\t\t\t\tUnbounded => self.size,",
      "\t\t\t\tExcluded(&v) => v,",
      "\t\t\t\tIncluded(&v) => v + 1,",
      "\t\t\t};",
      "\t\t\tif start <= end && end <= self.size {",
      "\t\t\t\tSome((start, end))",
      "\t\t\t} else {",
      "\t\t\t\tNone",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 遅延評価セグメント木を初期化する",
      "\t\t/// - `n`: 配列サイズ",
      "\t\tpub fn new(n: usize) -> Self {",
      "\t\t\tlet offset = n.next_power_of_two();",
      "\t\t\tSelf {",
      "\t\t\t\tsize: n,",
      "\t\t\t\toffset,",
      "\t\t\t\tdata: vec![M::IX; offset << 1],",
      "\t\t\t\tlazy: vec![M::IM; offset << 1],",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 遅延値を評価",
      "\t\tfn eval(&mut self, idx: usize, len: usize) {",
      "\t\t\tif self.lazy[idx] == M::IM {",
      "\t\t\t\treturn;",
      "\t\t\t}",
      "\t\t\t// 葉でなければ子に伝搬",
      "\t\t\tif idx < self.offset {",
      "\t\t\t\tself.lazy[idx * 2] = M::operate_m(&self.lazy[idx * 2], &self.lazy[idx]);",
      "\t\t\t\tself.lazy[idx * 2 + 1] = M::operate_m(&self.lazy[idx * 2 + 1], &self.lazy[idx]);",
      "\t\t\t}",
      "\t\t\t// 自身を更新",
      "\t\t\tself.data[idx] = M::apply(&self.data[idx], &M::aggregate(&self.lazy[idx], len));",
      "\t\t\tself.lazy[idx] = M::IM;",
      "\t\t}",
      "\t\t/// 区間に`val`を作用させる",
      "\t\t/// - `range`: `[left, right)`",
      "\t\tpub fn apply<R: RangeBounds<usize> + fmt::Debug>(&mut self, range: R, val: M::M) {",
      "\t\t\tlet Some((left, right)) = self.parse_range(&range) else {",
      "\t\t\t\tpanic!(\"The given range is wrong: {:?}\", range);",
      "\t\t\t};",
      "\t\t\tself.apply_inner(left, right, val, 0, self.offset, 1);",
      "\t\t}",
      "\t\tfn apply_inner(",
      "\t\t\t&mut self,",
      "\t\t\tleft: usize,",
      "\t\t\tright: usize,",
      "\t\t\tval: M::M,",
      "\t\t\tbegin: usize,",
      "\t\t\tend: usize,",
      "\t\t\tidx: usize,",
      "\t\t) {",
      "\t\t\t// 遅延値を評価",
      "\t\t\tself.eval(idx, end - begin);",
      "\t\t\t// 区間を内包するとき",
      "\t\t\tif left <= begin && end <= right {",
      "\t\t\t\tself.lazy[idx] = M::operate_m(&self.lazy[idx], &val);",
      "\t\t\t\tself.eval(idx, end - begin);",
      "\t\t\t}",
      "\t\t\t// 区間が重なるとき",
      "\t\t\telse if left < end && begin < right {",
      "\t\t\t\tlet mid = (begin + end) / 2;",
      "\t\t\t\t// 左の子を更新",
      "\t\t\t\tself.apply_inner(left, right, val.clone(), begin, mid, idx * 2);",
      "\t\t\t\t// 右の子を更新",
      "\t\t\t\tself.apply_inner(left, right, val, mid, end, idx * 2 + 1);",
      "\t\t\t\t// 値を更新",
      "\t\t\t\tself.data[idx] = M::operate_x(&self.data[idx * 2], &self.data[idx * 2 + 1]);",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 区間を取得する",
      "\t\t/// - `range`: `[left, right)`",
      "\t\tpub fn get<R: RangeBounds<usize> + fmt::Debug>(&mut self, range: R) -> M::X {",
      "\t\t\tlet Some((left, right)) = self.parse_range(&range) else {",
      "\t\t\t\tpanic!(\"The given range is wrong: {:?}\", range);",
      "\t\t\t};",
      "\t\t\tself.get_inner(left, right, 0, self.offset, 1)",
      "\t\t}",
      "\t\tfn get_inner(",
      "\t\t\t&mut self,",
      "\t\t\tleft: usize,",
      "\t\t\tright: usize,",
      "\t\t\tbegin: usize,",
      "\t\t\tend: usize,",
      "\t\t\tidx: usize,",
      "\t\t) -> M::X {",
      "\t\t\t// 遅延値を評価",
      "\t\t\tself.eval(idx, end - begin);",
      "\t\t\t// 区間を含まない",
      "\t\t\tif end <= left || right <= begin {",
      "\t\t\t\tM::IX",
      "\t\t\t}",
      "\t\t\t// 区間を包含する",
      "\t\t\telse if left <= begin && end <= right {",
      "\t\t\t\tself.data[idx].clone()",
      "\t\t\t}",
      "\t\t\t// 区間が重なる",
      "\t\t\telse {",
      "\t\t\t\tlet mid = (begin + end) / 2;",
      "\t\t\t\tlet l_val = self.get_inner(left, right, begin, mid, idx * 2);",
      "\t\t\t\tlet r_val = self.get_inner(left, right, mid, end, idx * 2 + 1);",
      "\t\t\t\tM::operate_x(&l_val, &r_val)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\timpl<M: ExtMonoid> From<&Vec<M::X>> for LazySegmentTree<M> {",
      "\t\tfn from(src: &Vec<M::X>) -> Self {",
      "\t\t\tlet mut seg = Self::new(src.len());",
      "\t\t\tfor (i, v) in src.iter().enumerate() {",
      "\t\t\t\tseg.data[seg.offset + i] = v.clone();",
      "\t\t\t}",
      "\t\t\tfor i in (0..seg.offset).rev() {",
      "\t\t\t\tlet lch = i << 1;",
      "\t\t\t\tseg.data[i] = M::operate_x(&seg.data[lch], &seg.data[lch + 1]);",
      "\t\t\t}",
      "\t\t\tseg",
      "\t\t}",
      "\t}",
      "\timpl<M> LazySegmentTree<M>",
      "\twhere",
      "\t\tM: ExtMonoid,",
      "\t\tM::M: Debug,",
      "\t\tM::X: Debug,",
      "\t{",
      "\t\tpub fn show(&mut self) -> String {",
      "\t\t\tlet mut res = \"LazySegmentTree {{ [\".to_string();",
      "\t\t\tfor i in 0..self.size {",
      "\t\t\t\tif i + 1 < self.size {",
      "\t\t\t\t\tres += &format!(\"{:?}, \", self.get(i..=i));",
      "\t\t\t\t} else {",
      "\t\t\t\t\tres += &format!(\"{:?}\", self.get(i..=i));",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\tres += \"] }}\";",
      "\t\t\tres",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "遅延評価セグメント木"
  },
  "bit_2d.rs": {
    "prefix": "bit_2d",
    "body": [
      "mod monoid {",
      "\t#![allow(dead_code)]",
      "\t//! モノイド",
      "\tuse std::fmt::Debug;",
      "\t/// モノイド",
      "\tpub trait Monoid {",
      "\t\t/// 元の型",
      "\t\ttype Val: Debug + Clone + PartialEq;",
      "\t\t/// 単位元",
      "\t\tconst E: Self::Val;",
      "\t\t/// 演算",
      "\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val;",
      "\t}",
      "\t/// 各種モノイド",
      "\tpub mod examples {",
      "\t\tuse super::Monoid;",
      "\t\t/// 和",
      "\t\tpub struct Add;",
      "\t\timpl Monoid for Add {",
      "\t\t\ttype Val = isize;",
      "\t\t\tconst E: Self::Val = 0;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tleft + right",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 積",
      "\t\tpub struct Mul;",
      "\t\timpl Monoid for Mul {",
      "\t\t\ttype Val = isize;",
      "\t\t\tconst E: Self::Val = 1;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tleft * right",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// bit単位の排他的論理和",
      "\t\tpub struct Xor;",
      "\t\timpl Monoid for Xor {",
      "\t\t\ttype Val = usize;",
      "\t\t\tconst E: Self::Val = 0;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tleft ^ right",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 最小値",
      "\t\tpub struct Min;",
      "\t\timpl Monoid for Min {",
      "\t\t\ttype Val = isize;",
      "\t\t\tconst E: Self::Val = (1 << 31) - 1;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\t*left.min(right)",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 最大値",
      "\t\tpub struct Max;",
      "\t\timpl Monoid for Max {",
      "\t\t\ttype Val = isize;",
      "\t\t\tconst E: Self::Val = -((1 << 31) - 1);",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\t*left.max(right)",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 最小公倍数",
      "\t\tpub struct GCD;",
      "\t\timpl Monoid for GCD {",
      "\t\t\ttype Val = usize;",
      "\t\t\tconst E: Self::Val = 0;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tgcd(*left, *right)",
      "\t\t\t}",
      "\t\t}",
      "\t\tpub fn gcd(a: usize, b: usize) -> usize {",
      "\t\t\tif b == 0 {",
      "\t\t\t\ta",
      "\t\t\t} else {",
      "\t\t\t\tgcd(b, a % b)",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// アフィン変換（浮動小数点数）",
      "\t\tstruct Affine;",
      "\t\timpl Monoid for Affine {",
      "\t\t\ttype Val = (f64, f64);",
      "\t\t\tconst E: Self::Val = (1.0, 0.0);",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tlet &(a1, b1) = left;",
      "\t\t\t\tlet &(a2, b2) = right;",
      "\t\t\t\t(a2 * a1, a2 * b1 + b2)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "}",
      "",
      "mod bit_2d {",
      "\t#![allow(dead_code)]",
      "\t//! 2次元BIT",
      "\t/// cfor! {}",
      "\tmacro_rules! cfor {",
      "\t\t(\\$def:stmt ; \\$fin:expr ; \\$incr:stmt ;; \\$bl:block) => {{",
      "\t\t\t\\$def",
      "\t\t\twhile \\$fin {",
      "\t\t\t\t\\$bl",
      "\t\t\t\t\\$incr",
      "\t\t\t}",
      "\t\t}}",
      "\t}",
      "\tuse crate::monoid::Monoid;",
      "\tpub struct BIT2D<M: Monoid> {",
      "\t\tpub H: usize,",
      "\t\tpub W: usize,",
      "\t\tpub data: Vec<Vec<M::Val>>,",
      "\t}",
      "\timpl<M: Monoid> BIT2D<M> {",
      "\t\t#[inline]",
      "\t\tfn lsb(x: usize) -> usize {",
      "\t\t\tx & x.wrapping_neg()",
      "\t\t}",
      "\t\t/// 2次元BITを作成する",
      "\t\tpub fn new(H: usize, W: usize) -> Self {",
      "\t\t\tSelf {",
      "\t\t\t\tH,",
      "\t\t\t\tW,",
      "\t\t\t\tdata: vec![vec![M::E; W + 1]; H + 1],",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 位置 (r,c) に値 `v` を加算する",
      "\t\t/// - `(r, c)`: 加算を行うインデックス（`0-indexed`）",
      "\t\t/// - `x`: 加算する値",
      "\t\tpub fn add(&mut self, mut r: usize, mut c: usize, v: M::Val) {",
      "\t\t\t// 0-indexedに修正",
      "\t\t\tr += 1;",
      "\t\t\tc += 1;",
      "\t\t\tcfor! {let mut i = r; i <= self.H; i += Self::lsb(i) ;; {",
      "\t\t\t\tcfor! {let mut j = c; j <= self.W; j += Self::lsb(j) ;; {",
      "\t\t\t\t\tself.data[i][j] = M::op(&self.data[i][j], &v);",
      "\t\t\t\t}}",
      "\t\t\t}}",
      "\t\t}",
      "\t\t/// 左上からの和を求める",
      "\t\t/// - `(r,c)`: 領域 `0<=i<r, 0<=j<c` に対しての総和（`0-indexed`）",
      "\t\tpub fn prefix_sum(&self, r: usize, c: usize) -> M::Val {",
      "\t\t\tlet mut res = M::E;",
      "\t\t\tcfor! {let mut i = r; i > 0; i -= Self::lsb(i) ;; {",
      "\t\t\t\tcfor! {let mut j = c; j > 0; j -= Self::lsb(j) ;; {",
      "\t\t\t\t\tres = M::op(&res, &self.data[i][j]);",
      "\t\t\t\t}}",
      "\t\t\t}}",
      "\t\t\tres",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "2次元BIT"
  },
  "modint_traits.rs": {
    "prefix": "modint_traits",
    "body": [
      "mod modint_traits {",
      "\t#![allow(dead_code)]",
      "\t//! Modintをusizeに注入するトレイト",
      "\t/// 有限体の実装",
      "\tpub trait Fp {",
      "\t\tfn val(&self) -> usize;",
      "\t\tfn madd(&self, other: usize) -> usize;",
      "\t\tfn mneg(&self) -> usize;",
      "\t\tfn msub(&self, other: usize) -> usize;",
      "\t\tfn mmul(&self, other: usize) -> usize;",
      "\t\tfn minv(&self) -> usize;",
      "\t\tfn mdiv(&self, other: usize) -> usize;",
      "\t\tfn mpow(&self, other: usize) -> usize;",
      "\t}",
      "\timpl Fp for usize {",
      "\t\tfn val(&self) -> usize {",
      "\t\t\tself % MOD",
      "\t\t}",
      "\t\tfn madd(&self, other: usize) -> usize {",
      "\t\t\t(self.val() + other.val()).val()",
      "\t\t}",
      "\t\tfn mneg(&self) -> usize {",
      "\t\t\t(MOD - self.val()).val()",
      "\t\t}",
      "\t\tfn msub(&self, other: usize) -> usize {",
      "\t\t\tself.madd(other.mneg())",
      "\t\t}",
      "\t\tfn mmul(&self, other: usize) -> usize {",
      "\t\t\t(self.val() * other.val()).val()",
      "\t\t}",
      "\t\tfn mpow(&self, other: usize) -> usize {",
      "\t\t\tlet (mut a, mut b) = (self.val(), other);",
      "\t\t\tlet mut res = 1;",
      "\t\t\twhile b > 0 {",
      "\t\t\t\tif b & 1 == 1 {",
      "\t\t\t\t\tres = res.mmul(a);",
      "\t\t\t\t}",
      "\t\t\t\ta = a.mmul(a);",
      "\t\t\t\tb >>= 1;",
      "\t\t\t}",
      "\t\t\tres",
      "\t\t}",
      "\t\tfn minv(&self) -> usize {",
      "\t\t\tassert!(*self != 0);",
      "\t\t\tself.mpow(MOD - 2)",
      "\t\t}",
      "\t\tfn mdiv(&self, other: usize) -> usize {",
      "\t\t\tself.mmul(other.minv())",
      "\t\t}",
      "\t}",
      "\tpub trait FpAssign {",
      "\t\tfn madd_assign(&mut self, other: usize);",
      "\t\tfn msub_assign(&mut self, other: usize);",
      "\t\tfn mmul_assign(&mut self, other: usize);",
      "\t}",
      "\timpl FpAssign for usize {",
      "\t\tfn madd_assign(&mut self, other: usize) {",
      "\t\t\t*self = self.madd(other);",
      "\t\t}",
      "\t\tfn mmul_assign(&mut self, other: usize) {",
      "\t\t\t*self = self.mmul(other);",
      "\t\t}",
      "\t\tfn msub_assign(&mut self, other: usize) {",
      "\t\t\t*self = self.msub(other);",
      "\t\t}",
      "\t}",
      "\tpub const MOD: usize = 998_244_353;",
      "\t// const MOD: usize = 1_000_000_007;",
      "}"
    ],
    "description": "Modintをusizeに注入するトレイト"
  },
  "tree_dp.rs": {
    "prefix": "tree_dp",
    "body": [
      "mod tree_dp {",
      "\t#![allow(dead_code)]",
      "\t//! 木DP",
      "\ttype Graph = Vec<Vec<usize>>;",
      "\t/// # Monoid",
      "\tpub trait Monoid {",
      "\t\ttype Val: Clone + PartialEq;",
      "\t\tconst E: Self::Val;",
      "\t\tfn op(u: &Self::Val, v: &Self::Val) -> Self::Val;",
      "\t\tfn apply(val: &Self::Val) -> Self::Val;",
      "\t}",
      "\t/// # 木DP",
      "\tstruct TreeDP<T: Monoid> {",
      "\t\tpub N: usize,",
      "\t\tpub G: Graph,",
      "\t\tdp: Vec<T::Val>,",
      "\t}",
      "\timpl<T: Monoid> TreeDP<T> {",
      "\t\t/// 頂点数`N`でグラフを初期化する",
      "\t\tpub fn new(N: usize) -> Self {",
      "\t\t\tSelf {",
      "\t\t\t\tN,",
      "\t\t\t\tG: vec![vec![]; N],",
      "\t\t\t\tdp: vec![T::E; N],",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 辺`u`-`v`を追加する",
      "\t\tpub fn add_edge(&mut self, u: usize, v: usize) {",
      "\t\t\tself.G[u].push(v);",
      "\t\t\tself.G[v].push(u);",
      "\t\t}",
      "\t\t/// 頂点`start`に値を集約する",
      "\t\tpub fn aggregate(&mut self, start: usize) -> T::Val {",
      "\t\t\tlet NEG1 = 1_usize.wrapping_neg();",
      "\t\t\tSelf::dfs(NEG1, start, &self.G, &mut self.dp);",
      "\t\t\tself.dp[start].clone()",
      "\t\t}",
      "\t\tfn dfs(p: usize, u: usize, G: &Graph, dp: &mut Vec<T::Val>) {",
      "\t\t\t// 葉であるときの処理",
      "\t\t\tif G[u].len() == 1 && G[u][0] == p {",
      "\t\t\t\tdp[u] = T::E;",
      "\t\t\t\treturn;",
      "\t\t\t}",
      "\t\t\t// 子要素を集約する",
      "\t\t\tlet mut acc = T::E; // 子要素の累積",
      "\t\t\tfor &v in &G[u] {",
      "\t\t\t\tif v == p {",
      "\t\t\t\t\tcontinue;",
      "\t\t\t\t}",
      "\t\t\t\tSelf::dfs(u, v, G, dp);",
      "\t\t\t\tacc = T::op(&acc, &dp[v]);",
      "\t\t\t}",
      "\t\t\tdp[u] = T::apply(&acc);",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "木DP"
  },
  "monoid_mod.rs": {
    "prefix": "monoid_mod",
    "body": [
      "mod modint {",
      "\t#![allow(dead_code)]",
      "\t//! Modintの構造体",
      "\tpub use modint::*;",
      "\tpub type M998 = Modint<998244353>;",
      "\tpub type M107 = Modint<1000000007>;",
      "\t// 適当な素数",
      "\tpub type P1 = Modint<938472061>;",
      "\tpub type P2 = Modint<958472071>;",
      "\t#[rustfmt::skip]",
      "\tpub mod modint {",
      "\t\tfn sqrt(n: usize) -> usize { (n as f64).sqrt() as usize }",
      "\t\tuse std::{fmt::{Debug, Display}, iter::{Sum, Product}, mem::replace, num::ParseIntError, ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign}, str::FromStr};",
      "\t\t#[derive(Clone, Copy, Default, PartialEq, Eq, Hash)] pub struct Modint<const MOD: usize>(pub usize);",
      "\t\timpl<const MOD: usize> Modint<MOD> { pub fn new(n: usize) -> Self { Self(if n < MOD { n } else { n % MOD }) }",
      "\t\tpub fn from_str(s: &str) -> Self { s.chars().fold(0.into(), |n, c| n * 10 + c.to_digit(10).unwrap() as usize) }",
      "\t\tpub fn from_isize(n: isize) -> Self { Self::new((MOD as isize + n % MOD as isize) as usize) }",
      "\t\tpub fn rational_reconstruction(&self) -> Option<(usize, usize)> { let N = sqrt(MOD / 2); let mut v = (MOD, 0); let mut w = (self.0, 1);",
      "\t\twhile w.0 > N { let q = v.0.div_euclid(w.0); let z = (v.0 - q * w.0, v.1 + q * w.1); v = replace(&mut w, z); } (w.0 <= N && w.1 <= N).then_some(w) } }",
      "\t\timpl<const MOD: usize> Neg for Modint<MOD> { type Output = Self; fn neg(self) -> Self { Modint(if self.0 == 0 { 0 } else { MOD - self.0 }) } }",
      "\t\timpl<const MOD: usize> Add for Modint<MOD> { type Output = Self; fn add(self, rhs: Self) -> Self { let mut res = self.0 + rhs.0; if res >= MOD { res -= MOD; } Modint(res) } }",
      "\t\timpl<const MOD: usize> Sub for Modint<MOD> { type Output = Self; fn sub(self, rhs: Self) -> Self { self + (- rhs) } }",
      "\t\timpl<const MOD: usize> Mul for Modint<MOD> { type Output = Self; fn mul(self, rhs: Self) -> Self { Modint(self.0 * rhs.0 % MOD) } }",
      "\t\timpl<const MOD: usize> Div for Modint<MOD> { type Output = Self; fn div(self, rhs: Self) -> Self { self * rhs.inv() } }",
      "\t\timpl<const MOD: usize> AddAssign for Modint<MOD> { fn add_assign(&mut self, rhs: Self) { self.0 = (*self + rhs).0 } }",
      "\t\timpl<const MOD: usize> SubAssign for Modint<MOD> { fn sub_assign(&mut self, rhs: Self) { self.0 = (*self - rhs).0 } }",
      "\t\timpl<const MOD: usize> MulAssign for Modint<MOD> { fn mul_assign(&mut self, rhs: Self) { self.0 = (*self * rhs).0 } }",
      "\t\timpl<const MOD: usize> DivAssign for Modint<MOD> { fn div_assign(&mut self, rhs: Self) { self.0 = (*self / rhs).0 } }",
      "\t\timpl<const MOD: usize> From<usize> for Modint<MOD> { fn from(value: usize) -> Self { Modint::new(value) } }",
      "\t\timpl<const MOD: usize> Add<usize> for Modint<MOD> { type Output = Self; fn add(self, rhs: usize) -> Self { let mut res = self.0 + rhs; if res >= MOD {res -= MOD;} Modint(res) } }",
      "\t\timpl<const MOD: usize> Sub<usize> for Modint<MOD> { type Output = Self; fn sub(self, rhs: usize) -> Self { self - Modint::new(rhs) } }",
      "\t\timpl<const MOD: usize> Mul<usize> for Modint<MOD> { type Output = Self; fn mul(self, rhs: usize) -> Self { self * Modint::new(rhs) } }",
      "\t\timpl<const MOD: usize> Div<usize> for Modint<MOD> { type Output = Self; fn div(self, rhs: usize) -> Self { self / Modint::new(rhs) } }",
      "\t\timpl<const MOD: usize> AddAssign<usize> for Modint<MOD> { fn add_assign(&mut self, rhs: usize) { *self += Modint::new(rhs) } }",
      "\t\timpl<const MOD: usize> SubAssign<usize> for Modint<MOD> { fn sub_assign(&mut self, rhs: usize) { *self -= Modint::new(rhs) } }",
      "\t\timpl<const MOD: usize> MulAssign<usize> for Modint<MOD> { fn mul_assign(&mut self, rhs: usize) { *self *= Modint::new(rhs) } }",
      "\t\timpl<const MOD: usize> DivAssign<usize> for Modint<MOD> { fn div_assign(&mut self, rhs: usize) { *self /= Modint::new(rhs) } }",
      "\t\timpl<const MOD: usize> Display for Modint<MOD> { fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, \"{}\", self.0) } }",
      "\t\timpl<const MOD: usize> PartialEq<usize> for Modint<MOD> { fn eq(&self, other: &usize) -> bool { self == &Modint::new(*other) } }",
      "\t\timpl<const MOD: usize> FromStr for Modint<MOD> { type Err = ParseIntError; fn from_str(s: &str) -> Result<Self, Self::Err> { Ok(Self::from_str(s)) } }",
      "\t\timpl<const MOD: usize> Debug for Modint<MOD> { fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { match self.rational_reconstruction() { Some((n, d)) => if d > 1 { write!(f, \"Modint({n}/{d})\") } else { write!(f, \"Modint({n})\") } _ => write!(f, \"Modint({})\", self.0) } } }",
      "\t\tpub trait Fp { fn pow(&self, rhs: usize) -> Self; fn inv(&self) -> Self; }",
      "\t\timpl<const MOD: usize> Fp for Modint<MOD> { fn pow(&self, rhs: usize) -> Self { let (mut a, mut b) = (self.0, rhs); let mut res = 1; while b > 0 { if b & 1 == 1 { res = (res * a) % MOD; } a = (a * a) % MOD; b >>= 1u32; } Modint(res) } fn inv(&self) -> Self { self.pow(MOD - 2) } }",
      "\t\timpl<const MOD: usize> Sum<Modint<MOD>> for Modint<MOD> { fn sum<I: Iterator<Item = Modint<MOD>>>(iter: I) -> Self { iter.fold(Modint::<MOD>(0), |acc, x| acc + x) } }",
      "\t\timpl<const MOD: usize> Product<Modint<MOD>> for Modint<MOD> { fn product<I: Iterator<Item = Modint<MOD>>>(iter: I) -> Self { iter.fold(Modint::<MOD>(1), |acc, x| acc * x) } }",
      "\t}",
      "}",
      "",
      "mod monoid {",
      "\t#![allow(dead_code)]",
      "\t//! モノイド",
      "\tuse std::fmt::Debug;",
      "\t/// モノイド",
      "\tpub trait Monoid {",
      "\t\t/// 元の型",
      "\t\ttype Val: Debug + Clone + PartialEq;",
      "\t\t/// 単位元",
      "\t\tconst E: Self::Val;",
      "\t\t/// 演算",
      "\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val;",
      "\t}",
      "\t/// 各種モノイド",
      "\tpub mod examples {",
      "\t\tuse super::Monoid;",
      "\t\t/// 和",
      "\t\tpub struct Add;",
      "\t\timpl Monoid for Add {",
      "\t\t\ttype Val = isize;",
      "\t\t\tconst E: Self::Val = 0;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tleft + right",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 積",
      "\t\tpub struct Mul;",
      "\t\timpl Monoid for Mul {",
      "\t\t\ttype Val = isize;",
      "\t\t\tconst E: Self::Val = 1;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tleft * right",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// bit単位の排他的論理和",
      "\t\tpub struct Xor;",
      "\t\timpl Monoid for Xor {",
      "\t\t\ttype Val = usize;",
      "\t\t\tconst E: Self::Val = 0;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tleft ^ right",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 最小値",
      "\t\tpub struct Min;",
      "\t\timpl Monoid for Min {",
      "\t\t\ttype Val = isize;",
      "\t\t\tconst E: Self::Val = (1 << 31) - 1;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\t*left.min(right)",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 最大値",
      "\t\tpub struct Max;",
      "\t\timpl Monoid for Max {",
      "\t\t\ttype Val = isize;",
      "\t\t\tconst E: Self::Val = -((1 << 31) - 1);",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\t*left.max(right)",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 最小公倍数",
      "\t\tpub struct GCD;",
      "\t\timpl Monoid for GCD {",
      "\t\t\ttype Val = usize;",
      "\t\t\tconst E: Self::Val = 0;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tgcd(*left, *right)",
      "\t\t\t}",
      "\t\t}",
      "\t\tpub fn gcd(a: usize, b: usize) -> usize {",
      "\t\t\tif b == 0 {",
      "\t\t\t\ta",
      "\t\t\t} else {",
      "\t\t\t\tgcd(b, a % b)",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// アフィン変換（浮動小数点数）",
      "\t\tstruct Affine;",
      "\t\timpl Monoid for Affine {",
      "\t\t\ttype Val = (f64, f64);",
      "\t\t\tconst E: Self::Val = (1.0, 0.0);",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tlet &(a1, b1) = left;",
      "\t\t\t\tlet &(a2, b2) = right;",
      "\t\t\t\t(a2 * a1, a2 * b1 + b2)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "}",
      "",
      "mod monoid_mod {",
      "\t#![allow(dead_code)]",
      "\t//! modを取るモノイド",
      "\tuse crate::modint::*;",
      "\tuse crate::monoid::Monoid;",
      "\t/// あまりをとる和",
      "\tpub struct ModAdd<const MOD: usize>;",
      "\timpl<const MOD: usize> Monoid for ModAdd<MOD> {",
      "\t\ttype Val = Modint<MOD>;",
      "\t\tconst E: Self::Val = Modint::<MOD>(0);",
      "\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t*left + *right",
      "\t\t}",
      "\t}",
      "\t/// あまりをとる積",
      "\tpub struct ModMul<const MOD: usize>;",
      "\timpl<const MOD: usize> Monoid for ModMul<MOD> {",
      "\t\ttype Val = Modint<MOD>;",
      "\t\tconst E: Self::Val = Modint::<MOD>(1);",
      "\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t*left * *right",
      "\t\t}",
      "\t}",
      "\t/// アフィン変換",
      "\tpub struct Affine<const MOD: usize>;",
      "\timpl<const MOD: usize> Monoid for Affine<MOD> {",
      "\t\ttype Val = (Modint<MOD>, Modint<MOD>);",
      "\t\tconst E: Self::Val = (Modint::<MOD>(1), Modint::<MOD>(0));",
      "\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\tlet &(a1, b1) = left;",
      "\t\t\tlet &(a2, b2) = right;",
      "\t\t\t(a2 * a1, a2 * b1 + b2)",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "modを取るモノイド"
  },
  "macro_get.rs": {
    "prefix": "macro_get",
    "body": [
      "mod macro_get {",
      "\t#![allow(dead_code)]",
      "\t//! 入力用マクロ",
      "\t//! - 参考：[Rustで競技プログラミング スターターキット](https://qiita.com/hatoo@github/items/fa14ad36a1b568d14f3e)",
      "\t/// 入力用マクロ",
      "\t#[macro_export]",
      "\tmacro_rules! get {",
      "\t\t(\\$t:ty) => {",
      "\t\t\t{",
      "\t\t\t\tlet mut line = String::new();",
      "\t\t\t\tstd::io::stdin().read_line(&mut line).unwrap();",
      "\t\t\t\tline.trim().parse::<\\$t>().unwrap()",
      "\t\t\t}",
      "\t\t};",
      "\t\t(\\$(\\$t:ty),*) => {",
      "\t\t\t{",
      "\t\t\t\tlet mut line = String::new();",
      "\t\t\t\tstd::io::stdin().read_line(&mut line).unwrap();",
      "\t\t\t\tlet mut iter = line.split_whitespace();",
      "\t\t\t\t(",
      "\t\t\t\t\t\\$(iter.next().unwrap().parse::<\\$t>().unwrap(),)*",
      "\t\t\t\t)",
      "\t\t\t}",
      "\t\t};",
      "\t\t(\\$t:ty ; \\$n:expr) => {",
      "\t\t\t(0..\\$n).map(|_|",
      "\t\t\t\tget_!(\\$t)",
      "\t\t\t).collect::<Vec<_>>()",
      "\t\t};",
      "\t\t(\\$(\\$t:ty),* ; \\$n:expr) => {",
      "\t\t\t(0..\\$n).map(|_|",
      "\t\t\t\tget_!(\\$(\\$t),*)",
      "\t\t\t).collect::<Vec<_>>()",
      "\t\t};",
      "\t\t(\\$t:ty ;;) => {",
      "\t\t\t{",
      "\t\t\t\tlet mut line = String::new();",
      "\t\t\t\tstd::io::stdin().read_line(&mut line).unwrap();",
      "\t\t\t\tline.split_whitespace()",
      "\t\t\t\t\t.map(|t| t.parse::<\\$t>().unwrap())",
      "\t\t\t\t\t.collect::<Vec<_>>()",
      "\t\t\t}",
      "\t\t};",
      "\t\t(\\$t:ty ;; \\$n:expr) => {",
      "\t\t\t(0..\\$n).map(|_|",
      "\t\t\t\tget_!(\\$t ;;)",
      "\t\t\t).collect::<Vec<_>>()",
      "\t\t};",
      "\t}",
      "}"
    ],
    "description": "入力用マクロ\n- 参考：[Rustで競技プログラミング スターターキット](https://qiita.com/hatoo@github/items/fa14ad36a1b568d14f3e)"
  },
  "namori.rs": {
    "prefix": "namori",
    "body": [
      "mod namori {",
      "\t#![allow(dead_code)]",
      "\t//! なもりグラフの分解",
      "\tuse std::collections::VecDeque;",
      "\tpub type Graph = Vec<Vec<usize>>;",
      "\t/// # なもりグラフ",
      "\t/// - なもりグラフ（木に辺を1本加えたグラフ）を分解する",
      "\t#[derive(Debug)]",
      "\tpub struct Namori {",
      "\t\tpub N: usize,",
      "\t\tpub graph: Graph,",
      "\t\tpub forest: Graph,",
      "\t\tpub on_cycle: Vec<bool>,",
      "\t}",
      "\timpl Namori {",
      "\t\t/// 頂点数`N`のグラフを作成する",
      "\t\tpub fn new(N: usize) -> Self {",
      "\t\t\tSelf {",
      "\t\t\t\tN,",
      "\t\t\t\tgraph: vec![vec![]; N],",
      "\t\t\t\tforest: vec![vec![]; N],",
      "\t\t\t\ton_cycle: vec![true; N],",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 頂点`u`,`v`に辺を張る",
      "\t\tpub fn add_edge(&mut self, u: usize, v: usize) {",
      "\t\t\tself.graph[u].push(v);",
      "\t\t\tself.graph[v].push(u);",
      "\t\t}",
      "\t\t/// なもりグラフを分解し、",
      "\t\t/// - サイクルを取り除いた森",
      "\t\t/// - サイクル上の頂点",
      "\t\t///",
      "\t\t/// を求める",
      "\t\tpub fn decompose(&mut self) {",
      "\t\t\t// 葉を調べる",
      "\t\t\tlet mut degree = vec![0; self.N];",
      "\t\t\tlet mut leafs = VecDeque::new();",
      "\t\t\tlet mut visited = vec![false; self.N];",
      "\t\t\tfor i in 0..self.N {",
      "\t\t\t\tdegree[i] = self.graph[i].len(); // 次数を調べる",
      "\t\t\t\t\t\t\t\t\t\t\t\t // 次数が1の頂点を格納",
      "\t\t\t\tif degree[i] == 1 {",
      "\t\t\t\t\tleafs.push_back(i);",
      "\t\t\t\t\tvisited[i] = true;",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\t// 葉を辿って木に分解",
      "\t\t\twhile let Some(u) = leafs.pop_front() {",
      "\t\t\t\tself.on_cycle[u] = false;",
      "\t\t\t\tfor &v in &self.graph[u] {",
      "\t\t\t\t\tif visited[v] {",
      "\t\t\t\t\t\tcontinue;",
      "\t\t\t\t\t}",
      "\t\t\t\t\tdegree[v] -= 1;",
      "\t\t\t\t\t// 森に追加",
      "\t\t\t\t\tself.forest[u].push(v);",
      "\t\t\t\t\tself.forest[v].push(u);",
      "\t\t\t\t\tif degree[v] <= 1 {",
      "\t\t\t\t\t\tleafs.push_back(v);",
      "\t\t\t\t\t\tvisited[v] = true;",
      "\t\t\t\t\t}",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "なもりグラフの分解"
  },
  "vec2.rs": {
    "prefix": "vec2",
    "body": [
      "mod vec2 {",
      "\t#![allow(dead_code)]",
      "\t//! 幾何ライブラリ",
      "\tuse std::ops::{Add, Mul, Neg, Sub};",
      "\tpub type Pos<T> = (T, T);",
      "\tpub type Line<T> = (Pos<T>, Pos<T>);",
      "\t/// ベクトル演算を行う",
      "\tpub trait Vec2<T> {",
      "\t\tfn mul(&self, scalar: T) -> Self;",
      "\t\tfn add(&self, other: Self) -> Self;",
      "\t\tfn sub(&self, other: Self) -> Self;",
      "\t\t/// ドット積",
      "\t\tfn dot(&self, other: Self) -> T;",
      "\t\t/// クロス積",
      "\t\tfn cross(&self, other: Self) -> T;",
      "\t\t/// L2-ノルム（の2乗）",
      "\t\tfn dist2(&self, other: Self) -> T;",
      "\t}",
      "\timpl<T> Vec2<T> for Pos<T>",
      "\twhere",
      "\t\tT: Copy + Add<Output = T> + Sub<Output = T> + Mul<Output = T> + Neg,",
      "\t{",
      "\t\tfn mul(&self, scalar: T) -> Self {",
      "\t\t\t(self.0 * scalar, self.1 * scalar)",
      "\t\t}",
      "\t\tfn add(&self, other: Self) -> Self {",
      "\t\t\t(self.0 + other.0, self.1 + other.1)",
      "\t\t}",
      "\t\tfn sub(&self, other: Self) -> Self {",
      "\t\t\t(self.0 - other.0, self.1 - other.1)",
      "\t\t}",
      "\t\tfn dot(&self, other: Self) -> T {",
      "\t\t\tself.0 * other.0 + self.1 * other.1",
      "\t\t}",
      "\t\tfn cross(&self, other: Self) -> T {",
      "\t\t\t(self.0 * other.1) - (other.0 * self.1)",
      "\t\t}",
      "\t\tfn dist2(&self, other: Self) -> T {",
      "\t\t\t(self.0 - other.0) * (self.0 - other.0) + (self.1 - other.1) * (self.1 - other.1)",
      "\t\t}",
      "\t}",
      "\t/// 線分abと線分xyが衝突しているかどうか",
      "\tpub fn is_collided(ab: Line<isize>, xy: Line<isize>) -> bool {",
      "\t\tlet (a, b) = ab;",
      "\t\tlet (x, y) = xy;",
      "\t\t// Aから見たとき",
      "\t\tlet AX = x.sub(a);",
      "\t\tlet AY = y.sub(a);",
      "\t\tlet AB = b.sub(a);",
      "\t\t// Xから見たとき",
      "\t\tlet XA = a.sub(x);",
      "\t\tlet XB = b.sub(x);",
      "\t\tlet XY = y.sub(x);",
      "\t\tAB.cross(AX) * AB.cross(AY) < 0 && XY.cross(XA) * XY.cross(XB) < 0",
      "\t}",
      "}"
    ],
    "description": "幾何ライブラリ"
  },
  "rolling_hash.rs": {
    "prefix": "rolling_hash",
    "body": [
      "mod modint_for_rollinghash {",
      "\t#![allow(dead_code)]",
      "\t//! Modintの構造体",
      "\t#[rustfmt::skip]",
      "\tpub mod modint {",
      "\t\tpub const MOD: usize = (1 << 61) - 1;",
      "\t\tconst MASK30: usize = (1 << 30) - 1;",
      "\t\tconst MASK31: usize = (1 << 31) - 1;",
      "\t\tconst MASK61: usize = MOD;",
      "\t\tfn mul(a: usize, b: usize) -> usize { let (au, ad) = (a >> 31, a & MASK31); let (bu, bd) = (b >> 31, b & MASK31); let m = ad * bu + au * bd; let (mu, md) = (m >> 30, m & MASK30); calcmod(au * bu * 2 + mu + (md << 31) + ad * bd) }",
      "\t\tfn calcmod(x: usize) -> usize { let xu = x >> 61; let xd = x & MASK61; let res = xu + xd; if res >= MOD { res - MOD } else { res } }",
      "\t\tuse std::{fmt::Display,ops::{Add, AddAssign, Div, Mul, MulAssign, Neg, Sub, SubAssign}, str::FromStr, num::ParseIntError, iter::{Sum, Product}};",
      "\t\t#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)] pub struct Modint(pub usize);",
      "\t\timpl Modint { pub fn new(n: usize) -> Self { Self(calcmod(n)) } }",
      "\t\timpl Neg for Modint { type Output = Self; fn neg(self) -> Self { Modint(if self.0 == 0 { 0 } else { MOD - self.0 }) } }",
      "\t\timpl Add for Modint { type Output = Self; fn add(self, rhs: Self) -> Self { let mut res = self.0 + rhs.0; if res >= MOD { res -= MOD; } Modint(res) } }",
      "\t\timpl Sub for Modint { type Output = Self; fn sub(self, rhs: Self) -> Self { self + (- rhs) } }",
      "\t\timpl Mul for Modint { type Output = Self; fn mul(self, rhs: Self) -> Self { Modint(mul(self.0, rhs.0)) } }",
      "\t\timpl Div for Modint { type Output = Self; fn div(self, rhs: Self) -> Self { self * rhs.inv() } }",
      "\t\timpl AddAssign for Modint { fn add_assign(&mut self, rhs: Self) { self.0 = (*self + rhs).0 } }",
      "\t\timpl SubAssign for Modint { fn sub_assign(&mut self, rhs: Self) { self.0 = (*self - rhs).0 } }",
      "\t\timpl MulAssign for Modint { fn mul_assign(&mut self, rhs: Self) { self.0 = (*self * rhs).0 } }",
      "\t\timpl From<usize> for Modint { fn from(value: usize) -> Self { Modint::new(value) } }",
      "\t\timpl Add<usize> for Modint { type Output = Self; fn add(self, rhs: usize) -> Self { let mut res = self.0 + rhs; if res >= MOD {res -= MOD;} Modint(res) } }",
      "\t\timpl Sub<usize> for Modint { type Output = Self; fn sub(self, rhs: usize) -> Self { self - Modint::new(rhs) } }",
      "\t\timpl Mul<usize> for Modint { type Output = Self; fn mul(self, rhs: usize) -> Self { self * Modint::new(rhs) } }",
      "\t\timpl Div<usize> for Modint { type Output = Self; fn div(self, rhs: usize) -> Self { self / Modint::new(rhs) } }",
      "\t\timpl AddAssign<usize> for Modint { fn add_assign(&mut self, rhs: usize) { *self += Modint::new(rhs) } }",
      "\t\timpl SubAssign<usize> for Modint { fn sub_assign(&mut self, rhs: usize) { *self -= Modint::new(rhs) } }",
      "\t\timpl MulAssign<usize> for Modint { fn mul_assign(&mut self, rhs: usize) { *self *= Modint::new(rhs) } }",
      "\t\timpl Display for Modint { fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, \"{}\", self.0) } }",
      "\t\timpl PartialEq<usize> for Modint { fn eq(&self, other: &usize) -> bool { self == &Modint::new(*other) } }",
      "\t\timpl FromStr for Modint { type Err = ParseIntError; fn from_str(s: &str) -> Result<Self, Self::Err> { usize::from_str(s).map(Modint::new) } }",
      "\t\tpub trait Fp { fn pow(&self, rhs: usize) -> Self; fn inv(&self) -> Self; }",
      "\t\timpl Fp for Modint { fn pow(&self, rhs: usize) -> Self { let (mut a, mut b) = (self.0, rhs); let mut res = 1; while b > 0 { if b & 1 == 1 { res = mul(res, a); } a = mul(a, a); b >>= 1u32; } Modint(res) } fn inv(&self) -> Self { self.pow(MOD - 2) } }",
      "\t\timpl Sum<Modint> for Modint { fn sum<I: Iterator<Item = Modint>>(iter: I) -> Self { iter.fold(Modint(0), |acc, x| acc + x) } }",
      "\t\timpl Product<Modint> for Modint { fn product<I: Iterator<Item = Modint>>(iter: I) -> Self { iter.fold(Modint(1), |acc, x| acc * x) } }",
      "\t}",
      "\tpub use modint::*;",
      "}",
      "",
      "mod rolling_hash {",
      "\t#![allow(dead_code)]",
      "\t//! ローリングハッシュ",
      "\tuse crate::modint_for_rollinghash::modint::Modint;",
      "\t/// # RollingHash",
      "\t/// 文字列の比較を高速に行う",
      "\t/// - 計算量: `O(n+m)`",
      "\t#[derive(Debug)]",
      "\tpub struct RollingHash {",
      "\t\tpub size: usize,",
      "\t\tpower: Vec<Modint>,",
      "\t\thash: Vec<Modint>,",
      "\t\tbase: Modint,",
      "\t}",
      "\timpl RollingHash {",
      "\t\t/// 初期化",
      "\t\tpub fn build(arr: &[Modint], base: usize) -> Self {",
      "\t\t\tlet size = arr.len();",
      "\t\t\tlet mut power = vec![Modint(0); size + 1];",
      "\t\t\tlet mut hash = vec![Modint(0); size + 1];",
      "\t\t\t// hashを初期化",
      "\t\t\tlet (mut h, mut p) = (Modint(0), Modint(1));",
      "\t\t\tfor i in 0..size {",
      "\t\t\t\th = arr[i] + (h * base);",
      "\t\t\t\tp *= base;",
      "\t\t\t\thash[i + 1] = h.into();",
      "\t\t\t\tpower[i + 1] = p.into();",
      "\t\t\t}",
      "\t\t\tSelf {",
      "\t\t\t\tsize,",
      "\t\t\t\tpower,",
      "\t\t\t\thash,",
      "\t\t\t\tbase: base.into(),",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 文字列から生成",
      "\t\tpub fn from_str(s: &str, base: usize) -> Self {",
      "\t\t\tlet arr: Vec<Modint> = s.chars().map(Self::ord).map(Modint).collect();",
      "\t\t\tSelf::build(&arr, base)",
      "\t\t}",
      "\t\t/// `l..r`のハッシュを取得",
      "\t\t/// - 計算量: `O(1)`",
      "\t\tpub fn get(&self, l: usize, r: usize) -> Modint {",
      "\t\t\tself.hash[r] - self.hash[l] * self.power[r - l]",
      "\t\t}",
      "\t\t/// `0..size`のハッシュを取得",
      "\t\t/// - 計算量: `O(1)`",
      "\t\tpub fn full(&self) -> Modint {",
      "\t\t\tself.hash[self.size]",
      "\t\t}",
      "\t\t/// a,bからの最長共通接頭辞の長さを調べる",
      "\t\t/// - 計算量: `O(log N)`",
      "\t\tpub fn getLCP(&self, a: usize, b: usize) -> usize {",
      "\t\t\tlet len = self.size.saturating_sub(a.max(b));",
      "\t\t\tlet (mut lo, mut hi) = (0, len + 1);",
      "\t\t\twhile hi - lo > 1 {",
      "\t\t\t\tlet mid = (lo + hi) / 2;",
      "\t\t\t\tif self.get(a, a + mid) == self.get(b, b + mid) {",
      "\t\t\t\t\tlo = mid;",
      "\t\t\t\t} else {",
      "\t\t\t\t\thi = mid;",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\tlo",
      "\t\t}",
      "\t\t/// ハッシュ同士を連結",
      "\t\t/// - 計算量: `O(1)`",
      "\t\tpub fn concat(&self, h1: Modint, h2: Modint, h2_len: usize) -> Modint {",
      "\t\t\th1 * self.power[h2_len] + h2",
      "\t\t}",
      "\t\t/// `A`を`0`とするascii文字(`A~Za~z`)のインデックスを返す",
      "\t\t#[inline]",
      "\t\tfn ord(c: char) -> usize {",
      "\t\t\tlet a = 'A' as u32;",
      "\t\t\tlet c = c as u32;",
      "\t\t\t(c - a) as usize",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "ローリングハッシュ"
  },
  "loop_detection_fold.rs": {
    "prefix": "loop_detection_fold",
    "body": [
      "mod loop_detection_fold {",
      "\t#![allow(dead_code)]",
      "\t//! ループ検出（fold関数版）",
      "\tuse num_bigint::BigUint;",
      "\tuse num_traits::{FromPrimitive, ToPrimitive, Zero};",
      "\tuse std::ops::{Add, Mul, Sub};",
      "\tuse std::{collections::HashMap, hash::Hash};",
      "\tpub struct Loop<T, V, F, G>",
      "\twhere",
      "\t\tF: Fn(T) -> T,",
      "\t\tG: Fn(V, T) -> V,",
      "\t{",
      "\t\t/// ノードの移動を行う関数",
      "\t\tpub next: F,",
      "\t\t/// 値を更新する関数",
      "\t\tpub fold: G,",
      "\t\t/// 始点となるノード",
      "\t\tpub begin: T,",
      "\t\t/// ループの長さ",
      "\t\tpub loop_len: usize,",
      "\t\t/// ループ開始時の値",
      "\t\tpub loop_begin: T,",
      "\t\t/// ループに到達するまでの移動回数",
      "\t\tpub loop_begin_idx: usize,",
      "\t\t/// ループ開始時までの累積",
      "\t\tpub before_loop_sum: V,",
      "\t\t/// ループ内での累積",
      "\t\tpub loop_sum: V,",
      "\t\t/// ループの途中の値",
      "\t\tvals: HashMap<T, (usize, V)>,",
      "\t}",
      "\timpl<T, V, F, G> Loop<T, V, F, G>",
      "\twhere",
      "\t\tT: Copy + Hash + Eq,",
      "\t\tV: Copy + Zero + Add<Output = V> + Sub<Output = V> + Mul<usize, Output = V>,",
      "\t\tF: Fn(T) -> T,",
      "\t\tG: Fn(V, T) -> V,",
      "\t{",
      "\t\t/// ループを検出する",
      "\t\tpub fn build(begin: T, next: F, fold: G) -> Self {",
      "\t\t\t// 初期化",
      "\t\t\tlet mut cur: T = begin;",
      "\t\t\tlet mut idx: usize = 0;",
      "\t\t\tlet mut sum: V = V::zero();",
      "\t\t\tlet mut vals: HashMap<T, (usize, V)> = HashMap::new();",
      "\t\t\t// ループ検出",
      "\t\t\twhile vals.get(&cur).is_none() {",
      "\t\t\t\tvals.insert(cur, (idx, sum));",
      "\t\t\t\tsum = fold(sum, cur);",
      "\t\t\t\tcur = next(cur);",
      "\t\t\t\tidx += 1;",
      "\t\t\t}",
      "\t\t\t// ループの値を取り出す",
      "\t\t\tlet loop_begin = cur;",
      "\t\t\tlet (loop_begin_idx, before_loop_sum) = vals[&loop_begin];",
      "\t\t\tlet loop_len = idx - loop_begin_idx;",
      "\t\t\tlet loop_sum = sum - before_loop_sum;",
      "\t\t\t// 返す",
      "\t\t\tSelf {",
      "\t\t\t\tnext,",
      "\t\t\t\tfold,",
      "\t\t\t\tbegin,",
      "\t\t\t\tloop_len,",
      "\t\t\t\tloop_begin,",
      "\t\t\t\tloop_begin_idx,",
      "\t\t\t\tbefore_loop_sum,",
      "\t\t\t\tloop_sum,",
      "\t\t\t\tvals,",
      "\t\t\t}",
      "\t\t}",
      "\t\tfn accumulate(&self, begin: T, n: usize) -> (T, V) {",
      "\t\t\tlet mut res = V::zero();",
      "\t\t\tlet mut cur = begin;",
      "\t\t\tfor _ in 0..n {",
      "\t\t\t\tres = (self.fold)(res, cur);",
      "\t\t\t\tcur = (self.next)(cur);",
      "\t\t\t}",
      "\t\t\t(cur, res)",
      "\t\t}",
      "\t\t/// self.beginからn個後の頂点を取り出す",
      "\t\tpub fn get_nth_node_usize(&self, n: usize) -> T {",
      "\t\t\tif n < self.loop_begin_idx {",
      "\t\t\t\tself.accumulate(self.begin, n).0",
      "\t\t\t} else {",
      "\t\t\t\tlet loop_rem = (n - self.loop_begin_idx) % self.loop_len;",
      "\t\t\t\tself.accumulate(self.loop_begin, loop_rem).0",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// self.beginからn個後の値を取り出す",
      "\t\tpub fn get_nth_val_usize(&self, n: usize) -> V {",
      "\t\t\tif n < self.loop_begin_idx {",
      "\t\t\t\tself.accumulate(self.begin, n).1",
      "\t\t\t} else {",
      "\t\t\t\tlet loop_rep = (n - self.loop_begin_idx) / self.loop_len;",
      "\t\t\t\tlet loop_rem = (n - self.loop_begin_idx) % self.loop_len;",
      "\t\t\t\tself.before_loop_sum",
      "\t\t\t\t\t+ self.loop_sum * loop_rep",
      "\t\t\t\t\t+ self.accumulate(self.loop_begin, loop_rem).1",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// self.beginからn個後の値を取り出す",
      "\t\tpub fn get_nth_node_biguint(&self, n: BigUint) -> T {",
      "\t\t\tlet loop_begin_idx = BigUint::from_usize(self.loop_begin_idx).unwrap();",
      "\t\t\tif n < loop_begin_idx {",
      "\t\t\t\tlet n_usize = n.to_usize().unwrap();",
      "\t\t\t\tself.accumulate(self.begin, n_usize).0",
      "\t\t\t} else {",
      "\t\t\t\tlet loop_len = BigUint::from_usize(self.loop_len).unwrap();",
      "\t\t\t\tlet loop_rem = (n - loop_begin_idx) % loop_len;",
      "\t\t\t\tlet loop_rem = loop_rem.to_usize().unwrap();",
      "\t\t\t\tself.accumulate(self.loop_begin, loop_rem).0",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "ループ検出（fold関数版）"
  },
  "indexedset.rs": {
    "prefix": "indexedset",
    "body": [
      "mod indexedset {",
      "\t#![allow(dead_code)]",
      "\t//! インデックス付きの集合",
      "\tuse std::iter::FromIterator;",
      "\tuse std::mem::{replace, swap};",
      "\tuse std::{cmp::Ordering, fmt::Debug};",
      "\t/// # Node",
      "\t#[derive(Debug, Clone)]",
      "\tpub struct Node<T: Ord> {",
      "\t\tpub key: T,",
      "\t\tpub left: Option<Box<Node<T>>>,",
      "\t\tpub right: Option<Box<Node<T>>>,",
      "\t\t/// 部分木のサイズ",
      "\t\tpub size: usize,",
      "\t}",
      "\timpl<T: Ord> Node<T> {",
      "\t\tpub fn new(key: T) -> Self {",
      "\t\t\tSelf {",
      "\t\t\t\tkey,",
      "\t\t\t\tleft: None,",
      "\t\t\t\tright: None,",
      "\t\t\t\tsize: 1,",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\t/// # IndexedSet",
      "\t/// スプレー木のクラス",
      "\tpub struct IndexedSet<T: Ord> {",
      "\t\tsize: usize,",
      "\t\tpub root: Option<Box<Node<T>>>,",
      "\t}",
      "\timpl<T> IndexedSet<T>",
      "\twhere",
      "\t\tT: Ord + Clone,",
      "\t{",
      "\t\t/// `a <= b`の値を返す",
      "\t\t#[inline]",
      "\t\tfn le(a: &T, b: &T) -> bool {",
      "\t\t\tmatches!(a.cmp(b), Ordering::Less | Ordering::Equal)",
      "\t\t}",
      "\t\t/// `a < b`の値を返す",
      "\t\t#[inline]",
      "\t\tfn lt(a: &T, b: &T) -> bool {",
      "\t\t\tmatches!(a.cmp(b), Ordering::Less)",
      "\t\t}",
      "\t\t/// `a >= b`の値を返す",
      "\t\t#[inline]",
      "\t\tfn ge(a: &T, b: &T) -> bool {",
      "\t\t\tmatches!(a.cmp(b), Ordering::Equal | Ordering::Greater)",
      "\t\t}",
      "\t\t/// `a > b`の値を返す",
      "\t\t#[inline]",
      "\t\tfn gt(a: &T, b: &T) -> bool {",
      "\t\t\tmatches!(a.cmp(b), Ordering::Greater)",
      "\t\t}",
      "\t\tpub fn new() -> Self {",
      "\t\t\tSelf {",
      "\t\t\t\tsize: 0,",
      "\t\t\t\troot: None,",
      "\t\t\t}",
      "\t\t}",
      "\t\tpub fn len(&self) -> usize {",
      "\t\t\tself.size",
      "\t\t}",
      "\t\tpub fn is_empty(&self) -> bool {",
      "\t\t\tself.size == 0",
      "\t\t}",
      "\t\t/// ## get",
      "\t\t/// 値の検索を行う",
      "\t\t/// ### 戻り値",
      "\t\t/// - `Option<&T>`: キーに紐づいた値",
      "\t\tpub fn get(&mut self, key: &T) -> Option<&T> {",
      "\t\t\tlet lb = self.lower_bound(key);",
      "\t\t\tif lb.is_some_and(|k| k == key) {",
      "\t\t\t\tlb",
      "\t\t\t} else {",
      "\t\t\t\tNone",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 値の挿入を行う。",
      "\t\t/// ### 戻り値",
      "\t\t/// - `bool`: 挿入が行われたか",
      "\t\tpub fn insert(&mut self, key: T) -> Option<T> {",
      "\t\t\t// rootの取り出し",
      "\t\t\tlet root = self.root.take();",
      "\t\t\t// splay操作（一番右の要素）",
      "\t\t\tlet (mut tmp_root, _) = splay(root, &key, Self::le);",
      "\t\t\tif tmp_root.is_some() && tmp_root.as_ref().unwrap().key == key {",
      "\t\t\t\tself.root = tmp_root;",
      "\t\t\t\tlet res = replace(&mut self.root.as_deref_mut().unwrap().key, key);",
      "\t\t\t\treturn Some(res);",
      "\t\t\t}",
      "\t\t\tself.root = Some(Box::new(Node::new(key.clone())));",
      "\t\t\tif tmp_root.is_some() {",
      "\t\t\t\tmatch key.cmp(&tmp_root.as_ref().unwrap().key) {",
      "\t\t\t\t\tOrdering::Less | Ordering::Equal => {",
      "\t\t\t\t\t\tlet mut new_left = tmp_root.as_mut().unwrap().left.take();",
      "\t\t\t\t\t\tupdate_size(&mut tmp_root);",
      "\t\t\t\t\t\tswap(&mut self.root.as_mut().unwrap().left, &mut new_left);",
      "\t\t\t\t\t\tswap(&mut self.root.as_mut().unwrap().right, &mut tmp_root);",
      "\t\t\t\t\t}",
      "\t\t\t\t\tOrdering::Greater => {",
      "\t\t\t\t\t\tlet mut new_right = tmp_root.as_mut().unwrap().right.take();",
      "\t\t\t\t\t\tupdate_size(&mut tmp_root);",
      "\t\t\t\t\t\tswap(&mut self.root.as_mut().unwrap().right, &mut new_right);",
      "\t\t\t\t\t\tswap(&mut self.root.as_mut().unwrap().left, &mut tmp_root);",
      "\t\t\t\t\t}",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\t// 部分木のサイズを更新",
      "\t\t\tupdate_size(&mut self.root);",
      "\t\t\t// 要素数の更新",
      "\t\t\tself.size += 1;",
      "\t\t\tNone",
      "\t\t}",
      "\t\t/// ## delete",
      "\t\t/// 値の削除",
      "\t\t/// ### 戻り値",
      "\t\t/// - `Option<T>`: 削除された値",
      "\t\tpub fn delete(&mut self, key: &T) -> Option<T> {",
      "\t\t\tif self.is_empty() {",
      "\t\t\t\treturn None;",
      "\t\t\t}",
      "\t\t\t// rootの取り出し",
      "\t\t\tlet root = self.root.take();",
      "\t\t\t// splay操作",
      "\t\t\t// tmp_root := keyより真に大きいノードのうち最小のもの",
      "\t\t\tlet (mut tmp_root, _) = splay(root, key, Self::le);",
      "\t\t\t// 値が存在しないとき",
      "\t\t\tif tmp_root.is_none() || &tmp_root.as_ref().unwrap().key != key {",
      "\t\t\t\tself.root = tmp_root;",
      "\t\t\t\treturn None;",
      "\t\t\t}",
      "\t\t\t// 削除",
      "\t\t\tif tmp_root.as_ref().unwrap().left.is_none() {",
      "\t\t\t\tswap(&mut self.root, &mut tmp_root.as_mut().unwrap().right);",
      "\t\t\t} else {",
      "\t\t\t\tlet root_left = tmp_root.as_mut().unwrap().left.take();",
      "\t\t\t\t// 左の子のうち最大の要素を新しい根に",
      "\t\t\t\tswap(&mut self.root, &mut splay(root_left, key, Self::lt).0);",
      "\t\t\t\t// 根の右側に子を付け替える",
      "\t\t\t\tswap(",
      "\t\t\t\t\t&mut self.root.as_mut().unwrap().right,",
      "\t\t\t\t\t&mut tmp_root.as_mut().unwrap().right,",
      "\t\t\t\t);",
      "\t\t\t}",
      "\t\t\t// 部分木のサイズを更新",
      "\t\t\tupdate_size(&mut self.root);",
      "\t\t\t// 要素数の更新",
      "\t\t\tself.size -= 1;",
      "\t\t\tlet deleted = tmp_root.take();",
      "\t\t\tSome(deleted.unwrap().key)",
      "\t\t}",
      "\t\t/// ## contains_key",
      "\t\t/// - 値`key`を含むか",
      "\t\tpub fn contains_key(&mut self, key: &T) -> bool {",
      "\t\t\tself.get(key).is_some_and(|k| k == key)",
      "\t\t}",
      "\t\t/// ## lower_bound",
      "\t\t/// - `key`以上の最小の値を返す",
      "\t\tpub fn lower_bound(&mut self, key: &T) -> Option<&T> {",
      "\t\t\t// 根の取り出し",
      "\t\t\tlet root = self.root.take();",
      "\t\t\t// スプレー操作",
      "\t\t\tlet (new_root, is_found) = splay(root, key, Self::le);",
      "\t\t\tself.root = new_root;",
      "\t\t\tif is_found {",
      "\t\t\t\tSome(&self.root.as_ref().unwrap().key)",
      "\t\t\t} else {",
      "\t\t\t\tNone",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// ## upper_bound",
      "\t\t/// - `key`より大きい最小の値を返す",
      "\t\tpub fn upper_bound(&mut self, key: &T) -> Option<&T> {",
      "\t\t\t// 根の取り出し",
      "\t\t\tlet root = self.root.take();",
      "\t\t\t// スプレー操作",
      "\t\t\tlet (new_root, is_found) = splay(root, key, Self::lt);",
      "\t\t\tself.root = new_root;",
      "\t\t\tif is_found {",
      "\t\t\t\tSome(&self.root.as_ref().unwrap().key)",
      "\t\t\t} else {",
      "\t\t\t\tNone",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// ## lower_bound_rev",
      "\t\t/// - `key`以下の最大の値を返す",
      "\t\tpub fn lower_bound_rev(&mut self, key: &T) -> Option<&T> {",
      "\t\t\t// 根の取り出し",
      "\t\t\tlet root = self.root.take();",
      "\t\t\t// スプレー操作",
      "\t\t\tlet (new_root, is_found) = splay_rev(root, key, Self::ge);",
      "\t\t\tself.root = new_root;",
      "\t\t\tif is_found {",
      "\t\t\t\tSome(&self.root.as_ref().unwrap().key)",
      "\t\t\t} else {",
      "\t\t\t\tNone",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// ## upper_bound_rev",
      "\t\t/// - `key`未満の最大の値を返す",
      "\t\tpub fn upper_bound_rev(&mut self, key: &T) -> Option<&T> {",
      "\t\t\t// 根の取り出し",
      "\t\t\tlet root = self.root.take();",
      "\t\t\t// スプレー操作",
      "\t\t\tlet (new_root, is_found) = splay_rev(root, key, Self::gt);",
      "\t\t\tself.root = new_root;",
      "\t\t\tif is_found {",
      "\t\t\t\tSome(&self.root.as_ref().unwrap().key)",
      "\t\t\t} else {",
      "\t\t\t\tNone",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// ## get_by_index",
      "\t\t/// - 先頭からn番目の値を取得する（0-indexed）",
      "\t\tpub fn get_by_index(&self, n: usize) -> Option<&T> {",
      "\t\t\tif n > self.size {",
      "\t\t\t\tNone",
      "\t\t\t} else {",
      "\t\t\t\tget_nth(&self.root, n + 1)",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// ## index",
      "\t\t/// - 要素`key`のインデックスを取得する（0-indexed）",
      "\t\tpub fn index(&mut self, key: &T) -> Option<usize> {",
      "\t\t\t// keyでsplayを行う",
      "\t\t\tif self.get(key).is_some() {",
      "\t\t\t\tlet left_size = self",
      "\t\t\t\t\t.root",
      "\t\t\t\t\t.as_ref()",
      "\t\t\t\t\t.unwrap()",
      "\t\t\t\t\t.left",
      "\t\t\t\t\t.as_ref()",
      "\t\t\t\t\t.map_or(0, |node| node.size);",
      "\t\t\t\tSome(left_size)",
      "\t\t\t} else {",
      "\t\t\t\tNone",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\t/// ## get_nth",
      "\tfn get_nth<T: Ord>(root: &Option<Box<Node<T>>>, n: usize) -> Option<&T> {",
      "\t\tif let Some(root) = root {",
      "\t\t\tlet left_size = root.left.as_ref().map_or(0, |node| node.size);",
      "\t\t\tmatch n.cmp(&(left_size + 1)) {",
      "\t\t\t\tOrdering::Less => get_nth(&root.left, n),",
      "\t\t\t\tOrdering::Equal => Some(&root.key),",
      "\t\t\t\tOrdering::Greater => get_nth(&root.right, n - left_size - 1),",
      "\t\t\t}",
      "\t\t} else {",
      "\t\t\tNone",
      "\t\t}",
      "\t}",
      "\t/// ## splay",
      "\t/// 比較関数`compare`を引数にとり、条件を満たす最小のノードを返す",
      "\tfn splay<T, C>(mut root: Option<Box<Node<T>>>, key: &T, compare: C) -> (Option<Box<Node<T>>>, bool)",
      "\twhere",
      "\t\tT: Ord,",
      "\t\tC: Fn(&T, &T) -> bool,",
      "\t{",
      "\t\tif root.is_none() {",
      "\t\t\treturn (root, false);",
      "\t\t}",
      "\t\tif compare(key, &root.as_ref().unwrap().key) {",
      "\t\t\tlet left = &mut root.as_mut().unwrap().left;",
      "\t\t\tif left.is_none() {",
      "\t\t\t\treturn (root, true);",
      "\t\t\t}",
      "\t\t\tif compare(key, &left.as_ref().unwrap().key) {",
      "\t\t\t\tlet leftleft = left.as_mut().unwrap().left.take();",
      "\t\t\t\tlet (mut tmp, is_found) = splay(leftleft, key, compare);",
      "\t\t\t\t// 戻す",
      "\t\t\t\tswap(&mut left.as_mut().unwrap().left, &mut tmp);",
      "\t\t\t\t// 親を右に回転",
      "\t\t\t\tlet tmp_left = rotate_right(root);",
      "\t\t\t\tif !is_found {",
      "\t\t\t\t\treturn (tmp_left, true);",
      "\t\t\t\t}",
      "\t\t\t\t// さらに右回転",
      "\t\t\t\t(rotate_right(tmp_left), true)",
      "\t\t\t} else {",
      "\t\t\t\tlet leftright = left.as_mut().unwrap().right.take();",
      "\t\t\t\tlet (mut new_leftright, is_found) = splay(leftright, key, compare);",
      "\t\t\t\t// 戻す",
      "\t\t\t\tswap(&mut left.as_mut().unwrap().right, &mut new_leftright);",
      "\t\t\t\t// root->left->rightがNoneでないとき",
      "\t\t\t\tif !is_found {",
      "\t\t\t\t\treturn (root, true);",
      "\t\t\t\t}",
      "\t\t\t\t// 左の子を左回転",
      "\t\t\t\tlet left = root.as_mut().unwrap().left.take();",
      "\t\t\t\tlet mut tmp_child = rotate_left(left);",
      "\t\t\t\tswap(&mut root.as_mut().unwrap().left, &mut tmp_child);",
      "\t\t\t\t// 親を右回転",
      "\t\t\t\t(rotate_right(root), true)",
      "\t\t\t}",
      "\t\t} else {",
      "\t\t\tlet right = &mut root.as_mut().unwrap().right;",
      "\t\t\tif right.is_none() {",
      "\t\t\t\treturn (root, false);",
      "\t\t\t}",
      "\t\t\tif compare(key, &right.as_ref().unwrap().key) {",
      "\t\t\t\tlet rightleft = right.as_mut().unwrap().left.take();",
      "\t\t\t\tlet (mut tmp, is_found) = splay(rightleft, key, compare);",
      "\t\t\t\t// 戻す",
      "\t\t\t\tswap(&mut right.as_mut().unwrap().left, &mut tmp);",
      "\t\t\t\tif is_found {",
      "\t\t\t\t\t// 右の子を右回転",
      "\t\t\t\t\tlet right = root.as_mut().unwrap().right.take();",
      "\t\t\t\t\tlet mut tmp_child = rotate_right(right);",
      "\t\t\t\t\tswap(&mut root.as_mut().unwrap().right, &mut tmp_child);",
      "\t\t\t\t}",
      "\t\t\t\t// 親を左回転",
      "\t\t\t\t(rotate_left(root), true)",
      "\t\t\t} else {",
      "\t\t\t\tlet rightright = right.as_mut().unwrap().right.take();",
      "\t\t\t\tlet (mut tmp, is_found) = splay(rightright, key, compare);",
      "\t\t\t\t// 戻す",
      "\t\t\t\tswap(&mut right.as_mut().unwrap().right, &mut tmp);",
      "\t\t\t\t// 親を左回転",
      "\t\t\t\tlet tmp_child = rotate_left(root);",
      "\t\t\t\t// さらに左回転",
      "\t\t\t\t(rotate_left(tmp_child), is_found)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\t/// ## splay_rev",
      "\t/// - 比較関数`compare`を引数にとり、条件を満たす最小のノードを返す",
      "\t/// - splayの逆向き",
      "\tfn splay_rev<T, C>(",
      "\t\tmut root: Option<Box<Node<T>>>,",
      "\t\tkey: &T,",
      "\t\tcompare: C,",
      "\t) -> (Option<Box<Node<T>>>, bool)",
      "\twhere",
      "\t\tT: Ord,",
      "\t\tC: Fn(&T, &T) -> bool,",
      "\t{",
      "\t\tif root.is_none() {",
      "\t\t\treturn (root, false);",
      "\t\t}",
      "\t\tif compare(key, &root.as_ref().unwrap().key) {",
      "\t\t\tlet right = &mut root.as_mut().unwrap().right;",
      "\t\t\tif right.is_none() {",
      "\t\t\t\treturn (root, true);",
      "\t\t\t}",
      "\t\t\tif compare(key, &right.as_ref().unwrap().key) {",
      "\t\t\t\tlet rightright = right.as_mut().unwrap().right.take();",
      "\t\t\t\tlet (mut tmp, is_found) = splay_rev(rightright, key, compare);",
      "\t\t\t\t// 戻す",
      "\t\t\t\tswap(&mut right.as_mut().unwrap().right, &mut tmp);",
      "\t\t\t\t// 親を左に回転",
      "\t\t\t\tlet tmp_right = rotate_left(root);",
      "\t\t\t\tif !is_found {",
      "\t\t\t\t\treturn (tmp_right, true);",
      "\t\t\t\t}",
      "\t\t\t\t// さらに左回転",
      "\t\t\t\t(rotate_left(tmp_right), true)",
      "\t\t\t} else {",
      "\t\t\t\tlet rightleft = right.as_mut().unwrap().left.take();",
      "\t\t\t\tlet (mut new_rightleft, is_found) = splay_rev(rightleft, key, compare);",
      "\t\t\t\t// 戻す",
      "\t\t\t\tswap(&mut right.as_mut().unwrap().left, &mut new_rightleft);",
      "\t\t\t\t// root->right->leftがNoneでないとき",
      "\t\t\t\tif !is_found {",
      "\t\t\t\t\treturn (root, true);",
      "\t\t\t\t}",
      "\t\t\t\t// 右の子を右回転",
      "\t\t\t\tlet right = root.as_mut().unwrap().right.take();",
      "\t\t\t\tlet mut tmp_child = rotate_right(right);",
      "\t\t\t\tswap(&mut root.as_mut().unwrap().right, &mut tmp_child);",
      "\t\t\t\t// 親を左回転",
      "\t\t\t\t(rotate_left(root), true)",
      "\t\t\t}",
      "\t\t} else {",
      "\t\t\tlet left = &mut root.as_mut().unwrap().left;",
      "\t\t\tif left.is_none() {",
      "\t\t\t\treturn (root, false);",
      "\t\t\t}",
      "\t\t\tif compare(key, &left.as_ref().unwrap().key) {",
      "\t\t\t\tlet leftright = left.as_mut().unwrap().right.take();",
      "\t\t\t\tlet (mut tmp, is_found) = splay_rev(leftright, key, compare);",
      "\t\t\t\t// 戻す",
      "\t\t\t\tswap(&mut left.as_mut().unwrap().right, &mut tmp);",
      "\t\t\t\tif is_found {",
      "\t\t\t\t\t// 左の子を左回転",
      "\t\t\t\t\tlet left = root.as_mut().unwrap().left.take();",
      "\t\t\t\t\tlet mut tmp_child = rotate_left(left);",
      "\t\t\t\t\tswap(&mut root.as_mut().unwrap().left, &mut tmp_child);",
      "\t\t\t\t}",
      "\t\t\t\t// 親を右回転",
      "\t\t\t\t(rotate_right(root), true)",
      "\t\t\t} else {",
      "\t\t\t\tlet leftleft = left.as_mut().unwrap().left.take();",
      "\t\t\t\tlet (mut tmp, is_found) = splay_rev(leftleft, key, compare);",
      "\t\t\t\t// 戻す",
      "\t\t\t\tswap(&mut left.as_mut().unwrap().left, &mut tmp);",
      "\t\t\t\t// 親を右回転",
      "\t\t\t\tlet tmp_child = rotate_right(root);",
      "\t\t\t\t// さらに右回転",
      "\t\t\t\t(rotate_right(tmp_child), is_found)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\t/// 部分木のサイズを更新する",
      "\tfn update_size<T: Ord>(node: &mut Option<Box<Node<T>>>) {",
      "\t\tif let Some(node) = node {",
      "\t\t\tlet left_size = node.left.as_ref().map_or(0, |node| node.size);",
      "\t\t\tlet right_size = node.right.as_ref().map_or(0, |node| node.size);",
      "\t\t\tnode.size = left_size + right_size + 1;",
      "\t\t}",
      "\t}",
      "\t/// ## 右回転",
      "\t/// ```not-rust",
      "\t///\t\tY\t\t\t\t\t  X",
      "\t///\t   / \\\t   right\t\t/ \\",
      "\t///\t  X   C  === rotate ==>  A   Y",
      "\t///\t / \\\t\t\t\t\t\t/ \\",
      "\t///\tA   B\t\t\t\t\t  B   C",
      "\t/// ```",
      "\tfn rotate_right<T: Ord>(root: Option<Box<Node<T>>>) -> Option<Box<Node<T>>> {",
      "\t\tlet mut root = root?;",
      "\t\tlet Some(mut new_root) = root.left else {",
      "\t\t\treturn Some(root);",
      "\t\t};",
      "\t\troot.left = new_root.right;",
      "\t\tnew_root.right = Some(root);",
      "\t\tupdate_size(&mut new_root.right);",
      "\t\tlet mut res = Some(new_root);",
      "\t\tupdate_size(&mut res);",
      "\t\tres",
      "\t}",
      "\t/// ## 左回転",
      "\t/// ```not-rust",
      "\t///\t  X\t\t\t\t\t\t  Y",
      "\t///\t / \\\t\t left\t\t   / \\",
      "\t///\tA   Y\t=== rotate ==>\tX   C",
      "\t///\t   / \\\t\t\t\t\t/ \\",
      "\t///\t  B   C\t\t\t\t  A   B",
      "\t/// ```",
      "\tfn rotate_left<T: Ord>(root: Option<Box<Node<T>>>) -> Option<Box<Node<T>>> {",
      "\t\tlet mut root = root?;",
      "\t\tlet Some(mut new_root) = root.right else {",
      "\t\t\treturn Some(root);",
      "\t\t};",
      "\t\troot.right = new_root.left;",
      "\t\tnew_root.left = Some(root);",
      "\t\tupdate_size(&mut new_root.left);",
      "\t\tlet mut res = Some(new_root);",
      "\t\tupdate_size(&mut res);",
      "\t\tres",
      "\t}",
      "\t// ----- FromIterator -----",
      "\timpl<T: Ord + Clone> FromIterator<T> for IndexedSet<T> {",
      "\t\tfn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {",
      "\t\t\tlet mut res = IndexedSet::new();",
      "\t\t\tfor item in iter {",
      "\t\t\t\tres.insert(item);",
      "\t\t\t}",
      "\t\t\tres",
      "\t\t}",
      "\t}",
      "\t// ----- Debug -----",
      "\timpl<T: Ord + Debug> Debug for IndexedSet<T> {",
      "\t\tfn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
      "\t\t\tfmt_inner(f, &self.root, 0);",
      "\t\t\tOk(())",
      "\t\t}",
      "\t}",
      "\t/// 再帰的に表示",
      "\t#[allow(unused_must_use)]",
      "\tfn fmt_inner<T>(f: &mut std::fmt::Formatter<'_>, node: &Option<Box<Node<T>>>, depth: usize)",
      "\twhere",
      "\t\tT: Ord + Debug,",
      "\t{",
      "\t\tmatch node {",
      "\t\t\tSome(ref node) => {",
      "\t\t\t\tfmt_inner(f, &node.left, depth + 1);",
      "\t\t\t\twriteln!(",
      "\t\t\t\t\tf,",
      "\t\t\t\t\t\"{}({:?}, size:{})\",",
      "\t\t\t\t\t\" \".repeat(depth * 2),",
      "\t\t\t\t\tnode.key,",
      "\t\t\t\t\tnode.size",
      "\t\t\t\t);",
      "\t\t\t\tfmt_inner(f, &node.right, depth + 1);",
      "\t\t\t}",
      "\t\t\tNone => {}",
      "\t\t}",
      "\t}",
      "\t// ----- iterator -----",
      "\tpub struct SplayTreeIterator<'a, T: 'a + Ord> {",
      "\t\tunvisited: Vec<&'a Node<T>>,",
      "\t}",
      "\timpl<'a, T: Ord> SplayTreeIterator<'a, T> {",
      "\t\tfn push_left_edge(&mut self, mut tree: &'a Option<Box<Node<T>>>) {",
      "\t\t\twhile let Some(node) = tree.as_deref() {",
      "\t\t\t\tself.unvisited.push(node);",
      "\t\t\t\ttree = &node.left;",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\timpl<'a, T: Ord> Iterator for SplayTreeIterator<'a, T> {",
      "\t\ttype Item = &'a T;",
      "\t\tfn next(&mut self) -> Option<Self::Item> {",
      "\t\t\tlet node = match self.unvisited.pop() {",
      "\t\t\t\tNone => return None,",
      "\t\t\t\tSome(n) => n,",
      "\t\t\t};",
      "\t\t\tself.push_left_edge(&node.right);",
      "\t\t\tSome(&node.key)",
      "\t\t}",
      "\t}",
      "\timpl<T: Ord> IndexedSet<T> {",
      "\t\tpub fn iter(&self) -> SplayTreeIterator<'_, T> {",
      "\t\t\tlet mut iter = SplayTreeIterator { unvisited: vec![] };",
      "\t\t\titer.push_left_edge(&self.root);",
      "\t\t\titer",
      "\t\t}",
      "\t}",
      "\timpl<'a, T: Ord> IntoIterator for &'a IndexedSet<T> {",
      "\t\ttype IntoIter = SplayTreeIterator<'a, T>;",
      "\t\ttype Item = &'a T;",
      "\t\tfn into_iter(self) -> Self::IntoIter {",
      "\t\t\tself.iter()",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "インデックス付きの集合"
  },
  "bitset.rs": {
    "prefix": "bitset",
    "body": [
      "mod bitset {",
      "\t#![allow(dead_code)]",
      "\t//! ビット列を管理する",
      "\tuse std::{",
      "\t\tfmt::Debug,",
      "\t\tops::{Deref, DerefMut, Index},",
      "\t};",
      "\t/// ビット列を高速に処理する",
      "\t#[derive(Clone)]",
      "\tpub struct BitSet<const SIZE: usize> {",
      "\t\tbits: Vec<u64>,",
      "\t}",
      "\timpl<const SIZE: usize> BitSet<SIZE> {",
      "\t\t/// ⌈size / 64⌉個のu64",
      "\t\tconst ARRAY_SIZE: usize = (SIZE + 64 - 1) / 64;",
      "\t\t/// あまりのビット",
      "\t\tconst REM_BIT: usize = SIZE % 64;",
      "\t\t/// 一時的な値",
      "\t\tconst TMP_BOOL: [bool; 2] = [false, true];",
      "\t\t/// Bitsetを初期化する",
      "\t\t/// - `size`: ビットの数",
      "\t\tpub fn new() -> Self {",
      "\t\t\tSelf {",
      "\t\t\t\tbits: vec![0; Self::ARRAY_SIZE],",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// `idx`bit目を1に設定",
      "\t\tpub fn set(&mut self, index: usize) {",
      "\t\t\tlet arr_idx = index / 64;",
      "\t\t\tlet bit_idx = index % 64;",
      "\t\t\tself.bits[arr_idx] |= 1 << bit_idx;",
      "\t\t}",
      "\t\t/// `idx`bit目を0に設定",
      "\t\tpub fn unset(&mut self, index: usize) {",
      "\t\t\tlet arr_idx = index / 64;",
      "\t\t\tlet bit_idx = index % 64;",
      "\t\t\tself.bits[arr_idx] &= !(1 << bit_idx);",
      "\t\t}",
      "\t\t/// `idx`bit目を反転",
      "\t\tpub fn flip(&mut self, index: usize) {",
      "\t\t\tif self[index] {",
      "\t\t\t\tself.unset(index);",
      "\t\t\t} else {",
      "\t\t\t\tself.set(index);",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// すべてのbitが0になっているかを判定する",
      "\t\tpub fn any(&self) -> bool {",
      "\t\t\tself.bits.iter().all(|&b64| b64 == 0)",
      "\t\t}",
      "\t\t/// すべてのbitが1になっているかを判定する",
      "\t\tpub fn all(&self) -> bool {",
      "\t\t\t// あまりだけ個別に判定",
      "\t\t\tlet filter = !0_u64 >> (64 - Self::REM_BIT);",
      "\t\t\tself.bits[Self::ARRAY_SIZE - 1] ^ filter == 0",
      "\t\t\t\t&& self",
      "\t\t\t\t\t.bits",
      "\t\t\t\t\t.iter()",
      "\t\t\t\t\t.take(Self::ARRAY_SIZE - 1)",
      "\t\t\t\t\t.all(|&b64| b64 == !0)",
      "\t\t}",
      "\t\t/// あるbitを更新する",
      "\t\tfn update(&mut self, index: usize, new_val: bool) {",
      "\t\t\tif new_val {",
      "\t\t\t\tself.set(index);",
      "\t\t\t} else {",
      "\t\t\t\tself.unset(index);",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 1であるビットの数を求める",
      "\t\tpub fn count_ones(&self) -> usize {",
      "\t\t\tself.bits",
      "\t\t\t\t.iter()",
      "\t\t\t\t.map(|b64| b64.count_ones() as usize)",
      "\t\t\t\t.sum::<usize>()",
      "\t\t}",
      "\t\t/// あるbitの可変参照を取得する",
      "\t\t/// - `index`: 取得するbitのインデックス",
      "\t\tpub fn get_mut(&mut self, index: usize) -> Option<BitMut<'_, SIZE>> {",
      "\t\t\tif index < SIZE {",
      "\t\t\t\tlet default = self[index];",
      "\t\t\t\tSome(BitMut {",
      "\t\t\t\t\tbitset: self,",
      "\t\t\t\t\tidx: index,",
      "\t\t\t\t\tnew_val: default,",
      "\t\t\t\t})",
      "\t\t\t} else {",
      "\t\t\t\tNone",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\timpl<const SIZE: usize> Index<usize> for BitSet<SIZE> {",
      "\t\ttype Output = bool;",
      "\t\tfn index(&self, index: usize) -> &Self::Output {",
      "\t\t\tlet arr_idx = index / 64;",
      "\t\t\tlet bit_idx = index % 64;",
      "\t\t\tif self.bits[arr_idx] >> bit_idx & 1 == 0 {",
      "\t\t\t\t&Self::TMP_BOOL[0]",
      "\t\t\t} else {",
      "\t\t\t\t&Self::TMP_BOOL[1]",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\t/// bitsetの更新を行う",
      "\tpub struct BitMut<'a, const SIZE: usize> {",
      "\t\tbitset: &'a mut BitSet<SIZE>,",
      "\t\tidx: usize,",
      "\t\tnew_val: bool,",
      "\t}",
      "\timpl<const SIZE: usize> Deref for BitMut<'_, SIZE> {",
      "\t\ttype Target = bool;",
      "\t\tfn deref(&self) -> &Self::Target {",
      "\t\t\t&self.new_val",
      "\t\t}",
      "\t}",
      "\timpl<const SIZE: usize> DerefMut for BitMut<'_, SIZE> {",
      "\t\tfn deref_mut(&mut self) -> &mut Self::Target {",
      "\t\t\t&mut self.new_val",
      "\t\t}",
      "\t}",
      "\timpl<const SIZE: usize> Drop for BitMut<'_, SIZE> {",
      "\t\tfn drop(&mut self) {",
      "\t\t\tself.bitset.update(self.idx, self.new_val);",
      "\t\t}",
      "\t}",
      "\timpl<const SIZE: usize> Debug for BitSet<SIZE> {",
      "\t\tfn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
      "\t\t\tlet mut bit_str = format!(\"{:b}\", self.bits[Self::ARRAY_SIZE - 1]);",
      "\t\t\t// ゼロ埋め",
      "\t\t\tbit_str = \"0\".repeat(Self::REM_BIT - bit_str.len()) + &bit_str;",
      "\t\t\tbit_str = self.bits[..Self::ARRAY_SIZE - 1]",
      "\t\t\t\t.iter()",
      "\t\t\t\t.rev()",
      "\t\t\t\t.map(|b64| format!(\",{:0>64b}\", b64))",
      "\t\t\t\t.fold(bit_str, |acc, b64| acc + &b64);",
      "\t\t\twrite!(f, \"BitSet {{ {:?} }}\", bit_str)",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "ビット列を管理する"
  },
  "grid.rs": {
    "prefix": "grid",
    "body": [
      "mod grid {",
      "\t#![allow(dead_code)]",
      "\t//! グリッド探索の便利ツール",
      "\t/// グリッドの探索",
      "\tpub trait Grid<T>",
      "\twhere",
      "\t\tSelf: Sized,",
      "\t{",
      "\t\t/// usizeにおける-1",
      "\t\tconst NEG1: T;",
      "\t\t/// 隣接する4方向（上下左右）",
      "\t\tconst ADJ4: [(T, T); 4];",
      "\t\t/// 隣接する8方向",
      "\t\tconst ADJ8: [(T, T); 8];",
      "\t\t/// 座標`(i,j)`に上下左右で隣接する座標を取得",
      "\t\t/// - グリッドサイズ`HxW`でバリデーション",
      "\t\tfn get_adj_4(&self, H: usize, W: usize) -> Vec<Self>;",
      "\t\t/// 座標`(i,j)`に8方向で隣接する座標を取得",
      "\t\t/// - グリッドサイズ`HxW`でバリデーション",
      "\t\tfn get_adj_8(&self, H: usize, W: usize) -> Vec<Self>;",
      "\t}",
      "\timpl Grid<usize> for (usize, usize) {",
      "\t\tconst NEG1: usize = 1_usize.wrapping_neg();",
      "\t\tconst ADJ4: [(usize, usize); 4] = [(0, Self::NEG1), (Self::NEG1, 0), (0, 1), (1, 0)];",
      "\t\tconst ADJ8: [(usize, usize); 8] = [",
      "\t\t\t(Self::NEG1, Self::NEG1),",
      "\t\t\t(Self::NEG1, 0),",
      "\t\t\t(Self::NEG1, 1),",
      "\t\t\t(0, Self::NEG1),",
      "\t\t\t(0, 1),",
      "\t\t\t(1, Self::NEG1),",
      "\t\t\t(1, 0),",
      "\t\t\t(1, 1),",
      "\t\t];",
      "\t\tfn get_adj_4(&self, H: usize, W: usize) -> Vec<(usize, usize)> {",
      "\t\t\tlet mut adj = vec![];",
      "\t\t\tfor &(dr, dc) in &Self::ADJ4 {",
      "\t\t\t\tlet nr = self.0.wrapping_add(dr);",
      "\t\t\t\tlet nc = self.1.wrapping_add(dc);",
      "\t\t\t\tif nr < H && nc < W {",
      "\t\t\t\t\tadj.push((nr, nc));",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\tadj",
      "\t\t}",
      "\t\tfn get_adj_8(&self, H: usize, W: usize) -> Vec<(usize, usize)> {",
      "\t\t\tlet mut adj = vec![];",
      "\t\t\tfor &(dr, dc) in &Self::ADJ8 {",
      "\t\t\t\tlet nr = self.0.wrapping_add(dr);",
      "\t\t\t\tlet nc = self.1.wrapping_add(dc);",
      "\t\t\t\tif nr < H && nc < W {",
      "\t\t\t\t\tadj.push((nr, nc));",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\tadj",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "グリッド探索の便利ツール"
  },
  "sparse_table.rs": {
    "prefix": "sparse_table",
    "body": [
      "mod sparse_table {",
      "\t#![allow(dead_code)]",
      "\t//! SparseTable",
      "\tuse std::fmt;",
      "\tuse std::ops::{",
      "\t\tBound::{Excluded, Included, Unbounded},",
      "\t\tRangeBounds,",
      "\t};",
      "\tpub trait Semilattice {",
      "\t\t/// 元の型",
      "\t\ttype Val: fmt::Debug + Clone;",
      "\t\t/// 単位元",
      "\t\tconst E: Self::Val;",
      "\t\t/// 可換な二項演算",
      "\t\tfn op(x: &Self::Val, y: &Self::Val) -> Self::Val;",
      "\t}",
      "\t#[derive(Debug)]",
      "\tpub struct SparseTable<S: Semilattice> {",
      "\t\tpub size: usize,",
      "\t\ttable: Vec<Vec<S::Val>>,",
      "\t\tlogs: Vec<usize>,",
      "\t}",
      "\timpl<S: Semilattice> SparseTable<S> {",
      "\t\t#[inline]",
      "\t\tfn parse_range<R: RangeBounds<usize>>(&self, range: &R) -> Option<(usize, usize)> {",
      "\t\t\tlet start = match range.start_bound() {",
      "\t\t\t\tUnbounded => 0,",
      "\t\t\t\tExcluded(&v) => v + 1,",
      "\t\t\t\tIncluded(&v) => v,",
      "\t\t\t};",
      "\t\t\tlet end = match range.end_bound() {",
      "\t\t\t\tUnbounded => self.size,",
      "\t\t\t\tExcluded(&v) => v,",
      "\t\t\t\tIncluded(&v) => v + 1,",
      "\t\t\t};",
      "\t\t\tif start <= end && end <= self.size {",
      "\t\t\t\tSome((start, end))",
      "\t\t\t} else {",
      "\t\t\t\tNone",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// SparseTableを構築する",
      "\t\tpub fn build(arr: &[S::Val]) -> Self {",
      "\t\t\tlet size = arr.len();",
      "\t\t\t// 区間取得用の配列",
      "\t\t\tlet mut logs = vec![0; size + 1];",
      "\t\t\tfor i in 2..=size {",
      "\t\t\t\tlogs[i] = logs[i >> 1] + 1;",
      "\t\t\t}",
      "\t\t\t// テーブルの高さ",
      "\t\t\tlet lg = logs[size] + 1;",
      "\t\t\t// 繰り返し適用した結果",
      "\t\t\tlet mut table = vec![vec![]; lg];",
      "\t\t\tfor i in 0..size {",
      "\t\t\t\ttable[0].push(arr[i].clone());",
      "\t\t\t}",
      "\t\t\tfor i in 1..lg {",
      "\t\t\t\tlet mut j = 0;",
      "\t\t\t\twhile j + (1 << i) <= size {",
      "\t\t\t\t\tlet a = &table[i - 1][j];",
      "\t\t\t\t\tlet b = &table[i - 1][j + (1 << (i - 1))];",
      "\t\t\t\t\tlet res = S::op(a, b);",
      "\t\t\t\t\ttable[i].push(res);",
      "\t\t\t\t\tj += 1;",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\tSelf { size, table, logs }",
      "\t\t}",
      "\t\t/// 区間取得",
      "\t\tpub fn get_range<R: RangeBounds<usize> + fmt::Debug>(&self, range: R) -> S::Val {",
      "\t\t\tlet Some((start, end)) = self.parse_range(&range) else {",
      "\t\t\t\tpanic!(\"The given range is wrong: {:?}\", range);",
      "\t\t\t};",
      "\t\t\tif start >= end {",
      "\t\t\t\treturn S::E;",
      "\t\t\t}",
      "\t\t\tlet lg = self.logs[end - start];",
      "\t\t\tlet left = &self.table[lg][start];",
      "\t\t\tlet right = &self.table[lg][end - (1 << lg)];",
      "\t\t\tS::op(left, right)",
      "\t\t}",
      "\t}",
      "\tpub mod Alg {",
      "\t\tuse super::Semilattice;",
      "\t\t/// 区間最小値",
      "\t\t#[derive(Debug)]",
      "\t\tpub struct Min;",
      "\t\timpl Semilattice for Min {",
      "\t\t\ttype Val = isize;",
      "\t\t\tconst E: Self::Val = isize::MAX;",
      "\t\t\tfn op(x: &Self::Val, y: &Self::Val) -> Self::Val {",
      "\t\t\t\t*x.min(y)",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 区間最大値",
      "\t\t#[derive(Debug)]",
      "\t\tpub struct Max;",
      "\t\timpl Semilattice for Max {",
      "\t\t\ttype Val = isize;",
      "\t\t\tconst E: Self::Val = isize::MAX;",
      "\t\t\tfn op(x: &Self::Val, y: &Self::Val) -> Self::Val {",
      "\t\t\t\t*x.max(y)",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 最大公約数",
      "\t\tpub fn gcd(a: usize, b: usize) -> usize {",
      "\t\t\tif b == 0 {",
      "\t\t\t\ta",
      "\t\t\t} else {",
      "\t\t\t\tgcd(b, a % b)",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 区間最大公約数",
      "\t\t#[derive(Debug)]",
      "\t\tpub struct GCD;",
      "\t\timpl Semilattice for GCD {",
      "\t\t\ttype Val = usize;",
      "\t\t\tconst E: Self::Val = 0;",
      "\t\t\tfn op(x: &Self::Val, y: &Self::Val) -> Self::Val {",
      "\t\t\t\tgcd(*x, *y)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "SparseTable"
  },
  "extmonoid.rs": {
    "prefix": "extmonoid",
    "body": [
      "mod extmonoid {",
      "\t#![allow(dead_code)]",
      "\t//! 作用付きモノイド",
      "\t/// 作用付きモノイド",
      "\tpub trait ExtMonoid {",
      "\t\t/// 要素のデータ型",
      "\t\ttype X: Clone + PartialEq;",
      "\t\t/// 作用素のデータ型",
      "\t\ttype M: Clone + PartialEq;",
      "\t\t/// 要素Xの単位元",
      "\t\tconst IX: Self::X;",
      "\t\t/// 作用素Mの単位元",
      "\t\tconst IM: Self::M;",
      "\t\t/// 要素同士の演算",
      "\t\tfn operate_x(x: &Self::X, y: &Self::X) -> Self::X;",
      "\t\t/// 要素に対する作用",
      "\t\tfn apply(x: &Self::X, y: &Self::M) -> Self::X;",
      "\t\t/// 作用素同士の演算",
      "\t\tfn operate_m(x: &Self::M, y: &Self::M) -> Self::M;",
      "\t\t/// 作用素の集約",
      "\t\tfn aggregate(x: &Self::M, p: usize) -> Self::M;",
      "\t}",
      "\t/// （遅延セグ木）作用付きモノイド",
      "\tpub mod examples {",
      "\t\tuse super::ExtMonoid;",
      "\t\t/// ## RSQandRAQ",
      "\t\t/// - 区間加算",
      "\t\t/// - 区間和",
      "\t\t#[derive(Debug)]",
      "\t\tpub struct RSQandRAQ;",
      "\t\timpl ExtMonoid for RSQandRAQ {",
      "\t\t\ttype X = isize;",
      "\t\t\ttype M = isize;",
      "\t\t\tconst IX: Self::X = 0;",
      "\t\t\tconst IM: Self::M = 0;",
      "\t\t\tfn operate_x(x: &Self::X, y: &Self::X) -> Self::X {",
      "\t\t\t\tx + y",
      "\t\t\t}",
      "\t\t\tfn apply(x: &Self::X, y: &Self::M) -> Self::X {",
      "\t\t\t\tx + y",
      "\t\t\t}",
      "\t\t\tfn operate_m(x: &Self::M, y: &Self::M) -> Self::M {",
      "\t\t\t\tx + y",
      "\t\t\t}",
      "\t\t\tfn aggregate(x: &Self::M, p: usize) -> Self::M {",
      "\t\t\t\tx * p as isize",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// ## RMQandRUQ",
      "\t\t/// - 区間更新",
      "\t\t/// - 区間最小値",
      "\t\t#[derive(Debug)]",
      "\t\tpub struct RMQandRUQ;",
      "\t\timpl ExtMonoid for RMQandRUQ {",
      "\t\t\ttype X = isize;",
      "\t\t\ttype M = isize;",
      "\t\t\tconst IM: Self::M = (1 << 31) - 1;",
      "\t\t\tconst IX: Self::X = (1 << 31) - 1;",
      "\t\t\tfn operate_x(x: &Self::X, y: &Self::X) -> Self::X {",
      "\t\t\t\t*x.min(y)",
      "\t\t\t}",
      "\t\t\tfn apply(_x: &Self::X, y: &Self::M) -> Self::X {",
      "\t\t\t\t*y",
      "\t\t\t}",
      "\t\t\tfn operate_m(_x: &Self::M, y: &Self::M) -> Self::M {",
      "\t\t\t\t*y",
      "\t\t\t}",
      "\t\t\tfn aggregate(x: &Self::M, _p: usize) -> Self::M {",
      "\t\t\t\t*x",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// ## RMQandRAQ",
      "\t\t/// - 区間加算",
      "\t\t/// - 区間最小値",
      "\t\t#[derive(Debug)]",
      "\t\tpub struct RMQandRAQ;",
      "\t\timpl ExtMonoid for RMQandRAQ {",
      "\t\t\ttype X = isize;",
      "\t\t\ttype M = isize;",
      "\t\t\tconst IM: Self::M = 0;",
      "\t\t\tconst IX: Self::X = 1 << 31;",
      "\t\t\tfn operate_x(x: &Self::X, y: &Self::X) -> Self::X {",
      "\t\t\t\t*x.min(y)",
      "\t\t\t}",
      "\t\t\tfn apply(x: &Self::X, y: &Self::M) -> Self::X {",
      "\t\t\t\tx + y",
      "\t\t\t}",
      "\t\t\tfn operate_m(x: &Self::M, y: &Self::M) -> Self::M {",
      "\t\t\t\tx + y",
      "\t\t\t}",
      "\t\t\tfn aggregate(x: &Self::M, _p: usize) -> Self::M {",
      "\t\t\t\t*x",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// ## RSQandRUQ",
      "\t\t/// - 区間更新",
      "\t\t/// - 区間和取得",
      "\t\t#[derive(Debug)]",
      "\t\tpub struct RSQandRUQ;",
      "\t\timpl ExtMonoid for RSQandRUQ {",
      "\t\t\ttype X = isize;",
      "\t\t\ttype M = Option<isize>;",
      "\t\t\tconst IX: Self::X = 0;",
      "\t\t\tconst IM: Self::M = None;",
      "\t\t\tfn operate_x(x: &Self::X, y: &Self::X) -> Self::X {",
      "\t\t\t\tx + y",
      "\t\t\t}",
      "\t\t\tfn apply(_x: &Self::X, y: &Self::M) -> Self::X {",
      "\t\t\t\ty.unwrap()",
      "\t\t\t}",
      "\t\t\tfn operate_m(_x: &Self::M, y: &Self::M) -> Self::M {",
      "\t\t\t\t*y",
      "\t\t\t}",
      "\t\t\tfn aggregate(x: &Self::M, p: usize) -> Self::M {",
      "\t\t\t\tx.map(|x| x * p as isize)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "作用付きモノイド"
  },
  "segment_tree_2d.rs": {
    "prefix": "segment_tree_2d",
    "body": [
      "mod monoid {",
      "\t#![allow(dead_code)]",
      "\t//! モノイド",
      "\tuse std::fmt::Debug;",
      "\t/// モノイド",
      "\tpub trait Monoid {",
      "\t\t/// 元の型",
      "\t\ttype Val: Debug + Clone + PartialEq;",
      "\t\t/// 単位元",
      "\t\tconst E: Self::Val;",
      "\t\t/// 演算",
      "\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val;",
      "\t}",
      "\t/// 各種モノイド",
      "\tpub mod examples {",
      "\t\tuse super::Monoid;",
      "\t\t/// 和",
      "\t\tpub struct Add;",
      "\t\timpl Monoid for Add {",
      "\t\t\ttype Val = isize;",
      "\t\t\tconst E: Self::Val = 0;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tleft + right",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 積",
      "\t\tpub struct Mul;",
      "\t\timpl Monoid for Mul {",
      "\t\t\ttype Val = isize;",
      "\t\t\tconst E: Self::Val = 1;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tleft * right",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// bit単位の排他的論理和",
      "\t\tpub struct Xor;",
      "\t\timpl Monoid for Xor {",
      "\t\t\ttype Val = usize;",
      "\t\t\tconst E: Self::Val = 0;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tleft ^ right",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 最小値",
      "\t\tpub struct Min;",
      "\t\timpl Monoid for Min {",
      "\t\t\ttype Val = isize;",
      "\t\t\tconst E: Self::Val = (1 << 31) - 1;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\t*left.min(right)",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 最大値",
      "\t\tpub struct Max;",
      "\t\timpl Monoid for Max {",
      "\t\t\ttype Val = isize;",
      "\t\t\tconst E: Self::Val = -((1 << 31) - 1);",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\t*left.max(right)",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 最小公倍数",
      "\t\tpub struct GCD;",
      "\t\timpl Monoid for GCD {",
      "\t\t\ttype Val = usize;",
      "\t\t\tconst E: Self::Val = 0;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tgcd(*left, *right)",
      "\t\t\t}",
      "\t\t}",
      "\t\tpub fn gcd(a: usize, b: usize) -> usize {",
      "\t\t\tif b == 0 {",
      "\t\t\t\ta",
      "\t\t\t} else {",
      "\t\t\t\tgcd(b, a % b)",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// アフィン変換（浮動小数点数）",
      "\t\tstruct Affine;",
      "\t\timpl Monoid for Affine {",
      "\t\t\ttype Val = (f64, f64);",
      "\t\t\tconst E: Self::Val = (1.0, 0.0);",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tlet &(a1, b1) = left;",
      "\t\t\t\tlet &(a2, b2) = right;",
      "\t\t\t\t(a2 * a1, a2 * b1 + b2)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "}",
      "",
      "mod segment_tree_2d {",
      "\t#![allow(dead_code)]",
      "\t//! 二次元セグメント木",
      "\t//! - 参考：[二次元セグメント木 - Nyaan's Library](https://nyaannyaan.github.io/library/data-structure-2d/2d-segment-tree.hpp.html)",
      "\t/// cfor! {}",
      "\tmacro_rules! cfor {",
      "\t\t(\\$def:stmt ; \\$fin:expr ; \\$incr:stmt ;; \\$bl:block) => {{",
      "\t\t\t\\$def",
      "\t\t\twhile \\$fin {",
      "\t\t\t\t\\$bl",
      "\t\t\t\t\\$incr",
      "\t\t\t}",
      "\t\t}}",
      "\t}",
      "\tuse crate::monoid::Monoid;",
      "\tuse std::fmt::{self, Debug};",
      "\tuse std::ops::{",
      "\t\tBound::{Excluded, Included, Unbounded},",
      "\t\tDeref, DerefMut, RangeBounds,",
      "\t};",
      "\t/// # SegmentTree2D (Monoid)",
      "\t/// - 2次元セグメント木",
      "\tpub struct SegmentTree2D<M: Monoid> {",
      "\t\tpub oh: usize,",
      "\t\tpub ow: usize,",
      "\t\tpub data: Vec<M::Val>,",
      "\t}",
      "\timpl<M: Monoid> SegmentTree2D<M> {",
      "\t\t#[inline]",
      "\t\tfn parse_range<R: RangeBounds<usize>>(&self, range: &R, max: usize) -> Option<(usize, usize)> {",
      "\t\t\tlet start = match range.start_bound() {",
      "\t\t\t\tUnbounded => 0,",
      "\t\t\t\tExcluded(&v) => v + 1,",
      "\t\t\t\tIncluded(&v) => v,",
      "\t\t\t};",
      "\t\t\tlet end = match range.end_bound() {",
      "\t\t\t\tUnbounded => max,",
      "\t\t\t\tExcluded(&v) => v,",
      "\t\t\t\tIncluded(&v) => v + 1,",
      "\t\t\t};",
      "\t\t\tif start <= end && end <= max {",
      "\t\t\t\tSome((start, end))",
      "\t\t\t} else {",
      "\t\t\t\tNone",
      "\t\t\t}",
      "\t\t}",
      "\t\t#[inline]",
      "\t\tfn idx(&self, i: usize, j: usize) -> usize {",
      "\t\t\t2 * self.ow * i + j",
      "\t\t}",
      "\t\t/// セグメント木を初期化する",
      "\t\tpub fn new(H: usize, W: usize) -> Self {",
      "\t\t\tlet oh = H.next_power_of_two();",
      "\t\t\tlet ow = W.next_power_of_two();",
      "\t\t\tSelf {",
      "\t\t\t\toh,",
      "\t\t\t\tow,",
      "\t\t\t\tdata: vec![M::E; 4 * oh * ow],",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 座標 `(r,c)` の値を `x` に更新する",
      "\t\tpub fn update(&mut self, mut r: usize, mut c: usize, x: M::Val) {",
      "\t\t\tr += self.oh;",
      "\t\t\tc += self.ow;",
      "\t\t\tlet idx = self.idx(r, c);",
      "\t\t\tself.data[idx] = x;",
      "\t\t\t// col方向の更新",
      "\t\t\tcfor! {let mut i = r >> 1; i > 0; i >>= 1;; {",
      "\t\t\t\tlet idx = self.idx(i, c);",
      "\t\t\t\tself.data[idx] = M::op(",
      "\t\t\t\t\t&self.data[self.idx(2 * i, c)],",
      "\t\t\t\t\t&self.data[self.idx(2 * i + 1, c)],",
      "\t\t\t\t);",
      "\t\t\t}}",
      "\t\t\t// row方向の更新",
      "\t\t\tcfor! {let mut i = r; i > 0; i >>= 1;; {",
      "\t\t\t\tcfor! {let mut j = c >> 1; j > 0; j >>= 1;; {",
      "\t\t\t\t\tlet idx = self.idx(i, j);",
      "\t\t\t\t\tself.data[idx] = M::op(",
      "\t\t\t\t\t\t&self.data[self.idx(i, 2 * j)],",
      "\t\t\t\t\t\t&self.data[self.idx(i, 2 * j + 1)],",
      "\t\t\t\t\t);",
      "\t\t\t\t}}",
      "\t\t\t}}",
      "\t\t}",
      "\t\t/// 可変な参照を返す",
      "\t\tpub fn get_mut(&mut self, r: usize, c: usize) -> Option<ValMut<'_, M>> {",
      "\t\t\tif r < self.oh && c < self.ow {",
      "\t\t\t\tlet old_val = self.data[self.idx(r + self.oh, c + self.ow)].clone();",
      "\t\t\t\tSome(ValMut {",
      "\t\t\t\t\tsegtree: self,",
      "\t\t\t\t\tr,",
      "\t\t\t\t\tc,",
      "\t\t\t\t\tnew_val: old_val,",
      "\t\t\t\t})",
      "\t\t\t} else {",
      "\t\t\t\tNone",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// row方向での集約を行う",
      "\t\tfn aggregate_row(&self, r: usize, mut cs: usize, mut ce: usize) -> M::Val {",
      "\t\t\t// 集約",
      "\t\t\tlet mut res = M::E;",
      "\t\t\twhile cs < ce {",
      "\t\t\t\tif cs & 1 == 1 {",
      "\t\t\t\t\tres = M::op(&res, &self.data[self.idx(r, cs)]);",
      "\t\t\t\t\tcs += 1;",
      "\t\t\t\t}",
      "\t\t\t\tif ce & 1 == 1 {",
      "\t\t\t\t\tce -= 1;",
      "\t\t\t\t\tres = M::op(&res, &self.data[self.idx(r, ce)]);",
      "\t\t\t\t}",
      "\t\t\t\tcs >>= 1;",
      "\t\t\t\tce >>= 1;",
      "\t\t\t}",
      "\t\t\tres",
      "\t\t}",
      "\t\t/// 区間の集約を行う",
      "\t\tpub fn get_range<R, C>(&self, row: R, col: C) -> M::Val",
      "\t\twhere",
      "\t\t\tR: RangeBounds<usize> + fmt::Debug,",
      "\t\t\tC: RangeBounds<usize> + fmt::Debug,",
      "\t\t{",
      "\t\t\tlet Some((mut rs, mut re)) = self.parse_range(&row, self.oh) else {",
      "\t\t\t\tpanic!(\"The given range is wrong (row): {:?}\", row);",
      "\t\t\t};",
      "\t\t\tlet Some((mut cs, mut ce)) = self.parse_range(&col, self.ow) else {",
      "\t\t\t\tpanic!(\"The given range is wrong (col): {:?}\", col);",
      "\t\t\t};",
      "\t\t\trs += self.oh;",
      "\t\t\tre += self.oh;",
      "\t\t\tcs += self.ow;",
      "\t\t\tce += self.ow;",
      "\t\t\t// 値の取得",
      "\t\t\tlet mut res = M::E;",
      "\t\t\twhile rs < re {",
      "\t\t\t\tif rs & 1 == 1 {",
      "\t\t\t\t\tres = M::op(&res, &self.aggregate_row(rs, cs, ce));",
      "\t\t\t\t\trs += 1;",
      "\t\t\t\t}",
      "\t\t\t\tif re & 1 == 1 {",
      "\t\t\t\t\tre -= 1;",
      "\t\t\t\t\tres = M::op(&res, &self.aggregate_row(re, cs, ce));",
      "\t\t\t\t}",
      "\t\t\t\trs >>= 1;",
      "\t\t\t\tre >>= 1;",
      "\t\t\t}",
      "\t\t\tres",
      "\t\t}",
      "\t}",
      "\timpl<M: Monoid> From<&Vec<Vec<M::Val>>> for SegmentTree2D<M> {",
      "\t\tfn from(src: &Vec<Vec<M::Val>>) -> Self {",
      "\t\t\tlet (H, W) = (src.len(), src[0].len());",
      "\t\t\tlet mut seg = SegmentTree2D::new(H, W);",
      "\t\t\tlet (oh, ow) = (seg.oh, seg.ow);",
      "\t\t\t// セグ木の値を埋める",
      "\t\t\tfor i in 0..H {",
      "\t\t\t\tfor j in 0..W {",
      "\t\t\t\t\tlet idx = seg.idx(oh + i, ow + j);",
      "\t\t\t\t\tseg.data[idx] = src[i][j].clone();",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\t// col方向の集約",
      "\t\t\tfor j in ow..2 * ow {",
      "\t\t\t\tfor i in (1..oh).rev() {",
      "\t\t\t\t\tlet idx = seg.idx(i, j);",
      "\t\t\t\t\tseg.data[idx] = M::op(",
      "\t\t\t\t\t\t&seg.data[seg.idx(2 * i, j)],",
      "\t\t\t\t\t\t&seg.data[seg.idx(2 * i + 1, j)],",
      "\t\t\t\t\t);",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\t// row方向の集約",
      "\t\t\tfor i in 0..2 * oh {",
      "\t\t\t\tfor j in (1..ow).rev() {",
      "\t\t\t\t\tlet idx = seg.idx(i, j);",
      "\t\t\t\t\tseg.data[idx] = M::op(",
      "\t\t\t\t\t\t&seg.data[seg.idx(i, 2 * j)],",
      "\t\t\t\t\t\t&seg.data[seg.idx(i, 2 * j + 1)],",
      "\t\t\t\t\t);",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\tseg",
      "\t\t}",
      "\t}",
      "\tpub struct ValMut<'a, M: 'a + Monoid> {",
      "\t\tsegtree: &'a mut SegmentTree2D<M>,",
      "\t\tr: usize,",
      "\t\tc: usize,",
      "\t\tnew_val: M::Val,",
      "\t}",
      "\timpl<M: Monoid> fmt::Debug for ValMut<'_, M> {",
      "\t\tfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "\t\t\tf.debug_struct(\"ValMut\")",
      "\t\t\t\t.field(\"r\", &self.r)",
      "\t\t\t\t.field(\"c\", &self.c)",
      "\t\t\t\t.field(\"new_val\", &self.new_val)",
      "\t\t\t\t.finish()",
      "\t\t}",
      "\t}",
      "\timpl<M: Monoid> Drop for ValMut<'_, M> {",
      "\t\tfn drop(&mut self) {",
      "\t\t\tself.segtree.update(self.r, self.c, self.new_val.clone());",
      "\t\t}",
      "\t}",
      "\timpl<M: Monoid> Deref for ValMut<'_, M> {",
      "\t\ttype Target = M::Val;",
      "\t\tfn deref(&self) -> &Self::Target {",
      "\t\t\t&self.new_val",
      "\t\t}",
      "\t}",
      "\timpl<M: Monoid> DerefMut for ValMut<'_, M> {",
      "\t\tfn deref_mut(&mut self) -> &mut Self::Target {",
      "\t\t\t&mut self.new_val",
      "\t\t}",
      "\t}",
      "\timpl<M> SegmentTree2D<M>",
      "\twhere",
      "\t\tM: Monoid,",
      "\t\tM::Val: Debug,",
      "\t{",
      "\t\t/// セグ木を簡易的に表示する",
      "\t\tpub fn show(&self) -> String {",
      "\t\t\tlet mut res = String::new();",
      "\t\t\tlet H = self.oh;",
      "\t\t\tlet W = self.ow;",
      "\t\t\tlet idx = |r: usize, c: usize| -> usize { 2 * r * W + c };",
      "\t\t\tlet mut r = 1;",
      "\t\t\tlet mut h = 1;",
      "\t\t\tlet mut logh = 0;",
      "\t\t\twhile r + h <= 2 * H {",
      "\t\t\t\tfor i in 1..=h {",
      "\t\t\t\t\tlet mut c = 1;",
      "\t\t\t\t\tlet mut w = 1;",
      "\t\t\t\t\twhile c + w <= 2 * W {",
      "\t\t\t\t\t\tres += &format!(",
      "\t\t\t\t\t\t\t\"{}{:?}\\n\",",
      "\t\t\t\t\t\t\t\"  \".repeat(logh),",
      "\t\t\t\t\t\t\t&self.data[idx(r + i - 1, c)..idx(r + i - 1, c + w)]",
      "\t\t\t\t\t\t);",
      "\t\t\t\t\t\tc += w;",
      "\t\t\t\t\t\tw <<= 1;",
      "\t\t\t\t\t}",
      "\t\t\t\t}",
      "\t\t\t\tr += h;",
      "\t\t\t\th <<= 1;",
      "\t\t\t\tlogh += 1;",
      "\t\t\t}",
      "\t\t\tres",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "二次元セグメント木\n- 参考：[二次元セグメント木 - Nyaan's Library](https://nyaannyaan.github.io/library/data-structure-2d/2d-segment-tree.hpp.html)"
  },
  "bit.rs": {
    "prefix": "bit",
    "body": [
      "mod bit {",
      "\t#![allow(dead_code)]",
      "\t//! BinaryIndexedTree / FenwickTree",
      "\tuse std::{",
      "\t\tfmt::Debug,",
      "\t\tops::{",
      "\t\t\tBound::{Excluded, Included, Unbounded},",
      "\t\t\tRangeBounds,",
      "\t\t},",
      "\t};",
      "\t/// # Monoid",
      "\t/// - モノイド",
      "\tpub trait Monoid {",
      "\t\t/// 値の型",
      "\t\ttype Val: Debug + Clone + PartialEq;",
      "\t\t/// 単位元",
      "\t\tconst E: Self::Val;",
      "\t\t/// 演算",
      "\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val;",
      "\t}",
      "\t/// モノイドに対する逆元の実装",
      "\tpub trait InversableMonoid: Monoid {",
      "\t\tfn inv(val: &Self::Val) -> Self::Val;",
      "\t}",
      "\t/// モノイドに対する順序の実装",
      "\tpub trait OrderedMonoid: Monoid {",
      "\t\tfn lt(left: &Self::Val, right: &Self::Val) -> bool;",
      "\t\tfn le(left: &Self::Val, right: &Self::Val) -> bool;",
      "\t}",
      "\t/// # BinaryIndexedTree",
      "\t/// - `0-indexed`なインターフェースを持つBIT",
      "\tpub struct BIT<T: Monoid> {",
      "\t\tpub size: usize,",
      "\t\tarr: Vec<T::Val>,",
      "\t}",
      "\timpl<T: Monoid> BIT<T> {",
      "\t\t#[inline]",
      "\t\tfn lsb(x: usize) -> usize {",
      "\t\t\tx & x.wrapping_neg()",
      "\t\t}",
      "\t\t/// BITの初期化を行う",
      "\t\t/// - `n`: 列の長さ",
      "\t\tpub fn new(n: usize) -> Self {",
      "\t\t\tBIT {",
      "\t\t\t\tsize: n,",
      "\t\t\t\tarr: vec![T::E; n + 1],",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 一点加算を行う",
      "\t\t/// - `i`: 加算を行うインデックス（`0-indexed`）",
      "\t\t/// - `x`: 加算する値",
      "\t\tpub fn add(&mut self, mut i: usize, x: T::Val) {",
      "\t\t\ti += 1;",
      "\t\t\twhile i <= self.size {",
      "\t\t\t\tself.arr[i] = T::op(&self.arr[i], &x);",
      "\t\t\t\ti += Self::lsb(i);",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 先頭からの和を求める",
      "\t\t/// - `i`: 区間`[0,i)`に対しての総和（`0-indexed`）",
      "\t\tpub fn prefix_sum(&self, mut i: usize) -> T::Val {",
      "\t\t\tlet mut res = T::E;",
      "\t\t\twhile i != 0 {",
      "\t\t\t\tres = T::op(&res, &self.arr[i]);",
      "\t\t\t\ti -= Self::lsb(i);",
      "\t\t\t}",
      "\t\t\tres",
      "\t\t}",
      "\t}",
      "\timpl<T: InversableMonoid> BIT<T> {",
      "\t\t#[inline]",
      "\t\tfn parse_range<R: RangeBounds<usize>>(&self, range: R) -> Option<(usize, usize)> {",
      "\t\t\tlet start = match range.start_bound() {",
      "\t\t\t\tUnbounded => 0,",
      "\t\t\t\tExcluded(&v) => v + 1,",
      "\t\t\t\tIncluded(&v) => v,",
      "\t\t\t}",
      "\t\t\t.min(self.size);",
      "\t\t\tlet end = match range.end_bound() {",
      "\t\t\t\tUnbounded => self.size,",
      "\t\t\t\tExcluded(&v) => v,",
      "\t\t\t\tIncluded(&v) => v + 1,",
      "\t\t\t}",
      "\t\t\t.min(self.size);",
      "\t\t\tif start <= end {",
      "\t\t\t\tSome((start, end))",
      "\t\t\t} else {",
      "\t\t\t\tNone",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 任意の区間の和を求める",
      "\t\t/// - `range`: 区間を表すRangeオブジェクト",
      "\t\tpub fn sum<R: RangeBounds<usize>>(&self, range: R) -> T::Val {",
      "\t\t\tif let Some((i, j)) = self.parse_range(range) {",
      "\t\t\t\tT::op(&self.prefix_sum(j), &T::inv(&self.prefix_sum(i)))",
      "\t\t\t} else {",
      "\t\t\t\tT::E",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\timpl<T: Monoid> From<&Vec<T::Val>> for BIT<T> {",
      "\t\t/// ベクターの参照からBITを作成",
      "\t\tfn from(src: &Vec<T::Val>) -> Self {",
      "\t\t\tlet size = src.len();",
      "\t\t\tlet mut arr = vec![T::E; size + 1];",
      "\t\t\tfor i in 1..=size {",
      "\t\t\t\tlet x = src[i - 1].clone();",
      "\t\t\t\tarr[i] = T::op(&arr[i], &x);",
      "\t\t\t\tlet j = i + Self::lsb(i);",
      "\t\t\t\tif j < size + 1 {",
      "\t\t\t\t\tarr[j] = T::op(&arr[j], &arr[i].clone());",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\tSelf { size, arr }",
      "\t\t}",
      "\t}",
      "\timpl<T: OrderedMonoid> BIT<T> {",
      "\t\t/// `lower_bound`/`upper_bound`を共通化した実装",
      "\t\tfn binary_search<F>(&self, w: T::Val, compare: F) -> usize",
      "\t\twhere",
      "\t\t\tF: Fn(&T::Val, &T::Val) -> bool,",
      "\t\t{",
      "\t\t\tlet mut sum = T::E;",
      "\t\t\tlet mut idx = 0;",
      "\t\t\tlet mut d = self.size.next_power_of_two() / 2;",
      "\t\t\twhile d != 0 {",
      "\t\t\t\tif idx + d <= self.size {",
      "\t\t\t\t\tlet nxt = T::op(&sum, &self.arr[idx + d]);",
      "\t\t\t\t\tif compare(&nxt, &w) {",
      "\t\t\t\t\t\tsum = nxt;",
      "\t\t\t\t\t\tidx += d;",
      "\t\t\t\t\t}",
      "\t\t\t\t}",
      "\t\t\t\td >>= 1;",
      "\t\t\t}",
      "\t\t\tidx",
      "\t\t}",
      "\t\t/// `a_0 + a_1 + ... + a_i >= w`となる最小の`i`を求める",
      "\t\tpub fn lower_bound(&self, w: T::Val) -> usize {",
      "\t\t\tself.binary_search(w, T::lt)",
      "\t\t}",
      "\t\t/// `a_0 + a_1 + ... + a_i > w`となる最小の`i`を求める",
      "\t\tpub fn upper_bound(&self, w: T::Val) -> usize {",
      "\t\t\tself.binary_search(w, T::le)",
      "\t\t}",
      "\t}",
      "\timpl<T: InversableMonoid> Debug for BIT<T> {",
      "\t\tfn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
      "\t\t\twrite!(f, \"BIT {{ [\")?;",
      "\t\t\tfor i in 0..self.size - 1 {",
      "\t\t\t\twrite!(f, \"{:?}, \", self.sum(i..i + 1))?;",
      "\t\t\t}",
      "\t\t\twrite!(f, \"{:?}] }}\", self.sum(self.size - 1..self.size))",
      "\t\t}",
      "\t}",
      "\tpub mod Alg {",
      "\t\tuse super::{InversableMonoid, Monoid, OrderedMonoid};",
      "\t\t#[derive(Debug)]",
      "\t\tpub struct Add;",
      "\t\timpl Monoid for Add {",
      "\t\t\ttype Val = isize;",
      "\t\t\tconst E: Self::Val = 0;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tleft + right",
      "\t\t\t}",
      "\t\t}",
      "\t\timpl InversableMonoid for Add {",
      "\t\t\tfn inv(val: &Self::Val) -> Self::Val {",
      "\t\t\t\t-val",
      "\t\t\t}",
      "\t\t}",
      "\t\timpl OrderedMonoid for Add {",
      "\t\t\tfn lt(left: &Self::Val, right: &Self::Val) -> bool {",
      "\t\t\t\tleft < right",
      "\t\t\t}",
      "\t\t\tfn le(left: &Self::Val, right: &Self::Val) -> bool {",
      "\t\t\t\tleft <= right",
      "\t\t\t}",
      "\t\t}",
      "\t\t#[derive(Debug)]",
      "\t\tpub struct UAdd;",
      "\t\timpl Monoid for UAdd {",
      "\t\t\ttype Val = usize;",
      "\t\t\tconst E: Self::Val = 0;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tleft.wrapping_add(*right)",
      "\t\t\t}",
      "\t\t}",
      "\t\timpl InversableMonoid for UAdd {",
      "\t\t\tfn inv(val: &Self::Val) -> Self::Val {",
      "\t\t\t\tval.wrapping_neg()",
      "\t\t\t}",
      "\t\t}",
      "\t\timpl OrderedMonoid for UAdd {",
      "\t\t\tfn lt(left: &Self::Val, right: &Self::Val) -> bool {",
      "\t\t\t\tleft < right",
      "\t\t\t}",
      "\t\t\tfn le(left: &Self::Val, right: &Self::Val) -> bool {",
      "\t\t\t\tleft <= right",
      "\t\t\t}",
      "\t\t}",
      "\t\t#[derive(Debug)]",
      "\t\tpub struct Mul;",
      "\t\timpl Monoid for Mul {",
      "\t\t\ttype Val = isize;",
      "\t\t\tconst E: Self::Val = 1;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tleft + right",
      "\t\t\t}",
      "\t\t}",
      "\t\t#[derive(Debug)]",
      "\t\tpub struct Xor;",
      "\t\timpl Monoid for Xor {",
      "\t\t\ttype Val = usize;",
      "\t\t\tconst E: Self::Val = 0;",
      "\t\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
      "\t\t\t\tleft ^ right",
      "\t\t\t}",
      "\t\t}",
      "\t\timpl InversableMonoid for Xor {",
      "\t\t\tfn inv(val: &Self::Val) -> Self::Val {",
      "\t\t\t\t*val",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "BinaryIndexedTree / FenwickTree"
  },
  "lcs.rs": {
    "prefix": "lcs",
    "body": [
      "mod lcs {",
      "\t#![allow(dead_code)]",
      "\t//! 最長共通部分列",
      "\t/// `a < b` のとき、`a`を`b`に置き換え、trueを返す",
      "\tmacro_rules! chmax {",
      "\t\t( \\$a:expr, \\$b:expr ) => {{",
      "\t\t\tif \\$a < \\$b {",
      "\t\t\t\t\\$a = \\$b;",
      "\t\t\t\ttrue",
      "\t\t\t} else {",
      "\t\t\t\tfalse",
      "\t\t\t}",
      "\t\t}};",
      "\t}",
      "\t/// ## LCS",
      "\t/// 最長共通部分列を得る",
      "\t/// 計算量：O(NM)",
      "\tpub fn LCS<T: std::cmp::PartialEq>(A: &[T], B: &[T]) -> usize {",
      "\t\tlet (la, lb) = (A.len(), B.len());",
      "\t\tlet mut dp = vec![vec![0; lb + 1]; la + 1];",
      "\t\tfor (i, a) in A.iter().enumerate() {",
      "\t\t\tfor (j, b) in B.iter().enumerate() {",
      "\t\t\t\tif a == b {",
      "\t\t\t\t\tchmax!(dp[i + 1][j + 1], dp[i][j] + 1);",
      "\t\t\t\t}",
      "\t\t\t\tchmax!(dp[i + 1][j + 1], dp[i + 1][j]);",
      "\t\t\t\tchmax!(dp[i + 1][j + 1], dp[i][j + 1]);",
      "\t\t\t}",
      "\t\t}",
      "\t\tdp[la][lb]",
      "\t}",
      "\t/// ## LCS with Vector",
      "\t/// 最長共通部分列を得る",
      "\t/// 計算量：O(NM)",
      "\tpub fn LCS_with_Vec<T: std::cmp::PartialEq + Copy>(A: &[T], B: &[T]) -> Vec<T> {",
      "\t\tlet (la, lb) = (A.len(), B.len());",
      "\t\tlet mut dp = vec![vec![0; lb + 1]; la + 1];",
      "\t\tfor (i, a) in A.iter().enumerate() {",
      "\t\t\tfor (j, b) in B.iter().enumerate() {",
      "\t\t\t\tif a == b {",
      "\t\t\t\t\tchmax!(dp[i + 1][j + 1], dp[i][j] + 1);",
      "\t\t\t\t}",
      "\t\t\t\tchmax!(dp[i + 1][j + 1], dp[i + 1][j]);",
      "\t\t\t\tchmax!(dp[i + 1][j + 1], dp[i][j + 1]);",
      "\t\t\t}",
      "\t\t}",
      "\t\tlet mut res: Vec<T> = vec![];",
      "\t\tlet (mut cur, mut col) = (0, 0);",
      "\t\t'outer: for i in 0..la {",
      "\t\t\tfor j in col..lb {",
      "\t\t\t\tif cur == dp[i][j] && dp[i][j] < dp[i + 1][j + 1] {",
      "\t\t\t\t\tres.push(A[i]);",
      "\t\t\t\t\tcur += 1;",
      "\t\t\t\t\tcol = j + 1;",
      "\t\t\t\t}",
      "\t\t\t\tif cur == dp[la][lb] {",
      "\t\t\t\t\t// LCSの長さに達したら終了",
      "\t\t\t\t\tbreak 'outer;",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t}",
      "\t\tres",
      "\t}",
      "}"
    ],
    "description": "最長共通部分列"
  },
  "modint.rs": {
    "prefix": "modint",
    "body": [
      "mod modint {",
      "\t#![allow(dead_code)]",
      "\t//! Modintの構造体",
      "\tpub use modint::*;",
      "\tpub type M998 = Modint<998244353>;",
      "\tpub type M107 = Modint<1000000007>;",
      "\t// 適当な素数",
      "\tpub type P1 = Modint<938472061>;",
      "\tpub type P2 = Modint<958472071>;",
      "\t#[rustfmt::skip]",
      "\tpub mod modint {",
      "\t\tfn sqrt(n: usize) -> usize { (n as f64).sqrt() as usize }",
      "\t\tuse std::{fmt::{Debug, Display}, iter::{Sum, Product}, mem::replace, num::ParseIntError, ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign}, str::FromStr};",
      "\t\t#[derive(Clone, Copy, Default, PartialEq, Eq, Hash)] pub struct Modint<const MOD: usize>(pub usize);",
      "\t\timpl<const MOD: usize> Modint<MOD> { pub fn new(n: usize) -> Self { Self(if n < MOD { n } else { n % MOD }) }",
      "\t\tpub fn from_str(s: &str) -> Self { s.chars().fold(0.into(), |n, c| n * 10 + c.to_digit(10).unwrap() as usize) }",
      "\t\tpub fn from_isize(n: isize) -> Self { Self::new((MOD as isize + n % MOD as isize) as usize) }",
      "\t\tpub fn rational_reconstruction(&self) -> Option<(usize, usize)> { let N = sqrt(MOD / 2); let mut v = (MOD, 0); let mut w = (self.0, 1);",
      "\t\twhile w.0 > N { let q = v.0.div_euclid(w.0); let z = (v.0 - q * w.0, v.1 + q * w.1); v = replace(&mut w, z); } (w.0 <= N && w.1 <= N).then_some(w) } }",
      "\t\timpl<const MOD: usize> Neg for Modint<MOD> { type Output = Self; fn neg(self) -> Self { Modint(if self.0 == 0 { 0 } else { MOD - self.0 }) } }",
      "\t\timpl<const MOD: usize> Add for Modint<MOD> { type Output = Self; fn add(self, rhs: Self) -> Self { let mut res = self.0 + rhs.0; if res >= MOD { res -= MOD; } Modint(res) } }",
      "\t\timpl<const MOD: usize> Sub for Modint<MOD> { type Output = Self; fn sub(self, rhs: Self) -> Self { self + (- rhs) } }",
      "\t\timpl<const MOD: usize> Mul for Modint<MOD> { type Output = Self; fn mul(self, rhs: Self) -> Self { Modint(self.0 * rhs.0 % MOD) } }",
      "\t\timpl<const MOD: usize> Div for Modint<MOD> { type Output = Self; fn div(self, rhs: Self) -> Self { self * rhs.inv() } }",
      "\t\timpl<const MOD: usize> AddAssign for Modint<MOD> { fn add_assign(&mut self, rhs: Self) { self.0 = (*self + rhs).0 } }",
      "\t\timpl<const MOD: usize> SubAssign for Modint<MOD> { fn sub_assign(&mut self, rhs: Self) { self.0 = (*self - rhs).0 } }",
      "\t\timpl<const MOD: usize> MulAssign for Modint<MOD> { fn mul_assign(&mut self, rhs: Self) { self.0 = (*self * rhs).0 } }",
      "\t\timpl<const MOD: usize> DivAssign for Modint<MOD> { fn div_assign(&mut self, rhs: Self) { self.0 = (*self / rhs).0 } }",
      "\t\timpl<const MOD: usize> From<usize> for Modint<MOD> { fn from(value: usize) -> Self { Modint::new(value) } }",
      "\t\timpl<const MOD: usize> Add<usize> for Modint<MOD> { type Output = Self; fn add(self, rhs: usize) -> Self { let mut res = self.0 + rhs; if res >= MOD {res -= MOD;} Modint(res) } }",
      "\t\timpl<const MOD: usize> Sub<usize> for Modint<MOD> { type Output = Self; fn sub(self, rhs: usize) -> Self { self - Modint::new(rhs) } }",
      "\t\timpl<const MOD: usize> Mul<usize> for Modint<MOD> { type Output = Self; fn mul(self, rhs: usize) -> Self { self * Modint::new(rhs) } }",
      "\t\timpl<const MOD: usize> Div<usize> for Modint<MOD> { type Output = Self; fn div(self, rhs: usize) -> Self { self / Modint::new(rhs) } }",
      "\t\timpl<const MOD: usize> AddAssign<usize> for Modint<MOD> { fn add_assign(&mut self, rhs: usize) { *self += Modint::new(rhs) } }",
      "\t\timpl<const MOD: usize> SubAssign<usize> for Modint<MOD> { fn sub_assign(&mut self, rhs: usize) { *self -= Modint::new(rhs) } }",
      "\t\timpl<const MOD: usize> MulAssign<usize> for Modint<MOD> { fn mul_assign(&mut self, rhs: usize) { *self *= Modint::new(rhs) } }",
      "\t\timpl<const MOD: usize> DivAssign<usize> for Modint<MOD> { fn div_assign(&mut self, rhs: usize) { *self /= Modint::new(rhs) } }",
      "\t\timpl<const MOD: usize> Display for Modint<MOD> { fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, \"{}\", self.0) } }",
      "\t\timpl<const MOD: usize> PartialEq<usize> for Modint<MOD> { fn eq(&self, other: &usize) -> bool { self == &Modint::new(*other) } }",
      "\t\timpl<const MOD: usize> FromStr for Modint<MOD> { type Err = ParseIntError; fn from_str(s: &str) -> Result<Self, Self::Err> { Ok(Self::from_str(s)) } }",
      "\t\timpl<const MOD: usize> Debug for Modint<MOD> { fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { match self.rational_reconstruction() { Some((n, d)) => if d > 1 { write!(f, \"Modint({n}/{d})\") } else { write!(f, \"Modint({n})\") } _ => write!(f, \"Modint({})\", self.0) } } }",
      "\t\tpub trait Fp { fn pow(&self, rhs: usize) -> Self; fn inv(&self) -> Self; }",
      "\t\timpl<const MOD: usize> Fp for Modint<MOD> { fn pow(&self, rhs: usize) -> Self { let (mut a, mut b) = (self.0, rhs); let mut res = 1; while b > 0 { if b & 1 == 1 { res = (res * a) % MOD; } a = (a * a) % MOD; b >>= 1u32; } Modint(res) } fn inv(&self) -> Self { self.pow(MOD - 2) } }",
      "\t\timpl<const MOD: usize> Sum<Modint<MOD>> for Modint<MOD> { fn sum<I: Iterator<Item = Modint<MOD>>>(iter: I) -> Self { iter.fold(Modint::<MOD>(0), |acc, x| acc + x) } }",
      "\t\timpl<const MOD: usize> Product<Modint<MOD>> for Modint<MOD> { fn product<I: Iterator<Item = Modint<MOD>>>(iter: I) -> Self { iter.fold(Modint::<MOD>(1), |acc, x| acc * x) } }",
      "\t}",
      "}"
    ],
    "description": "Modintの構造体"
  },
  "frac.rs": {
    "prefix": "frac",
    "body": [
      "mod frac {",
      "\t#![allow(dead_code)]",
      "\t//! 比較を実装した分数の実装",
      "\tuse std::{cmp::Ordering, ops::Mul};",
      "\t/// 分数を表す構造体",
      "\t/// - `Frac(a, b)` := a / b",
      "\t#[derive(Debug, Clone, Copy)]",
      "\tpub struct Frac<T>(pub T, pub T);",
      "\timpl<T> PartialEq for Frac<T>",
      "\twhere",
      "\t\tT: Clone + Copy + Ord + Mul<Output = T>,",
      "\t{",
      "\t\tfn eq(&self, other: &Self) -> bool {",
      "\t\t\tlet &Frac(a1, b1) = self;",
      "\t\t\tlet &Frac(a2, b2) = other;",
      "\t\t\ta1 * b2 == a2 * b1",
      "\t\t}",
      "\t}",
      "\timpl<T> Eq for Frac<T>",
      "\twhere",
      "\t\tT: Clone + Copy + Ord + Mul<Output = T>,",
      "\t{",
      "\t\tfn assert_receiver_is_total_eq(&self) {}",
      "\t}",
      "\timpl<T> PartialOrd for Frac<T>",
      "\twhere",
      "\t\tT: Clone + Copy + Ord + Mul<Output = T>,",
      "\t{",
      "\t\tfn partial_cmp(&self, other: &Self) -> Option<Ordering> {",
      "\t\t\tlet &Frac(a1, b1) = self;",
      "\t\t\tlet &Frac(a2, b2) = other;",
      "\t\t\t(a1 * b2).partial_cmp(&(a2 * b1))",
      "\t\t}",
      "\t}",
      "\timpl<T> Ord for Frac<T>",
      "\twhere",
      "\t\tT: Clone + Copy + Ord + Mul<Output = T>,",
      "\t{",
      "\t\tfn cmp(&self, other: &Self) -> Ordering {",
      "\t\t\tself.partial_cmp(other).unwrap()",
      "\t\t}",
      "\t}",
      "\t// TODO: Add, Mul等の実装",
      "}"
    ],
    "description": "比較を実装した分数の実装"
  },
  "macro_chmin.rs": {
    "prefix": "macro_chmin",
    "body": [
      "mod macro_chmin {",
      "\t#![allow(dead_code)]",
      "\t//! chminの実装",
      "\t/// `chmin!{x1, x2, ..., xn}`:`x1`,`x2`,...,`xn`のうち最小のものを、`x1`に代入する",
      "\t/// - 代入があったとき、`true`を返す",
      "\t#[macro_export]",
      "\tmacro_rules! chmin {",
      "\t\t( \\$a:expr, \\$b:expr \\$(,)* ) => {{",
      "\t\t\tif \\$a > \\$b {",
      "\t\t\t\t\\$a = \\$b;",
      "\t\t\t\ttrue",
      "\t\t\t} else {",
      "\t\t\t\tfalse",
      "\t\t\t}",
      "\t\t}};",
      "\t\t( \\$a:expr, \\$b:expr, \\$c:expr \\$(,\\$other:expr)* \\$(,)* ) => {{",
      "\t\t\tchmin! {",
      "\t\t\t\t\\$a,",
      "\t\t\t\t(\\$b).min(\\$c)",
      "\t\t\t\t\\$(,\\$other)*",
      "\t\t\t}",
      "\t\t}};",
      "\t}",
      "}"
    ],
    "description": "chminの実装"
  },
  "comb.rs": {
    "prefix": "comb",
    "body": [
      "mod comb {",
      "\t#![allow(dead_code)]",
      "\t//! 二項係数を求める",
      "\tconst MOD: usize = 998_244_353;",
      "\t// const MOD: usize = 1_000_000_007;",
      "\t/// # Comb",
      "\t/// 二項係数を高速に求める",
      "\t/// - 前計算: `O(N)`",
      "\t/// - クエリ: `O(1)`",
      "\tpub struct Comb {",
      "\t\tfac: Vec<usize>,",
      "\t\tfinv: Vec<usize>,",
      "\t}",
      "\timpl Comb {",
      "\t\t/// サイズ`max_size`で配列を初期化する",
      "\t\tpub fn new(max_size: usize) -> Self {",
      "\t\t\tlet mut fac = vec![1; max_size];",
      "\t\t\tlet mut finv = vec![1; max_size];",
      "\t\t\tlet mut inv = vec![1; max_size];",
      "\t\t\tfor i in 2..max_size {",
      "\t\t\t\tfac[i] = fac[i - 1] * i % MOD;",
      "\t\t\t\tinv[i] = MOD - (MOD / i) * inv[MOD % i] % MOD;",
      "\t\t\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;",
      "\t\t\t}",
      "\t\t\tComb { fac, finv }",
      "\t\t}",
      "\t\t/// `nCr`を`MOD`で割った値を求める",
      "\t\tpub fn comb(&self, n: usize, r: usize) -> usize {",
      "\t\t\tif n < r {",
      "\t\t\t\treturn 0;",
      "\t\t\t}",
      "\t\t\tself.fac[n] * (self.finv[r] * self.finv[n - r] % MOD) % MOD",
      "\t\t}",
      "\t\t/// `nPr`を`MOD`で割った値を求める",
      "\t\tpub fn perm(&self, n: usize, r: usize) -> usize {",
      "\t\t\tif n < r {",
      "\t\t\t\treturn 0;",
      "\t\t\t}",
      "\t\t\tself.fac[n] * self.finv[n - r] % MOD",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "二項係数を求める"
  },
  "matrix_exp.rs": {
    "prefix": "matrix_exp",
    "body": [
      "mod matrix_exp {",
      "\t#![allow(dead_code)]",
      "\t//! 行列累乗",
      "\t// 定数",
      "\tpub const MOD: usize = 998244353;",
      "\t/* 行列累乗 */",
      "\tpub const DIM: usize = 4;",
      "\tpub type Vec = [usize; DIM];",
      "\tpub type Matrix = [[usize; DIM]; DIM];",
      "\tpub trait MatrixExp {",
      "\t\t/// ## e",
      "\t\t/// 単位行列を返す",
      "\t\tfn e() -> Self;",
      "\t\t/// ## apply",
      "\t\t/// ベクトル`x`と行列`A`について、`Ax`を返す",
      "\t\tfn dot(&self, other: Self) -> Self;",
      "\t\t/// ## pow",
      "\t\t/// 行列の累乗を返す（繰り返し2乗法）",
      "\t\tfn pow(&self, e: usize) -> Self;",
      "\t\t/// ## dot",
      "\t\t/// 行列のドット積",
      "\t\tfn apply(&self, vec: Vec) -> Vec;",
      "\t}",
      "\timpl MatrixExp for Matrix {",
      "\t\tfn e() -> Self {",
      "\t\t\tlet mut res = [[0; DIM]; DIM];",
      "\t\t\tfor i in 0..DIM {",
      "\t\t\t\tres[i][i] = 1;",
      "\t\t\t}",
      "\t\t\tres",
      "\t\t}",
      "\t\tfn apply(&self, vec: Vec) -> Vec {",
      "\t\t\tlet mut res = [0; DIM];",
      "\t\t\tfor i in 0..DIM {",
      "\t\t\t\tfor j in 0..DIM {",
      "\t\t\t\t\tres[i] += self[i][j] * vec[j] % MOD;",
      "\t\t\t\t\tres[i] %= MOD;",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\tres",
      "\t\t}",
      "\t\tfn pow(&self, mut e: usize) -> Self {",
      "\t\t\tlet mut res = Self::e();",
      "\t\t\tlet mut tmp = *self;",
      "\t\t\twhile e > 0 {",
      "\t\t\t\tif e & 1 == 1 {",
      "\t\t\t\t\tres = tmp.dot(res);",
      "\t\t\t\t}",
      "\t\t\t\ttmp = tmp.dot(tmp);",
      "\t\t\t\te >>= 1;",
      "\t\t\t}",
      "\t\t\tres",
      "\t\t}",
      "\t\tfn dot(&self, other: Self) -> Self {",
      "\t\t\tlet mut res = [[0; DIM]; DIM];",
      "\t\t\tfor i in 0..DIM {",
      "\t\t\t\tfor j in 0..DIM {",
      "\t\t\t\t\tfor k in 0..DIM {",
      "\t\t\t\t\t\tres[i][j] += self[i][k] * other[k][j] % MOD;",
      "\t\t\t\t\t\tres[i][j] %= MOD;",
      "\t\t\t\t\t}",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\tres",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "行列累乗"
  },
  "multiset_splay_tree.rs": {
    "prefix": "multiset_splay_tree",
    "body": [
      "mod multiset_splay_tree {",
      "\t#![allow(dead_code)]",
      "\t//! スプレー木のMultiSet",
      "\tuse std::iter::FromIterator;",
      "\tuse std::mem::swap;",
      "\tuse std::{cmp::Ordering, fmt::Debug};",
      "\t/// # Node",
      "\t#[derive(Debug, Clone)]",
      "\tpub struct Node<T: Ord + Debug> {",
      "\t\tpub key: T,",
      "\t\tpub left: Option<Box<Node<T>>>,",
      "\t\tpub right: Option<Box<Node<T>>>,",
      "\t\tpub id: usize,",
      "\t}",
      "\timpl<T: Ord + Debug> Node<T> {",
      "\t\tpub fn new(key: T, id: usize) -> Self {",
      "\t\t\tSelf {",
      "\t\t\t\tkey,",
      "\t\t\t\tleft: None,",
      "\t\t\t\tright: None,",
      "\t\t\t\tid,",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\t/// # MultiSet",
      "\t/// スプレー木のクラス",
      "\tpub struct MultiSet<T: Ord + Debug> {",
      "\t\tsize: usize,",
      "\t\tpub root: Option<Box<Node<T>>>,",
      "\t}",
      "\timpl<T> MultiSet<T>",
      "\twhere",
      "\t\tT: Ord + Clone + Debug,",
      "\t{",
      "\t\t/// `a <= b`の値を返す",
      "\t\t#[inline]",
      "\t\tfn le(a: &T, b: &T) -> bool {",
      "\t\t\tmatches!(a.cmp(b), Ordering::Less | Ordering::Equal)",
      "\t\t}",
      "\t\t/// `a < b`の値を返す",
      "\t\t#[inline]",
      "\t\tfn lt(a: &T, b: &T) -> bool {",
      "\t\t\tmatches!(a.cmp(b), Ordering::Less)",
      "\t\t}",
      "\t\t/// `a >= b`の値を返す",
      "\t\t#[inline]",
      "\t\tfn ge(a: &T, b: &T) -> bool {",
      "\t\t\tmatches!(a.cmp(b), Ordering::Equal | Ordering::Greater)",
      "\t\t}",
      "\t\t/// `a > b`の値を返す",
      "\t\t#[inline]",
      "\t\tfn gt(a: &T, b: &T) -> bool {",
      "\t\t\tmatches!(a.cmp(b), Ordering::Greater)",
      "\t\t}",
      "\t\tpub fn new() -> Self {",
      "\t\t\tSelf {",
      "\t\t\t\tsize: 0,",
      "\t\t\t\troot: None,",
      "\t\t\t}",
      "\t\t}",
      "\t\tpub fn len(&self) -> usize {",
      "\t\t\tself.size",
      "\t\t}",
      "\t\tpub fn is_empty(&self) -> bool {",
      "\t\t\tself.size == 0",
      "\t\t}",
      "\t\t/// ## get",
      "\t\t/// 値の検索を行う",
      "\t\t/// ### 戻り値",
      "\t\t/// - `Option<&T>`: キーに紐づいた値",
      "\t\tpub fn get(&mut self, key: &T) -> Option<&T> {",
      "\t\t\tlet lb = self.lower_bound(key);",
      "\t\t\tif lb.is_some_and(|k| k == key) {",
      "\t\t\t\tlb",
      "\t\t\t} else {",
      "\t\t\t\tNone",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// ## insert",
      "\t\t/// 値の挿入を行う。",
      "\t\tpub fn insert(&mut self, key: T) {",
      "\t\t\t// rootの取り出し",
      "\t\t\tlet root = self.root.take();",
      "\t\t\t// splay操作（一番右の要素）",
      "\t\t\tlet (mut tmp_root, _) = splay(root, &key, Self::le);",
      "\t\t\t// 挿入",
      "\t\t\tlet new_id = if tmp_root.is_some() && tmp_root.as_ref().unwrap().key == key {",
      "\t\t\t\ttmp_root.as_ref().unwrap().id + 1",
      "\t\t\t} else {",
      "\t\t\t\t1",
      "\t\t\t};",
      "\t\t\tself.root = Some(Box::new(Node::new(key.clone(), new_id)));",
      "\t\t\tif tmp_root.is_some() {",
      "\t\t\t\tmatch key.cmp(&tmp_root.as_ref().unwrap().key) {",
      "\t\t\t\t\tOrdering::Less | Ordering::Equal => {",
      "\t\t\t\t\t\tlet mut new_left = tmp_root.as_mut().unwrap().left.take();",
      "\t\t\t\t\t\tswap(&mut self.root.as_mut().unwrap().left, &mut new_left);",
      "\t\t\t\t\t\tswap(&mut self.root.as_mut().unwrap().right, &mut tmp_root);",
      "\t\t\t\t\t}",
      "\t\t\t\t\tOrdering::Greater => {",
      "\t\t\t\t\t\tlet mut new_right = tmp_root.as_mut().unwrap().right.take();",
      "\t\t\t\t\t\tswap(&mut self.root.as_mut().unwrap().right, &mut new_right);",
      "\t\t\t\t\t\tswap(&mut self.root.as_mut().unwrap().left, &mut tmp_root);",
      "\t\t\t\t\t}",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\t// 要素数の更新",
      "\t\t\tself.size += 1;",
      "\t\t}",
      "\t\t/// ## delete",
      "\t\t/// 値の削除",
      "\t\t/// ### 戻り値",
      "\t\t/// - `Option<T>`: 削除された値",
      "\t\tpub fn delete(&mut self, key: &T) -> Option<T> {",
      "\t\t\tif self.is_empty() {",
      "\t\t\t\treturn None;",
      "\t\t\t}",
      "\t\t\t// rootの取り出し",
      "\t\t\tlet root = self.root.take();",
      "\t\t\t// splay操作",
      "\t\t\t// tmp_root := keyより真に大きいノードのうち最小のもの",
      "\t\t\tlet (mut tmp_root, _) = splay(root, key, Self::le);",
      "\t\t\t// 値が存在しないとき",
      "\t\t\tif &tmp_root.as_ref().unwrap().key != key {",
      "\t\t\t\t// 値がないとき（Noneを返す）",
      "\t\t\t\tself.root = tmp_root;",
      "\t\t\t\treturn None;",
      "\t\t\t}",
      "\t\t\t// 削除",
      "\t\t\tif tmp_root.as_ref().unwrap().left.is_none() {",
      "\t\t\t\tswap(&mut self.root, &mut tmp_root.as_mut().unwrap().right);",
      "\t\t\t} else {",
      "\t\t\t\tlet root_left = tmp_root.as_mut().unwrap().left.take();",
      "\t\t\t\t// 左の子のうち最大の要素を新しい根に",
      "\t\t\t\tswap(&mut self.root, &mut splay(root_left, key, Self::lt).0);",
      "\t\t\t\t// 根の右側に子を付け替える",
      "\t\t\t\tswap(",
      "\t\t\t\t\t&mut self.root.as_mut().unwrap().right,",
      "\t\t\t\t\t&mut tmp_root.as_mut().unwrap().right,",
      "\t\t\t\t);",
      "\t\t\t}",
      "\t\t\tlet deleted = tmp_root.take();",
      "\t\t\t// 要素数の更新",
      "\t\t\tself.size -= 1;",
      "\t\t\tSome(deleted.unwrap().key)",
      "\t\t}",
      "\t\t/// ## count",
      "\t\t/// - 値`key`の要素の個数",
      "\t\tpub fn count(&mut self, key: &T) -> usize {",
      "\t\t\t// lower_boundを実行",
      "\t\t\tself.lower_bound(key);",
      "\t\t\t// rootのidを調べる",
      "\t\t\tself.root",
      "\t\t\t\t.as_ref()",
      "\t\t\t\t.filter(|node| &node.key == key)",
      "\t\t\t\t.map_or(0, |node| node.id)",
      "\t\t}",
      "\t\t/// ## lower_bound",
      "\t\t/// - `key`以上の最小の値を返す",
      "\t\tpub fn lower_bound(&mut self, key: &T) -> Option<&T> {",
      "\t\t\t// 根の取り出し",
      "\t\t\tlet root = self.root.take();",
      "\t\t\t// スプレー操作",
      "\t\t\tlet (new_root, is_found) = splay(root, key, Self::le);",
      "\t\t\tself.root = new_root;",
      "\t\t\tif is_found {",
      "\t\t\t\tSome(&self.root.as_ref().unwrap().key)",
      "\t\t\t} else {",
      "\t\t\t\tNone",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// ## upper_bound",
      "\t\t/// - `key`より大きい最小の値を返す",
      "\t\tpub fn upper_bound(&mut self, key: &T) -> Option<&T> {",
      "\t\t\t// 根の取り出し",
      "\t\t\tlet root = self.root.take();",
      "\t\t\t// スプレー操作",
      "\t\t\tlet (new_root, is_found) = splay(root, key, Self::lt);",
      "\t\t\tself.root = new_root;",
      "\t\t\tif is_found {",
      "\t\t\t\tSome(&self.root.as_ref().unwrap().key)",
      "\t\t\t} else {",
      "\t\t\t\tNone",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// ## lower_bound_rev",
      "\t\t/// - `key`以下の最大の値を返す",
      "\t\tpub fn lower_bound_rev(&mut self, key: &T) -> Option<&T> {",
      "\t\t\t// 根の取り出し",
      "\t\t\tlet root = self.root.take();",
      "\t\t\t// スプレー操作",
      "\t\t\tlet (new_root, is_found) = splay_rev(root, key, Self::ge);",
      "\t\t\tself.root = new_root;",
      "\t\t\tif is_found {",
      "\t\t\t\tSome(&self.root.as_ref().unwrap().key)",
      "\t\t\t} else {",
      "\t\t\t\tNone",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// ## upper_bound_rev",
      "\t\t/// - `key`未満の最大の値を返す",
      "\t\tpub fn upper_bound_rev(&mut self, key: &T) -> Option<&T> {",
      "\t\t\t// 根の取り出し",
      "\t\t\tlet root = self.root.take();",
      "\t\t\t// スプレー操作",
      "\t\t\tlet (new_root, is_found) = splay_rev(root, key, Self::gt);",
      "\t\t\tself.root = new_root;",
      "\t\t\tif is_found {",
      "\t\t\t\tSome(&self.root.as_ref().unwrap().key)",
      "\t\t\t} else {",
      "\t\t\t\tNone",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// ## to_vec",
      "\t\t/// 要素を順にVecとして取り出す",
      "\t\tpub fn to_vec(&self) -> Vec<&T> {",
      "\t\t\tlet mut res = vec![];",
      "\t\t\ttraverse(&self.root, &mut res);",
      "\t\t\tres",
      "\t\t}",
      "\t}",
      "\t/// ## traverse",
      "\t/// 順に取り出す",
      "\tfn traverse<'a, T: Ord + Debug>(root: &'a Option<Box<Node<T>>>, res: &mut Vec<&'a T>) {",
      "\t\tif root.is_none() {",
      "\t\t\treturn;",
      "\t\t}",
      "\t\t// 左の子を探索",
      "\t\ttraverse(&root.as_ref().unwrap().left, res);",
      "\t\t// 値を追加",
      "\t\tres.push(&root.as_ref().unwrap().key);",
      "\t\t// 右の子を探索",
      "\t\ttraverse(&root.as_ref().unwrap().right, res);",
      "\t}",
      "\t/// ## splay",
      "\t/// 比較関数`compare`を引数にとり、条件を満たす最小のノードを返す",
      "\tfn splay<T, C>(mut root: Option<Box<Node<T>>>, key: &T, compare: C) -> (Option<Box<Node<T>>>, bool)",
      "\twhere",
      "\t\tT: Ord + Debug,",
      "\t\tC: Fn(&T, &T) -> bool,",
      "\t{",
      "\t\tif root.is_none() {",
      "\t\t\treturn (root, false);",
      "\t\t}",
      "\t\tif compare(key, &root.as_ref().unwrap().key) {",
      "\t\t\tlet left = &mut root.as_mut().unwrap().left;",
      "\t\t\tif left.is_none() {",
      "\t\t\t\treturn (root, true);",
      "\t\t\t}",
      "\t\t\tif compare(key, &left.as_ref().unwrap().key) {",
      "\t\t\t\tlet leftleft = left.as_mut().unwrap().left.take();",
      "\t\t\t\tlet (mut tmp, is_found) = splay(leftleft, key, compare);",
      "\t\t\t\t// 戻す",
      "\t\t\t\tswap(&mut left.as_mut().unwrap().left, &mut tmp);",
      "\t\t\t\t// 親を右に回転",
      "\t\t\t\tlet tmp_left = rotate_right(root);",
      "\t\t\t\tif !is_found {",
      "\t\t\t\t\treturn (tmp_left, true);",
      "\t\t\t\t}",
      "\t\t\t\t// さらに右回転",
      "\t\t\t\t(rotate_right(tmp_left), true)",
      "\t\t\t} else {",
      "\t\t\t\tlet leftright = left.as_mut().unwrap().right.take();",
      "\t\t\t\tlet (mut new_leftright, is_found) = splay(leftright, key, compare);",
      "\t\t\t\t// 戻す",
      "\t\t\t\tswap(&mut left.as_mut().unwrap().right, &mut new_leftright);",
      "\t\t\t\t// root->left->rightがNoneでないとき",
      "\t\t\t\tif !is_found {",
      "\t\t\t\t\treturn (root, true);",
      "\t\t\t\t}",
      "\t\t\t\t// 左の子を左回転",
      "\t\t\t\tlet left = root.as_mut().unwrap().left.take();",
      "\t\t\t\tlet mut tmp_child = rotate_left(left);",
      "\t\t\t\tswap(&mut root.as_mut().unwrap().left, &mut tmp_child);",
      "\t\t\t\t// 親を右回転",
      "\t\t\t\t(rotate_right(root), true)",
      "\t\t\t}",
      "\t\t} else {",
      "\t\t\tlet right = &mut root.as_mut().unwrap().right;",
      "\t\t\tif right.is_none() {",
      "\t\t\t\treturn (root, false);",
      "\t\t\t}",
      "\t\t\tif compare(key, &right.as_ref().unwrap().key) {",
      "\t\t\t\tlet rightleft = right.as_mut().unwrap().left.take();",
      "\t\t\t\tlet (mut tmp, is_found) = splay(rightleft, key, compare);",
      "\t\t\t\t// 戻す",
      "\t\t\t\tswap(&mut right.as_mut().unwrap().left, &mut tmp);",
      "\t\t\t\tif is_found {",
      "\t\t\t\t\t// 右の子を右回転",
      "\t\t\t\t\tlet right = root.as_mut().unwrap().right.take();",
      "\t\t\t\t\tlet mut tmp_child = rotate_right(right);",
      "\t\t\t\t\tswap(&mut root.as_mut().unwrap().right, &mut tmp_child);",
      "\t\t\t\t}",
      "\t\t\t\t// 親を左回転",
      "\t\t\t\t(rotate_left(root), true)",
      "\t\t\t} else {",
      "\t\t\t\tlet rightright = right.as_mut().unwrap().right.take();",
      "\t\t\t\tlet (mut tmp, is_found) = splay(rightright, key, compare);",
      "\t\t\t\t// 戻す",
      "\t\t\t\tswap(&mut right.as_mut().unwrap().right, &mut tmp);",
      "\t\t\t\t// 親を左回転",
      "\t\t\t\tlet tmp_child = rotate_left(root);",
      "\t\t\t\t// さらに左回転",
      "\t\t\t\t(rotate_left(tmp_child), is_found)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\t/// ## splay_rev",
      "\t/// - 比較関数`compare`を引数にとり、条件を満たす最小のノードを返す",
      "\t/// - splayの逆向き",
      "\tfn splay_rev<T, C>(",
      "\t\tmut root: Option<Box<Node<T>>>,",
      "\t\tkey: &T,",
      "\t\tcompare: C,",
      "\t) -> (Option<Box<Node<T>>>, bool)",
      "\twhere",
      "\t\tT: Ord + Debug,",
      "\t\tC: Fn(&T, &T) -> bool,",
      "\t{",
      "\t\tif root.is_none() {",
      "\t\t\treturn (root, false);",
      "\t\t}",
      "\t\tif compare(key, &root.as_ref().unwrap().key) {",
      "\t\t\tlet right = &mut root.as_mut().unwrap().right;",
      "\t\t\tif right.is_none() {",
      "\t\t\t\treturn (root, true);",
      "\t\t\t}",
      "\t\t\tif compare(key, &right.as_ref().unwrap().key) {",
      "\t\t\t\tlet rightright = right.as_mut().unwrap().right.take();",
      "\t\t\t\tlet (mut tmp, is_found) = splay_rev(rightright, key, compare);",
      "\t\t\t\t// 戻す",
      "\t\t\t\tswap(&mut right.as_mut().unwrap().right, &mut tmp);",
      "\t\t\t\t// 親を左に回転",
      "\t\t\t\tlet tmp_right = rotate_left(root);",
      "\t\t\t\tif !is_found {",
      "\t\t\t\t\treturn (tmp_right, true);",
      "\t\t\t\t}",
      "\t\t\t\t// さらに左回転",
      "\t\t\t\t(rotate_left(tmp_right), true)",
      "\t\t\t} else {",
      "\t\t\t\tlet rightleft = right.as_mut().unwrap().left.take();",
      "\t\t\t\tlet (mut new_rightleft, is_found) = splay_rev(rightleft, key, compare);",
      "\t\t\t\t// 戻す",
      "\t\t\t\tswap(&mut right.as_mut().unwrap().left, &mut new_rightleft);",
      "\t\t\t\t// root->right->leftがNoneでないとき",
      "\t\t\t\tif !is_found {",
      "\t\t\t\t\treturn (root, true);",
      "\t\t\t\t}",
      "\t\t\t\t// 右の子を右回転",
      "\t\t\t\tlet right = root.as_mut().unwrap().right.take();",
      "\t\t\t\tlet mut tmp_child = rotate_right(right);",
      "\t\t\t\tswap(&mut root.as_mut().unwrap().right, &mut tmp_child);",
      "\t\t\t\t// 親を左回転",
      "\t\t\t\t(rotate_left(root), true)",
      "\t\t\t}",
      "\t\t} else {",
      "\t\t\tlet left = &mut root.as_mut().unwrap().left;",
      "\t\t\tif left.is_none() {",
      "\t\t\t\treturn (root, false);",
      "\t\t\t}",
      "\t\t\tif compare(key, &left.as_ref().unwrap().key) {",
      "\t\t\t\tlet leftright = left.as_mut().unwrap().right.take();",
      "\t\t\t\tlet (mut tmp, is_found) = splay_rev(leftright, key, compare);",
      "\t\t\t\t// 戻す",
      "\t\t\t\tswap(&mut left.as_mut().unwrap().right, &mut tmp);",
      "\t\t\t\tif is_found {",
      "\t\t\t\t\t// 左の子を左回転",
      "\t\t\t\t\tlet left = root.as_mut().unwrap().left.take();",
      "\t\t\t\t\tlet mut tmp_child = rotate_left(left);",
      "\t\t\t\t\tswap(&mut root.as_mut().unwrap().left, &mut tmp_child);",
      "\t\t\t\t}",
      "\t\t\t\t// 親を右回転",
      "\t\t\t\t(rotate_right(root), true)",
      "\t\t\t} else {",
      "\t\t\t\tlet leftleft = left.as_mut().unwrap().left.take();",
      "\t\t\t\tlet (mut tmp, is_found) = splay_rev(leftleft, key, compare);",
      "\t\t\t\t// 戻す",
      "\t\t\t\tswap(&mut left.as_mut().unwrap().left, &mut tmp);",
      "\t\t\t\t// 親を右回転",
      "\t\t\t\tlet tmp_child = rotate_right(root);",
      "\t\t\t\t// さらに右回転",
      "\t\t\t\t(rotate_right(tmp_child), is_found)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\t/// ## 右回転",
      "\t/// ```not-rust",
      "\t///\t\tY\t\t\t\t\t  X",
      "\t///\t   / \\\t   right\t\t/ \\",
      "\t///\t  X   C  === rotate ==>  A   Y",
      "\t///\t / \\\t\t\t\t\t\t/ \\",
      "\t///\tA   B\t\t\t\t\t  B   C",
      "\t/// ```",
      "\tfn rotate_right<T: Ord + Debug>(root: Option<Box<Node<T>>>) -> Option<Box<Node<T>>> {",
      "\t\tif let Some(mut root) = root {",
      "\t\t\tif let Some(mut new_root) = root.left {",
      "\t\t\t\troot.left = new_root.right;",
      "\t\t\t\tnew_root.right = Some(root);",
      "\t\t\t\tSome(new_root)",
      "\t\t\t} else {",
      "\t\t\t\tSome(root)",
      "\t\t\t}",
      "\t\t} else {",
      "\t\t\tNone",
      "\t\t}",
      "\t}",
      "\t/// ## 左回転",
      "\t/// ```not-rust",
      "\t///\t  X\t\t\t\t\t\t  Y",
      "\t///\t / \\\t\t left\t\t   / \\",
      "\t///\tA   Y\t=== rotate ==>\tX   C",
      "\t///\t   / \\\t\t\t\t\t/ \\",
      "\t///\t  B   C\t\t\t\t  A   B",
      "\t/// ```",
      "\tfn rotate_left<T: Ord + Debug>(root: Option<Box<Node<T>>>) -> Option<Box<Node<T>>> {",
      "\t\tif let Some(mut root) = root {",
      "\t\t\tif let Some(mut new_root) = root.right {",
      "\t\t\t\troot.right = new_root.left;",
      "\t\t\t\tnew_root.left = Some(root);",
      "\t\t\t\tSome(new_root)",
      "\t\t\t} else {",
      "\t\t\t\tSome(root)",
      "\t\t\t}",
      "\t\t} else {",
      "\t\t\tNone",
      "\t\t}",
      "\t}",
      "\t// ----- FromIterator -----",
      "\timpl<T: Ord + Clone + Debug> FromIterator<T> for MultiSet<T> {",
      "\t\tfn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {",
      "\t\t\tlet mut res = MultiSet::new();",
      "\t\t\tfor item in iter {",
      "\t\t\t\tres.insert(item);",
      "\t\t\t}",
      "\t\t\tres",
      "\t\t}",
      "\t}",
      "\t// ----- Debug -----",
      "\timpl<T: Ord + Debug> Debug for MultiSet<T> {",
      "\t\tfn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
      "\t\t\tfmt_inner(f, &self.root, 0);",
      "\t\t\tOk(())",
      "\t\t}",
      "\t}",
      "\t/// 再帰的に表示",
      "\t#[allow(unused_must_use)]",
      "\tfn fmt_inner<T>(f: &mut std::fmt::Formatter<'_>, node: &Option<Box<Node<T>>>, depth: usize)",
      "\twhere",
      "\t\tT: Ord + Debug,",
      "\t{",
      "\t\tmatch node {",
      "\t\t\tSome(ref node) => {",
      "\t\t\t\tfmt_inner(f, &node.left, depth + 1);",
      "\t\t\t\twriteln!(f, \"{}{:?}({})\", \" \".repeat(depth * 2), node.key, node.id);",
      "\t\t\t\tfmt_inner(f, &node.right, depth + 1);",
      "\t\t\t}",
      "\t\t\tNone => {}",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "スプレー木のMultiSet"
  },
  "run_length.rs": {
    "prefix": "run_length",
    "body": [
      "mod run_length {",
      "\t#![allow(dead_code)]",
      "\t//! ランレングス圧縮",
      "\t/// ## ランレングス圧縮",
      "\t/// - スライスからエンコードを行う",
      "\tpub fn run_length_encode<T>(arr: &[T]) -> Vec<(T, usize)>",
      "\twhere",
      "\t\tT: PartialEq + Copy,",
      "\t{",
      "\t\tlet mut res = vec![];",
      "\t\tlet mut cur = arr[0];",
      "\t\tlet mut cnt = 1;",
      "\t\tfor &val in &arr[1..] {",
      "\t\t\tif val == cur {",
      "\t\t\t\tcnt += 1;",
      "\t\t\t} else {",
      "\t\t\t\tres.push((cur, cnt));",
      "\t\t\t\tcur = val;",
      "\t\t\t\tcnt = 1;",
      "\t\t\t}",
      "\t\t}",
      "\t\tlet last_elem = *arr.last().unwrap();",
      "\t\tres.push((last_elem, cnt));",
      "\t\tres",
      "\t}",
      "\t/// ## ランレングス圧縮 (from Iterator)",
      "\t/// - イテレータからエンコードを行う",
      "\tpub fn run_length_encode_from<T, I>(mut itr: I) -> Vec<(T, usize)>",
      "\twhere",
      "\t\tT: PartialEq,",
      "\t\tI: Iterator<Item = T>,",
      "\t{",
      "\t\tlet mut res = vec![];",
      "\t\tlet mut cur = itr.next().unwrap();",
      "\t\tlet mut cnt = 1;",
      "\t\tfor val in itr {",
      "\t\t\tif val == cur {",
      "\t\t\t\tcnt += 1;",
      "\t\t\t} else {",
      "\t\t\t\tres.push((cur, cnt));",
      "\t\t\t\tcur = val;",
      "\t\t\t\tcnt = 1;",
      "\t\t\t}",
      "\t\t}",
      "\t\tres.push((cur, cnt));",
      "\t\tres",
      "\t}",
      "}"
    ],
    "description": "ランレングス圧縮"
  },
  "scc.rs": {
    "prefix": "scc",
    "body": [
      "mod scc {",
      "\t#![allow(dead_code)]",
      "\t//! 強連結成分分解",
      "\ttype Graph = Vec<Vec<usize>>;",
      "\t/// ## SCC (強連結成分分解)",
      "\t/// - Strongly Conneected Components",
      "\t#[derive(Debug)]",
      "\tpub struct SCC {",
      "\t\tpub V: usize,",
      "\t\tpub E: usize,",
      "\t\tpub G: Graph,",
      "\t\trG: Graph,",
      "\t\tpub group_count: usize,",
      "\t\tpub belongs_to: Vec<usize>,",
      "\t\tpub components: Vec<Vec<usize>>,",
      "\t\tpub DAG: Graph,",
      "\t}",
      "\timpl SCC {",
      "\t\tconst INF: usize = std::usize::MAX;",
      "\t\t/// 頂点`V`のグラフを構築する",
      "\t\tpub fn new(V: usize) -> Self {",
      "\t\t\tSelf {",
      "\t\t\t\tV,",
      "\t\t\t\tE: 0,",
      "\t\t\t\tG: vec![vec![]; V],",
      "\t\t\t\trG: vec![vec![]; V],",
      "\t\t\t\tgroup_count: 0,",
      "\t\t\t\tbelongs_to: vec![0; V],",
      "\t\t\t\tcomponents: vec![],",
      "\t\t\t\tDAG: vec![],",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// uからvへの有向辺を追加",
      "\t\tpub fn add_edge(&mut self, u: usize, v: usize) {",
      "\t\t\tself.E += 1;",
      "\t\t\tself.G[u].push(v);",
      "\t\t\tself.rG[v].push(u);",
      "\t\t}",
      "\t\t/// 強連結成分に分解する",
      "\t\tpub fn decompose(&mut self) {",
      "\t\t\t// 帰りがけ順で順序付け",
      "\t\t\tlet mut order = vec![];",
      "\t\t\tlet mut visited = vec![false; self.V];",
      "\t\t\tfor i in 0..self.V {",
      "\t\t\t\tSelf::dfs(i, &self.G, &mut order, &mut visited);",
      "\t\t\t}",
      "\t\t\t// 連結成分に分解",
      "\t\t\tlet mut group = 0;",
      "\t\t\tlet mut belongs_to = vec![Self::INF; self.V];",
      "\t\t\tfor &i in order.iter().rev() {",
      "\t\t\t\tif belongs_to[i] == Self::INF {",
      "\t\t\t\t\tSelf::rdfs(i, group, &self.rG, &mut belongs_to);",
      "\t\t\t\t\tgroup += 1;",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\t// DAGを構築",
      "\t\t\tlet mut DAG = vec![vec![]; group];",
      "\t\t\tfor i in 0..self.V {",
      "\t\t\t\tfor &j in &self.G[i] {",
      "\t\t\t\t\tlet (u, v) = (belongs_to[i], belongs_to[j]);",
      "\t\t\t\t\tif u != v {",
      "\t\t\t\t\t\tDAG[u].push(v);",
      "\t\t\t\t\t}",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\t// 分解する",
      "\t\t\tself.components.resize_with(group, Vec::new);",
      "\t\t\tfor (v, &g) in belongs_to.iter().enumerate() {",
      "\t\t\t\tself.components[g].push(v);",
      "\t\t\t}",
      "\t\t\tself.group_count = group;",
      "\t\t\tself.belongs_to = belongs_to;",
      "\t\t\tself.DAG = DAG;",
      "\t\t}",
      "\t\tfn dfs(u: usize, G: &Graph, order: &mut Vec<usize>, visited: &mut Vec<bool>) {",
      "\t\t\tif visited[u] {",
      "\t\t\t\treturn;",
      "\t\t\t}",
      "\t\t\tvisited[u] = true;",
      "\t\t\tfor &v in &G[u] {",
      "\t\t\t\tSelf::dfs(v, G, order, visited);",
      "\t\t\t}",
      "\t\t\torder.push(u);",
      "\t\t}",
      "\t\tfn rdfs(u: usize, group: usize, rG: &Graph, belongs_to: &mut Vec<usize>) {",
      "\t\t\tif belongs_to[u] != Self::INF {",
      "\t\t\t\treturn;",
      "\t\t\t}",
      "\t\t\tbelongs_to[u] = group;",
      "\t\t\tfor &v in &rG[u] {",
      "\t\t\t\tSelf::rdfs(v, group, rG, belongs_to);",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "強連結成分分解"
  },
  "comb_no_mod.rs": {
    "prefix": "comb_no_mod",
    "body": [
      "mod comb_no_mod {",
      "\t#![allow(dead_code)]",
      "\t//! 再帰関数による愚直な組合せ計算",
      "\tpub fn comb(n: usize, r: usize) -> usize {",
      "\t\tif r == 0 {",
      "\t\t\t1",
      "\t\t} else if n < r {",
      "\t\t\t0",
      "\t\t} else {",
      "\t\t\tn * comb(n - 1, r - 1) / r",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "再帰関数による愚直な組合せ計算"
  },
  "factorize_fast.rs": {
    "prefix": "factorize_fast",
    "body": [
      "mod factorize_fast {",
      "\t#![allow(dead_code)]",
      "\t//! 前計算ありの高速素因数分解",
      "\t/// # 前計算ありの高速素因数分解",
      "\t/// `N`までの数の素因数分解を",
      "\t/// - 前計算: `O(NloglogN)`",
      "\t/// - クエリ: `O(logN)`",
      "\t/// で行う。",
      "\tpub struct FactorTable {",
      "\t\tn: usize,",
      "\t\tsieve: Vec<usize>,",
      "\t}",
      "\timpl FactorTable {",
      "\t\t/// 前計算を行う",
      "\t\t/// - `O(NloglogN)`で篩を作成",
      "\t\tpub fn new(n: usize) -> Self {",
      "\t\t\tlet mut facs = FactorTable {",
      "\t\t\t\tn,",
      "\t\t\t\tsieve: vec![1; n + 1],",
      "\t\t\t};",
      "\t\t\tfor i in 2..=n {",
      "\t\t\t\tfor j in 1.. {",
      "\t\t\t\t\tif i * j > n {",
      "\t\t\t\t\t\tbreak;",
      "\t\t\t\t\t}",
      "\t\t\t\t\tif facs.sieve[i * j] == 1 {",
      "\t\t\t\t\t\tfacs.sieve[i * j] = i;",
      "\t\t\t\t\t}",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\tfacs",
      "\t\t}",
      "\t\t/// 素因数分解を`O(logn)`で行う",
      "\t\t/// ### 戻り値",
      "\t\t/// - `Vec<usize>`: 素因数のリスト",
      "\t\tpub fn factorize(&self, mut x: usize) -> Vec<usize> {",
      "\t\t\tassert!(1 <= x && x <= self.n);",
      "\t\t\tlet mut factors = vec![];",
      "\t\t\twhile x > 1 {",
      "\t\t\t\tfactors.push(self.sieve[x]);",
      "\t\t\t\tx /= self.sieve[x];",
      "\t\t\t}",
      "\t\t\tfactors",
      "\t\t}",
      "\t\t/// 素因数分解を`O(logn)`で行う",
      "\t\t/// ### 戻り値",
      "\t\t/// - `Vec<(usize, usize)>`: (素因数, その個数)",
      "\t\tpub fn factorize_pairs(&self, mut x: usize) -> Vec<(usize, usize)> {",
      "\t\t\tassert!(1 <= x && x <= self.n);",
      "\t\t\tlet mut pairs: Vec<(usize, usize)> = vec![];",
      "\t\t\twhile x > 1 {",
      "\t\t\t\tlet p = self.sieve[x];",
      "\t\t\t\tif !pairs.is_empty() && pairs.last().unwrap().0 == p {",
      "\t\t\t\t\tpairs.last_mut().unwrap().1 += 1",
      "\t\t\t\t} else {",
      "\t\t\t\t\tpairs.push((p, 1));",
      "\t\t\t\t}",
      "\t\t\t\tx /= self.sieve[x];",
      "\t\t\t}",
      "\t\t\tpairs",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "前計算ありの高速素因数分解"
  },
  "lca_doubling.rs": {
    "prefix": "lca_doubling",
    "body": [
      "mod lca_doubling {",
      "\t#![allow(dead_code)]",
      "\t//! ダブリングにより、最小共通祖先を求める",
      "\tconst INF: usize = 1001001001001001001;",
      "\ttype Graph = Vec<Vec<usize>>;",
      "\t/// # LCA",
      "\t/// 最小共通祖先を求めるクエリに答える",
      "\tpub struct LCA {",
      "\t\tdouble: Vec<Vec<usize>>,",
      "\t\tdepth: Vec<usize>,",
      "\t}",
      "\timpl LCA {",
      "\t\t/// `root`を根に持つ木`tree`で、初期化を行う",
      "\t\tpub fn new(tree: &Graph, root: usize) -> Self {",
      "\t\t\tlet V = tree.len(); // グラフの頂点数",
      "\t\t\tlet logV = {",
      "\t\t\t\t// log_2(グラフの頂点数)",
      "\t\t\t\tlet mut logv = 0;",
      "\t\t\t\twhile (V >> logv) > 0 {",
      "\t\t\t\t\tlogv += 1;",
      "\t\t\t\t}",
      "\t\t\t\tlogv",
      "\t\t\t};",
      "\t\t\tlet mut double = vec![vec![0; V]; logV]; // ダブリング配列",
      "\t\t\tlet mut depth = vec![INF; V]; // 頂点の根からの距離",
      "\t\t\tdepth[0] = 0;",
      "\t\t\tSelf::dfs(root, &mut double[0], &mut depth, tree);",
      "\t\t\t// ダブリング",
      "\t\t\tfor i in 1..logV {",
      "\t\t\t\tfor j in 0..V {",
      "\t\t\t\t\tdouble[i][j] = double[i - 1][double[i - 1][j]];",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\tSelf { double, depth }",
      "\t\t}",
      "\t\tfn dfs(u: usize, par: &mut Vec<usize>, depth: &mut Vec<usize>, tree: &Graph) {",
      "\t\t\tfor &v in &tree[u] {",
      "\t\t\t\tif depth[v] != INF {",
      "\t\t\t\t\tcontinue;",
      "\t\t\t\t}",
      "\t\t\t\tdepth[v] = depth[u] + 1;",
      "\t\t\t\tpar[v] = u;",
      "\t\t\t\tSelf::dfs(v, par, depth, tree);",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 頂点`u`,`v`の最小共通祖先を求める",
      "\t\tpub fn get_lca(&self, mut u: usize, mut v: usize) -> usize {",
      "\t\t\t// 常にuを深くする",
      "\t\t\tif self.depth[u] < self.depth[v] {",
      "\t\t\t\tstd::mem::swap(&mut u, &mut v);",
      "\t\t\t}",
      "\t\t\t// LCAまでの距離を同じにする",
      "\t\t\tfor k in 0..self.double.len() {",
      "\t\t\t\tif ((self.depth[u] - self.depth[v]) >> k) & 1 == 1 {",
      "\t\t\t\t\tu = self.double[k][u];",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\tif u == v {",
      "\t\t\t\treturn u;",
      "\t\t\t}",
      "\t\t\t// 二分探索",
      "\t\t\tfor k in (0..self.double.len()).rev() {",
      "\t\t\t\tif self.double[k][u] != self.double[k][v] {",
      "\t\t\t\t\tu = self.double[k][u];",
      "\t\t\t\t\tv = self.double[k][v];",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\tself.double[0][u]",
      "\t\t}",
      "\t\t/// 頂点`u`,`v`の距離を求める",
      "\t\tpub fn dist(&self, u: usize, v: usize) -> usize {",
      "\t\t\tlet o = self.get_lca(u, v);",
      "\t\t\t(self.depth[u] - self.depth[o]) + (self.depth[v] - self.depth[o])",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "ダブリングにより、最小共通祖先を求める"
  },
  "simple_graph.rs": {
    "prefix": "simple_graph",
    "body": [
      "mod simple_graph {",
      "\t#![allow(dead_code)]",
      "\t//! 単純グラフの連結成分分解，2部グラフ判定など",
      "\ttype Graph = Vec<Vec<usize>>;",
      "\t/// # 単純グラフ",
      "\t/// 単純グラフに対して",
      "\t/// - 連結成分分解",
      "\t/// - 2部グラフ分解",
      "\t///",
      "\t/// を行う。",
      "\t#[derive(Debug)]",
      "\tpub struct SimpleGraph {",
      "\t\tpub V: usize,",
      "\t\tpub E: usize,",
      "\t\tpub graph: Graph,",
      "\t\tpub edges: Vec<(usize, usize)>,",
      "\t\tpub component_size: Option<usize>,",
      "\t\tpub components: Vec<usize>,",
      "\t}",
      "\timpl SimpleGraph {",
      "\t\tconst INF: usize = 1_000_000_000_000_000_000;",
      "\t\t/// グラフの構築",
      "\t\tpub fn new(V: usize) -> Self {",
      "\t\t\tSelf {",
      "\t\t\t\tV,",
      "\t\t\t\tE: 0,",
      "\t\t\t\tgraph: vec![vec![]; V],",
      "\t\t\t\tedges: vec![],",
      "\t\t\t\tcomponent_size: None,",
      "\t\t\t\tcomponents: vec![Self::INF; V],",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 辺の追加",
      "\t\tpub fn add_edge(&mut self, u: usize, v: usize) {",
      "\t\t\tself.E += 1;",
      "\t\t\tself.edges.push((u, v));",
      "\t\t\tself.graph[u].push(v);",
      "\t\t\tself.graph[v].push(u);",
      "\t\t}",
      "\t\t/// 連結成分に分解：O(|V|+|E|)",
      "\t\tpub fn decompose(&mut self) {",
      "\t\t\tlet mut component = 0;",
      "\t\t\tself.components = vec![Self::INF; self.V];",
      "\t\t\tfor i in 0..self.V {",
      "\t\t\t\tif self.components[i] != Self::INF {",
      "\t\t\t\t\tcontinue;",
      "\t\t\t\t}",
      "\t\t\t\tself.components[i] = component;",
      "\t\t\t\tlet mut stack = vec![i];",
      "\t\t\t\twhile let Some(u) = stack.pop() {",
      "\t\t\t\t\tfor &v in &self.graph[u] {",
      "\t\t\t\t\t\tif self.components[v] == Self::INF {",
      "\t\t\t\t\t\t\tself.components[v] = component;",
      "\t\t\t\t\t\t\tstack.push(v);",
      "\t\t\t\t\t\t}",
      "\t\t\t\t\t}",
      "\t\t\t\t}",
      "\t\t\t\tcomponent += 1;",
      "\t\t\t}",
      "\t\t\tself.component_size = Some(component);",
      "\t\t}",
      "\t\t/// 2部グラフ判定：O(|V|+|E|)",
      "\t\tpub fn bipartite(&mut self) -> Option<Vec<isize>> {",
      "\t\t\t// 未だ連結成分分解されていない場合",
      "\t\t\tif self.component_size.is_none() {",
      "\t\t\t\tself.decompose();",
      "\t\t\t}",
      "\t\t\tlet mut res: Vec<isize> = vec![0; self.V];",
      "\t\t\tfor i in 0..self.V {",
      "\t\t\t\tlet mut stack = vec![i];",
      "\t\t\t\tif res[i] != 0 {",
      "\t\t\t\t\tcontinue;",
      "\t\t\t\t}",
      "\t\t\t\tres[i] = self.components[i] as isize + 1;",
      "\t\t\t\twhile let Some(u) = stack.pop() {",
      "\t\t\t\t\tfor &v in &self.graph[u] {",
      "\t\t\t\t\t\tif res[v] == res[u] {",
      "\t\t\t\t\t\t\treturn None;",
      "\t\t\t\t\t\t}",
      "\t\t\t\t\t\tif res[v] == 0 {",
      "\t\t\t\t\t\t\tres[v] = -res[u];",
      "\t\t\t\t\t\t\tstack.push(v);",
      "\t\t\t\t\t\t}",
      "\t\t\t\t\t}",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\tSome(res)",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "単純グラフの連結成分分解，2部グラフ判定など"
  },
  "rollback_unionfind.rs": {
    "prefix": "rollback_unionfind",
    "body": [
      "mod rollback_unionfind {",
      "\t#![allow(dead_code)]",
      "\t//! undo処理，rollback処理をもたせたUnionFind木",
      "\t/// ロールバック可能UnionFind",
      "\tstruct RollbackUnionFind {",
      "\t\t",
      "\t}",
      "}"
    ],
    "description": "undo処理，rollback処理をもたせたUnionFind木"
  },
  "modint_for_rollinghash.rs": {
    "prefix": "modint_for_rollinghash",
    "body": [
      "mod modint_for_rollinghash {",
      "\t#![allow(dead_code)]",
      "\t//! Modintの構造体",
      "\t#[rustfmt::skip]",
      "\tpub mod modint {",
      "\t\tpub const MOD: usize = (1 << 61) - 1;",
      "\t\tconst MASK30: usize = (1 << 30) - 1;",
      "\t\tconst MASK31: usize = (1 << 31) - 1;",
      "\t\tconst MASK61: usize = MOD;",
      "\t\tfn mul(a: usize, b: usize) -> usize { let (au, ad) = (a >> 31, a & MASK31); let (bu, bd) = (b >> 31, b & MASK31); let m = ad * bu + au * bd; let (mu, md) = (m >> 30, m & MASK30); calcmod(au * bu * 2 + mu + (md << 31) + ad * bd) }",
      "\t\tfn calcmod(x: usize) -> usize { let xu = x >> 61; let xd = x & MASK61; let res = xu + xd; if res >= MOD { res - MOD } else { res } }",
      "\t\tuse std::{fmt::Display,ops::{Add, AddAssign, Div, Mul, MulAssign, Neg, Sub, SubAssign}, str::FromStr, num::ParseIntError, iter::{Sum, Product}};",
      "\t\t#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)] pub struct Modint(pub usize);",
      "\t\timpl Modint { pub fn new(n: usize) -> Self { Self(calcmod(n)) } }",
      "\t\timpl Neg for Modint { type Output = Self; fn neg(self) -> Self { Modint(if self.0 == 0 { 0 } else { MOD - self.0 }) } }",
      "\t\timpl Add for Modint { type Output = Self; fn add(self, rhs: Self) -> Self { let mut res = self.0 + rhs.0; if res >= MOD { res -= MOD; } Modint(res) } }",
      "\t\timpl Sub for Modint { type Output = Self; fn sub(self, rhs: Self) -> Self { self + (- rhs) } }",
      "\t\timpl Mul for Modint { type Output = Self; fn mul(self, rhs: Self) -> Self { Modint(mul(self.0, rhs.0)) } }",
      "\t\timpl Div for Modint { type Output = Self; fn div(self, rhs: Self) -> Self { self * rhs.inv() } }",
      "\t\timpl AddAssign for Modint { fn add_assign(&mut self, rhs: Self) { self.0 = (*self + rhs).0 } }",
      "\t\timpl SubAssign for Modint { fn sub_assign(&mut self, rhs: Self) { self.0 = (*self - rhs).0 } }",
      "\t\timpl MulAssign for Modint { fn mul_assign(&mut self, rhs: Self) { self.0 = (*self * rhs).0 } }",
      "\t\timpl From<usize> for Modint { fn from(value: usize) -> Self { Modint::new(value) } }",
      "\t\timpl Add<usize> for Modint { type Output = Self; fn add(self, rhs: usize) -> Self { let mut res = self.0 + rhs; if res >= MOD {res -= MOD;} Modint(res) } }",
      "\t\timpl Sub<usize> for Modint { type Output = Self; fn sub(self, rhs: usize) -> Self { self - Modint::new(rhs) } }",
      "\t\timpl Mul<usize> for Modint { type Output = Self; fn mul(self, rhs: usize) -> Self { self * Modint::new(rhs) } }",
      "\t\timpl Div<usize> for Modint { type Output = Self; fn div(self, rhs: usize) -> Self { self / Modint::new(rhs) } }",
      "\t\timpl AddAssign<usize> for Modint { fn add_assign(&mut self, rhs: usize) { *self += Modint::new(rhs) } }",
      "\t\timpl SubAssign<usize> for Modint { fn sub_assign(&mut self, rhs: usize) { *self -= Modint::new(rhs) } }",
      "\t\timpl MulAssign<usize> for Modint { fn mul_assign(&mut self, rhs: usize) { *self *= Modint::new(rhs) } }",
      "\t\timpl Display for Modint { fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, \"{}\", self.0) } }",
      "\t\timpl PartialEq<usize> for Modint { fn eq(&self, other: &usize) -> bool { self == &Modint::new(*other) } }",
      "\t\timpl FromStr for Modint { type Err = ParseIntError; fn from_str(s: &str) -> Result<Self, Self::Err> { usize::from_str(s).map(Modint::new) } }",
      "\t\tpub trait Fp { fn pow(&self, rhs: usize) -> Self; fn inv(&self) -> Self; }",
      "\t\timpl Fp for Modint { fn pow(&self, rhs: usize) -> Self { let (mut a, mut b) = (self.0, rhs); let mut res = 1; while b > 0 { if b & 1 == 1 { res = mul(res, a); } a = mul(a, a); b >>= 1u32; } Modint(res) } fn inv(&self) -> Self { self.pow(MOD - 2) } }",
      "\t\timpl Sum<Modint> for Modint { fn sum<I: Iterator<Item = Modint>>(iter: I) -> Self { iter.fold(Modint(0), |acc, x| acc + x) } }",
      "\t\timpl Product<Modint> for Modint { fn product<I: Iterator<Item = Modint>>(iter: I) -> Self { iter.fold(Modint(1), |acc, x| acc * x) } }",
      "\t}",
      "\tpub use modint::*;",
      "}"
    ],
    "description": "Modintの構造体"
  },
  "acc2d.rs": {
    "prefix": "acc2d",
    "body": [
      "mod acc2d {",
      "\t#![allow(dead_code)]",
      "\t//! 2次元累積和",
      "\tuse num_traits::Num;",
      "\t/// ## acc2D",
      "\t/// - 2次元累積和を取る",
      "\t/// ### 戻り値",
      "\t/// - `|r_start, r_end, c_start, c_end|: (usize, usize, usize, usize) -> T`",
      "\tpub fn acc2D<T: Num + Copy>(array: &Vec<Vec<T>>) -> impl Fn(usize, usize, usize, usize) -> T {",
      "\t\tlet (H, W) = (array.len(), array[0].len());",
      "\t\tlet mut S = vec![vec![T::zero(); W + 1]; H + 1];",
      "\t\tfor i in 0..H {",
      "\t\t\tfor j in 0..W {",
      "\t\t\t\tS[i + 1][j + 1] = array[i][j] + S[i][j + 1] + S[i + 1][j] - S[i][j];",
      "\t\t\t}",
      "\t\t}",
      "\t\tmove |r_start: usize, r_end: usize, c_start: usize, c_end: usize| -> T {",
      "\t\t\tS[r_end][c_end] + S[r_start][c_start] - S[r_end][c_start] - S[r_start][c_end]",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "2次元累積和"
  },
  "coordinate_compression.rs": {
    "prefix": "coordinate_compression",
    "body": [
      "mod coordinate_compression {",
      "\t#![allow(dead_code)]",
      "\t//! 座標圧縮",
      "\t/// # 座標圧縮",
      "\t#[derive(Debug)]",
      "\tpub struct Compression<'a, T> {",
      "\t\tpub size: usize,",
      "\t\tpub sorted_array: Vec<&'a T>,",
      "\t}",
      "\timpl<'a, T: Ord> Compression<'a, T> {",
      "\t\t/// スライス`array`で配列を初期化する",
      "\t\tpub fn new(array: &'a [T]) -> Self {",
      "\t\t\tarray.iter().collect()",
      "\t\t}",
      "\t\t/// 圧縮後の`val`の番号を返す",
      "\t\tpub fn idx(&self, val: &T) -> Option<usize> {",
      "\t\t\tlet idx = self.sorted_array.binary_search(&val);",
      "\t\t\tif let Ok(idx) = idx {",
      "\t\t\t\tSome(idx)",
      "\t\t\t} else {",
      "\t\t\t\tNone",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// 圧縮前の要素`idx`を返す",
      "\t\tpub fn val(&self, idx: usize) -> Option<&T> {",
      "\t\t\tif let Some(&val) = self.sorted_array.get(idx) {",
      "\t\t\t\tSome(val)",
      "\t\t\t} else {",
      "\t\t\t\tNone",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\timpl<'a, T: Ord> FromIterator<&'a T> for Compression<'a, T> {",
      "\t\tfn from_iter<I: IntoIterator<Item = &'a T>>(iter: I) -> Self {",
      "\t\t\tlet mut comp: Vec<&'a T> = iter.into_iter().collect();",
      "\t\t\tcomp.sort();",
      "\t\t\tcomp.dedup();",
      "\t\t\tSelf {",
      "\t\t\t\tsize: comp.len(),",
      "\t\t\t\tsorted_array: comp,",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "座標圧縮"
  },
  "macro_debug.rs": {
    "prefix": "macro_debug",
    "body": [
      "mod macro_debug {",
      "\t#![allow(dead_code)]",
      "\t//! デバッグ用マクロ",
      "\t/// デバッグ用マクロ",
      "\t#[macro_export]",
      "\tmacro_rules! debug {",
      "\t\t( \\$(\\$val:expr),* \\$(,)* ) => {{",
      "\t\t\t#[cfg(debug_assertions)]",
      "\t\t\teprintln!( concat!(\\$(stringify!(\\$val), \" = {:?}, \"),*), \\$(\\$val),* );",
      "\t\t}};",
      "\t}",
      "\t/// 配列用マクロ",
      "\t#[macro_export]",
      "\tmacro_rules! debug2D {",
      "\t\t( \\$array:expr ) => {{",
      "\t\t\t#![cfg(debug_assertions)]",
      "\t\t\teprintln!(\"{}: \", stringify!(\\$array));",
      "\t\t\tfor row in &\\$array {",
      "\t\t\t\teprintln!(\"{:?}\", row);",
      "\t\t\t}",
      "\t\t}};",
      "\t}",
      "}"
    ],
    "description": "デバッグ用マクロ"
  },
  "segmented_sieve.rs": {
    "prefix": "segmented_sieve",
    "body": [
      "mod segmented_sieve {",
      "\t#![allow(dead_code)]",
      "\t//! 区間篩",
      "\t/// 区間 [l,r) の素数を列挙する",
      "\t/// - 計算量：`O((√B + (B - A)) log log B)`",
      "\tpub fn segmented_sieve(l: usize, r: usize) -> Vec<usize> {",
      "\t\tlet l = l.max(2);",
      "\t\tlet r = r.max(l);",
      "\t\tlet MAX = (r as f64).sqrt() as usize + 10;",
      "\t\tlet mut divisors = vec![true; MAX];",
      "\t\t(divisors[0], divisors[1]) = (false, false);",
      "\t\tlet mut sieve = vec![true; r - l];",
      "\t\tfor p in 2..MAX {",
      "\t\t\tif !divisors[p] {",
      "\t\t\t\tcontinue;",
      "\t\t\t}",
      "\t\t\tlet mut i = 2;",
      "\t\t\twhile p * i < MAX {",
      "\t\t\t\tdivisors[p * i] = false;",
      "\t\t\t\ti += 1;",
      "\t\t\t}",
      "\t\t\tlet mut k = (l + p - 1) / p * p;",
      "\t\t\twhile k < r {",
      "\t\t\t\tif k > p {",
      "\t\t\t\t\tif l <= k && k < r {",
      "\t\t\t\t\t\tsieve[k - l] = false;",
      "\t\t\t\t\t}",
      "\t\t\t\t}",
      "\t\t\t\tk += p;",
      "\t\t\t}",
      "\t\t}",
      "\t\tsieve",
      "\t\t\t.iter()",
      "\t\t\t.zip(l..)",
      "\t\t\t.filter_map(|(&is_prime, x)| is_prime.then_some(x))",
      "\t\t\t.collect()",
      "\t}",
      "}"
    ],
    "description": "区間篩"
  },
  "zigzag.rs": {
    "prefix": "zigzag",
    "body": [
      "mod zigzag {",
      "\t#![allow(dead_code)]",
      "\t//! 2次元グリッドをジグザグに走査する",
      "\t/// `H x W`領域をジグザグに操作する",
      "\t///",
      "\t/// ↓3x3領域の例",
      "\t/// ```text",
      "\t/// 123",
      "\t/// 654",
      "\t/// 789",
      "\t/// ```",
      "\tpub fn zigzag(H: usize, W: usize) -> impl Iterator<Item = (usize, usize)> {",
      "\t\t(0..H).zip(1..).step_by(2).flat_map(move |(t, b)| {",
      "\t\t\t(0..W)",
      "\t\t\t\t.map(move |j| (t, j))",
      "\t\t\t\t.chain((0..if b < H { W } else { 0 }).rev().map(move |j| (b, j)))",
      "\t\t})",
      "\t}",
      "}"
    ],
    "description": "2次元グリッドをジグザグに走査する"
  },
  "extmonoid_mod.rs": {
    "prefix": "extmonoid_mod",
    "body": [
      "mod extmonoid {",
      "\t#![allow(dead_code)]",
      "\t//! 作用付きモノイド",
      "\t/// 作用付きモノイド",
      "\tpub trait ExtMonoid {",
      "\t\t/// 要素のデータ型",
      "\t\ttype X: Clone + PartialEq;",
      "\t\t/// 作用素のデータ型",
      "\t\ttype M: Clone + PartialEq;",
      "\t\t/// 要素Xの単位元",
      "\t\tconst IX: Self::X;",
      "\t\t/// 作用素Mの単位元",
      "\t\tconst IM: Self::M;",
      "\t\t/// 要素同士の演算",
      "\t\tfn operate_x(x: &Self::X, y: &Self::X) -> Self::X;",
      "\t\t/// 要素に対する作用",
      "\t\tfn apply(x: &Self::X, y: &Self::M) -> Self::X;",
      "\t\t/// 作用素同士の演算",
      "\t\tfn operate_m(x: &Self::M, y: &Self::M) -> Self::M;",
      "\t\t/// 作用素の集約",
      "\t\tfn aggregate(x: &Self::M, p: usize) -> Self::M;",
      "\t}",
      "\t/// （遅延セグ木）作用付きモノイド",
      "\tpub mod examples {",
      "\t\tuse super::ExtMonoid;",
      "\t\t/// ## RSQandRAQ",
      "\t\t/// - 区間加算",
      "\t\t/// - 区間和",
      "\t\t#[derive(Debug)]",
      "\t\tpub struct RSQandRAQ;",
      "\t\timpl ExtMonoid for RSQandRAQ {",
      "\t\t\ttype X = isize;",
      "\t\t\ttype M = isize;",
      "\t\t\tconst IX: Self::X = 0;",
      "\t\t\tconst IM: Self::M = 0;",
      "\t\t\tfn operate_x(x: &Self::X, y: &Self::X) -> Self::X {",
      "\t\t\t\tx + y",
      "\t\t\t}",
      "\t\t\tfn apply(x: &Self::X, y: &Self::M) -> Self::X {",
      "\t\t\t\tx + y",
      "\t\t\t}",
      "\t\t\tfn operate_m(x: &Self::M, y: &Self::M) -> Self::M {",
      "\t\t\t\tx + y",
      "\t\t\t}",
      "\t\t\tfn aggregate(x: &Self::M, p: usize) -> Self::M {",
      "\t\t\t\tx * p as isize",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// ## RMQandRUQ",
      "\t\t/// - 区間更新",
      "\t\t/// - 区間最小値",
      "\t\t#[derive(Debug)]",
      "\t\tpub struct RMQandRUQ;",
      "\t\timpl ExtMonoid for RMQandRUQ {",
      "\t\t\ttype X = isize;",
      "\t\t\ttype M = isize;",
      "\t\t\tconst IM: Self::M = (1 << 31) - 1;",
      "\t\t\tconst IX: Self::X = (1 << 31) - 1;",
      "\t\t\tfn operate_x(x: &Self::X, y: &Self::X) -> Self::X {",
      "\t\t\t\t*x.min(y)",
      "\t\t\t}",
      "\t\t\tfn apply(_x: &Self::X, y: &Self::M) -> Self::X {",
      "\t\t\t\t*y",
      "\t\t\t}",
      "\t\t\tfn operate_m(_x: &Self::M, y: &Self::M) -> Self::M {",
      "\t\t\t\t*y",
      "\t\t\t}",
      "\t\t\tfn aggregate(x: &Self::M, _p: usize) -> Self::M {",
      "\t\t\t\t*x",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// ## RMQandRAQ",
      "\t\t/// - 区間加算",
      "\t\t/// - 区間最小値",
      "\t\t#[derive(Debug)]",
      "\t\tpub struct RMQandRAQ;",
      "\t\timpl ExtMonoid for RMQandRAQ {",
      "\t\t\ttype X = isize;",
      "\t\t\ttype M = isize;",
      "\t\t\tconst IM: Self::M = 0;",
      "\t\t\tconst IX: Self::X = 1 << 31;",
      "\t\t\tfn operate_x(x: &Self::X, y: &Self::X) -> Self::X {",
      "\t\t\t\t*x.min(y)",
      "\t\t\t}",
      "\t\t\tfn apply(x: &Self::X, y: &Self::M) -> Self::X {",
      "\t\t\t\tx + y",
      "\t\t\t}",
      "\t\t\tfn operate_m(x: &Self::M, y: &Self::M) -> Self::M {",
      "\t\t\t\tx + y",
      "\t\t\t}",
      "\t\t\tfn aggregate(x: &Self::M, _p: usize) -> Self::M {",
      "\t\t\t\t*x",
      "\t\t\t}",
      "\t\t}",
      "\t\t/// ## RSQandRUQ",
      "\t\t/// - 区間更新",
      "\t\t/// - 区間和取得",
      "\t\t#[derive(Debug)]",
      "\t\tpub struct RSQandRUQ;",
      "\t\timpl ExtMonoid for RSQandRUQ {",
      "\t\t\ttype X = isize;",
      "\t\t\ttype M = Option<isize>;",
      "\t\t\tconst IX: Self::X = 0;",
      "\t\t\tconst IM: Self::M = None;",
      "\t\t\tfn operate_x(x: &Self::X, y: &Self::X) -> Self::X {",
      "\t\t\t\tx + y",
      "\t\t\t}",
      "\t\t\tfn apply(_x: &Self::X, y: &Self::M) -> Self::X {",
      "\t\t\t\ty.unwrap()",
      "\t\t\t}",
      "\t\t\tfn operate_m(_x: &Self::M, y: &Self::M) -> Self::M {",
      "\t\t\t\t*y",
      "\t\t\t}",
      "\t\t\tfn aggregate(x: &Self::M, p: usize) -> Self::M {",
      "\t\t\t\tx.map(|x| x * p as isize)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "}",
      "",
      "mod modint {",
      "\t#![allow(dead_code)]",
      "\t//! Modintの構造体",
      "\tpub use modint::*;",
      "\tpub type M998 = Modint<998244353>;",
      "\tpub type M107 = Modint<1000000007>;",
      "\t// 適当な素数",
      "\tpub type P1 = Modint<938472061>;",
      "\tpub type P2 = Modint<958472071>;",
      "\t#[rustfmt::skip]",
      "\tpub mod modint {",
      "\t\tfn sqrt(n: usize) -> usize { (n as f64).sqrt() as usize }",
      "\t\tuse std::{fmt::{Debug, Display}, iter::{Sum, Product}, mem::replace, num::ParseIntError, ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign}, str::FromStr};",
      "\t\t#[derive(Clone, Copy, Default, PartialEq, Eq, Hash)] pub struct Modint<const MOD: usize>(pub usize);",
      "\t\timpl<const MOD: usize> Modint<MOD> { pub fn new(n: usize) -> Self { Self(if n < MOD { n } else { n % MOD }) }",
      "\t\tpub fn from_str(s: &str) -> Self { s.chars().fold(0.into(), |n, c| n * 10 + c.to_digit(10).unwrap() as usize) }",
      "\t\tpub fn from_isize(n: isize) -> Self { Self::new((MOD as isize + n % MOD as isize) as usize) }",
      "\t\tpub fn rational_reconstruction(&self) -> Option<(usize, usize)> { let N = sqrt(MOD / 2); let mut v = (MOD, 0); let mut w = (self.0, 1);",
      "\t\twhile w.0 > N { let q = v.0.div_euclid(w.0); let z = (v.0 - q * w.0, v.1 + q * w.1); v = replace(&mut w, z); } (w.0 <= N && w.1 <= N).then_some(w) } }",
      "\t\timpl<const MOD: usize> Neg for Modint<MOD> { type Output = Self; fn neg(self) -> Self { Modint(if self.0 == 0 { 0 } else { MOD - self.0 }) } }",
      "\t\timpl<const MOD: usize> Add for Modint<MOD> { type Output = Self; fn add(self, rhs: Self) -> Self { let mut res = self.0 + rhs.0; if res >= MOD { res -= MOD; } Modint(res) } }",
      "\t\timpl<const MOD: usize> Sub for Modint<MOD> { type Output = Self; fn sub(self, rhs: Self) -> Self { self + (- rhs) } }",
      "\t\timpl<const MOD: usize> Mul for Modint<MOD> { type Output = Self; fn mul(self, rhs: Self) -> Self { Modint(self.0 * rhs.0 % MOD) } }",
      "\t\timpl<const MOD: usize> Div for Modint<MOD> { type Output = Self; fn div(self, rhs: Self) -> Self { self * rhs.inv() } }",
      "\t\timpl<const MOD: usize> AddAssign for Modint<MOD> { fn add_assign(&mut self, rhs: Self) { self.0 = (*self + rhs).0 } }",
      "\t\timpl<const MOD: usize> SubAssign for Modint<MOD> { fn sub_assign(&mut self, rhs: Self) { self.0 = (*self - rhs).0 } }",
      "\t\timpl<const MOD: usize> MulAssign for Modint<MOD> { fn mul_assign(&mut self, rhs: Self) { self.0 = (*self * rhs).0 } }",
      "\t\timpl<const MOD: usize> DivAssign for Modint<MOD> { fn div_assign(&mut self, rhs: Self) { self.0 = (*self / rhs).0 } }",
      "\t\timpl<const MOD: usize> From<usize> for Modint<MOD> { fn from(value: usize) -> Self { Modint::new(value) } }",
      "\t\timpl<const MOD: usize> Add<usize> for Modint<MOD> { type Output = Self; fn add(self, rhs: usize) -> Self { let mut res = self.0 + rhs; if res >= MOD {res -= MOD;} Modint(res) } }",
      "\t\timpl<const MOD: usize> Sub<usize> for Modint<MOD> { type Output = Self; fn sub(self, rhs: usize) -> Self { self - Modint::new(rhs) } }",
      "\t\timpl<const MOD: usize> Mul<usize> for Modint<MOD> { type Output = Self; fn mul(self, rhs: usize) -> Self { self * Modint::new(rhs) } }",
      "\t\timpl<const MOD: usize> Div<usize> for Modint<MOD> { type Output = Self; fn div(self, rhs: usize) -> Self { self / Modint::new(rhs) } }",
      "\t\timpl<const MOD: usize> AddAssign<usize> for Modint<MOD> { fn add_assign(&mut self, rhs: usize) { *self += Modint::new(rhs) } }",
      "\t\timpl<const MOD: usize> SubAssign<usize> for Modint<MOD> { fn sub_assign(&mut self, rhs: usize) { *self -= Modint::new(rhs) } }",
      "\t\timpl<const MOD: usize> MulAssign<usize> for Modint<MOD> { fn mul_assign(&mut self, rhs: usize) { *self *= Modint::new(rhs) } }",
      "\t\timpl<const MOD: usize> DivAssign<usize> for Modint<MOD> { fn div_assign(&mut self, rhs: usize) { *self /= Modint::new(rhs) } }",
      "\t\timpl<const MOD: usize> Display for Modint<MOD> { fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, \"{}\", self.0) } }",
      "\t\timpl<const MOD: usize> PartialEq<usize> for Modint<MOD> { fn eq(&self, other: &usize) -> bool { self == &Modint::new(*other) } }",
      "\t\timpl<const MOD: usize> FromStr for Modint<MOD> { type Err = ParseIntError; fn from_str(s: &str) -> Result<Self, Self::Err> { Ok(Self::from_str(s)) } }",
      "\t\timpl<const MOD: usize> Debug for Modint<MOD> { fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { match self.rational_reconstruction() { Some((n, d)) => if d > 1 { write!(f, \"Modint({n}/{d})\") } else { write!(f, \"Modint({n})\") } _ => write!(f, \"Modint({})\", self.0) } } }",
      "\t\tpub trait Fp { fn pow(&self, rhs: usize) -> Self; fn inv(&self) -> Self; }",
      "\t\timpl<const MOD: usize> Fp for Modint<MOD> { fn pow(&self, rhs: usize) -> Self { let (mut a, mut b) = (self.0, rhs); let mut res = 1; while b > 0 { if b & 1 == 1 { res = (res * a) % MOD; } a = (a * a) % MOD; b >>= 1u32; } Modint(res) } fn inv(&self) -> Self { self.pow(MOD - 2) } }",
      "\t\timpl<const MOD: usize> Sum<Modint<MOD>> for Modint<MOD> { fn sum<I: Iterator<Item = Modint<MOD>>>(iter: I) -> Self { iter.fold(Modint::<MOD>(0), |acc, x| acc + x) } }",
      "\t\timpl<const MOD: usize> Product<Modint<MOD>> for Modint<MOD> { fn product<I: Iterator<Item = Modint<MOD>>>(iter: I) -> Self { iter.fold(Modint::<MOD>(1), |acc, x| acc * x) } }",
      "\t}",
      "}",
      "",
      "mod extmonoid_mod {",
      "\t#![allow(dead_code)]",
      "\t//! modを取る作用付きモノイド",
      "\tuse crate::extmonoid::ExtMonoid;",
      "\tuse crate::modint::*;",
      "\t/// ## 1次元Affine変換",
      "\t/// - 区間を`ax + b`で更新（Affine変換）",
      "\t/// - 区間和を取得",
      "\t#[derive(Debug)]",
      "\tpub struct Affine1dMod<const MOD: usize>;",
      "\timpl<const MOD: usize> ExtMonoid for Affine1dMod<MOD> {",
      "\t\ttype X = Modint<MOD>;",
      "\t\ttype M = (Modint<MOD>, Modint<MOD>);",
      "\t\tconst IX: Self::X = Modint::<MOD>(0);",
      "\t\tconst IM: Self::M = (Modint::<MOD>(1), Modint::<MOD>(0));",
      "\t\tfn operate_x(x: &Self::X, y: &Self::X) -> Self::X {",
      "\t\t\t*x + *y",
      "\t\t}",
      "\t\tfn operate_m(x: &Self::M, y: &Self::M) -> Self::M {",
      "\t\t\tlet &(a1, b1) = x;",
      "\t\t\tlet &(a2, b2) = y;",
      "\t\t\t//   a2 * (a1 * x + b1) + b2",
      "\t\t\t// = (a2 * a1) * x + (a2 * b1 + b2)",
      "\t\t\t(a2 * a1, a2 * b1 + b2)",
      "\t\t}",
      "\t\tfn apply(x: &Self::X, y: &Self::M) -> Self::X {",
      "\t\t\tlet &(a, b) = y;",
      "\t\t\ta * *x + b",
      "\t\t}",
      "\t\tfn aggregate(x: &Self::M, p: usize) -> Self::M {",
      "\t\t\tlet &(a, b) = x;",
      "\t\t\t(a, b * p)",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "modを取る作用付きモノイド"
  }
}