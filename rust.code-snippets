{
  "kyopro": [
    {
      "prefix": "usize_tools.rs",
      "body": [
        "pub trait UsizeTools {",
        "\tfn abs_diff(&self, other: Self) -> Self;",
        "\tfn sqrt(&self) -> Self;",
        "}",
        "impl UsizeTools for usize {",
        "\tfn abs_diff(&self, other: Self) -> Self {",
        "\t\tif *self > other {",
        "\t\t\t*self - other",
        "\t\t} else {",
        "\t\t\tother - *self",
        "\t\t}",
        "\t}",
        "\t/// x^2がNを超えない最大のxを求める",
        "\t/// - 計算量：O(log(N))",
        "\tfn sqrt(&self) -> Self {",
        "\t\tlet (mut ok, mut ng) = (0_usize, 1001001001001001001);",
        "\t\twhile (ng - ok) > 1 {",
        "\t\t\tlet m = (ok + ng) / 2;",
        "\t\t\tif m.saturating_mul(m) <= *self {",
        "\t\t\t\tok = m;",
        "\t\t\t} else {",
        "\t\t\t\tng = m;",
        "\t\t\t}",
        "\t\t}",
        "\t\tok",
        "\t}",
        "}"
      ],
      "description": "usizeの便利ツール"
    },
    {
      "prefix": "factors_all.rs",
      "body": [
        "/// ## 高速約数列挙",
        "/// `1 ~ N`までの数の約数を高速に列挙する",
        "/// 計算量：`O(nloglogn)`",
        "pub fn factors_all(n: usize) -> Vec<Vec<usize>> {",
        "\tlet mut res = vec![vec![]; n + 1];",
        "\tfor i in 1..=n {",
        "\t\tfor j in 1.. {",
        "\t\t\tif i * j > n {",
        "\t\t\t\tbreak;",
        "\t\t\t}",
        "\t\t\tres[i * j].push(i);",
        "\t\t}",
        "\t}",
        "\tres",
        "}"
      ],
      "description": "高速な約数列挙"
    },
    {
      "prefix": "lcs.rs",
      "body": [
        "/// `a < b` のとき、`a`を`b`に置き換え、trueを返す",
        "macro_rules! chmax {",
        "\t( \\$a:expr, \\$b:expr ) => {{",
        "\t\tif \\$a < \\$b {",
        "\t\t\t\\$a = \\$b;",
        "\t\t\ttrue",
        "\t\t} else {",
        "\t\t\tfalse",
        "\t\t}",
        "\t}};",
        "}",
        "/// ## LCS",
        "/// 最長共通部分列を得る",
        "/// 計算量：O(NM)",
        "pub fn LCS<T: std::cmp::PartialEq>(A: &[T], B: &[T]) -> usize {",
        "\tlet (la, lb) = (A.len(), B.len());",
        "\tlet mut dp = vec![vec![0; lb + 1]; la + 1];",
        "\tfor (i, a) in A.iter().enumerate() {",
        "\t\tfor (j, b) in B.iter().enumerate() {",
        "\t\t\tif a == b {",
        "\t\t\t\tchmax!(dp[i + 1][j + 1], dp[i][j] + 1);",
        "\t\t\t}",
        "\t\t\tchmax!(dp[i + 1][j + 1], dp[i + 1][j]);",
        "\t\t\tchmax!(dp[i + 1][j + 1], dp[i][j + 1]);",
        "\t\t}",
        "\t}",
        "\tdp[la][lb]",
        "}",
        "/// ## LCS with Vector",
        "/// 最長共通部分列を得る",
        "/// 計算量：O(NM)",
        "pub fn LCS_with_Vec<T: std::cmp::PartialEq + Copy>(A: &[T], B: &[T]) -> Vec<T> {",
        "\tlet (la, lb) = (A.len(), B.len());",
        "\tlet mut dp = vec![vec![0; lb + 1]; la + 1];",
        "\tfor (i, a) in A.iter().enumerate() {",
        "\t\tfor (j, b) in B.iter().enumerate() {",
        "\t\t\tif a == b {",
        "\t\t\t\tchmax!(dp[i + 1][j + 1], dp[i][j] + 1);",
        "\t\t\t}",
        "\t\t\tchmax!(dp[i + 1][j + 1], dp[i + 1][j]);",
        "\t\t\tchmax!(dp[i + 1][j + 1], dp[i][j + 1]);",
        "\t\t}",
        "\t}",
        "\tlet mut res: Vec<T> = vec![];",
        "\tlet (mut cur, mut col) = (0, 0);",
        "\t'outer: for i in 0..la {",
        "\t\tfor j in col..lb {",
        "\t\t\tif cur == dp[i][j] && dp[i][j] < dp[i + 1][j + 1] {",
        "\t\t\t\tres.push(A[i]);",
        "\t\t\t\tcur += 1;",
        "\t\t\t\tcol = j + 1;",
        "\t\t\t}",
        "\t\t\tif cur == dp[la][lb] {",
        "\t\t\t\t// LCSの長さに達したら終了",
        "\t\t\t\tbreak 'outer;",
        "\t\t\t}",
        "\t\t}",
        "\t}",
        "\tres",
        "}"
      ],
      "description": "最長共通部分列"
    },
    {
      "prefix": "modint_comb.rs",
      "body": [
        "use crate::modint::modint::Modint;",
        "/// 二項係数を高速に求める",
        "/// - 前計算: `O(N)`",
        "/// - クエリ: `O(1)`",
        "pub struct Comb<const MOD: usize> {",
        "\tfac: Vec<Modint<MOD>>,",
        "\tfinv: Vec<Modint<MOD>>,",
        "}",
        "impl<const MOD: usize> Comb<MOD> {",
        "\t/// サイズ`max_size`で配列を初期化する",
        "\tpub fn new(max_size: usize) -> Self {",
        "\t\tlet mod1: Modint<MOD> = 1.into();",
        "\t\tlet mut fac = vec![mod1; max_size];",
        "\t\tlet mut finv = vec![mod1; max_size];",
        "\t\tlet mut inv = vec![mod1; max_size];",
        "\t\tfor i in 2..max_size {",
        "\t\t\tfac[i] = fac[i - 1] * i;",
        "\t\t\tinv[i] = -Modint::new(MOD / i) * inv[MOD % i];",
        "\t\t\tfinv[i] = finv[i - 1] * inv[i];",
        "\t\t}",
        "\t\tComb { fac, finv }",
        "\t}",
        "\t/// 順列を求める",
        "\tpub fn comb(&self, n: usize, r: usize) -> Modint<MOD> {",
        "\t\tif n < r {",
        "\t\t\treturn 0.into();",
        "\t\t}",
        "\t\tself.fac[n] * self.finv[r] * self.finv[n - r]",
        "\t}",
        "\t/// 組合せを求める",
        "\tpub fn perm(&self, n: usize, r: usize) -> Modint<MOD> {",
        "\t\tif n < r {",
        "\t\t\treturn 0.into();",
        "\t\t}",
        "\t\tself.fac[n] * self.finv[n - r]",
        "\t}",
        "\t/// 重複を許す組合せ(combination with repetition)",
        "\tpub fn comb_with_rep(&self, n: usize, r: usize) -> Modint<MOD> {",
        "\t\tself.comb(n + r - 1, r)",
        "\t}",
        "}"
      ],
      "description": "階乗を前計算する（Modint構造体に依存）"
    },
    {
      "prefix": "miller_rabin_test.rs",
      "body": [
        "/// 余りをとる累乗",
        "pub fn powmod(a: usize, b: usize, m: usize) -> usize {",
        "\tlet (mut a, mut b, m) = (a as u128, b as u128, m as u128);",
        "\tlet mut res = 1;",
        "\twhile b > 0 {",
        "\t\tif b & 1 == 1 {",
        "\t\t\tres = (res * a) % m;",
        "\t\t}",
        "\t\ta = (a * a) % m;",
        "\t\tb >>= 1;",
        "\t}",
        "\tres as usize",
        "}",
        "/// ## ミラーラビン素数判定法",
        "/// 参考: <https://zenn.dev/kaki_xxx/articles/40a92b43200215>",
        "pub fn is_prime_MR(N: usize) -> bool {",
        "\tif N <= 2 {",
        "\t\treturn N == 2;",
        "\t}",
        "\tif N % 2 == 0 {",
        "\t\treturn false;",
        "\t}",
        "\tlet (mut s, mut d) = (0, N - 1);",
        "\twhile d % 2 == 0 {",
        "\t\ts += 1;",
        "\t\td >>= 1;",
        "\t}",
        "\t// n < 2^64 の場合、以下を調べれば十分",
        "\tlet A = [2, 325, 9375, 28178, 450775, 9780504, 1795265022];",
        "\tfor &a in &A {",
        "\t\tif a % N == 0 {",
        "\t\t\tbreak;",
        "\t\t}",
        "\t\tlet mut t = 0;",
        "\t\tlet mut x = powmod(a, d, N);",
        "\t\tif x != 1 {",
        "\t\t\twhile t < s {",
        "\t\t\t\tif x == N - 1 {",
        "\t\t\t\t\tbreak;",
        "\t\t\t\t}",
        "\t\t\t\tx = ((x as u128).pow(2) % (N as u128)) as usize;",
        "\t\t\t\tt += 1;",
        "\t\t\t}",
        "\t\t\tif t == s {",
        "\t\t\t\treturn false;",
        "\t\t\t}",
        "\t\t}",
        "\t}",
        "\ttrue",
        "}"
      ],
      "description": "ミラー・ラビン素数判定法"
    },
    {
      "prefix": "modint_traits.rs",
      "body": [
        "/// 有限体の実装",
        "pub trait Fp {",
        "\tfn val(&self) -> usize;",
        "\tfn madd(&self, other: usize) -> usize;",
        "\tfn mneg(&self) -> usize;",
        "\tfn msub(&self, other: usize) -> usize;",
        "\tfn mmul(&self, other: usize) -> usize;",
        "\tfn minv(&self) -> usize;",
        "\tfn mdiv(&self, other: usize) -> usize;",
        "\tfn mpow(&self, other: usize) -> usize;",
        "}",
        "impl Fp for usize {",
        "\tfn val(&self) -> usize {",
        "\t\tself % MOD",
        "\t}",
        "\tfn madd(&self, other: usize) -> usize {",
        "\t\t(self.val() + other.val()).val()",
        "\t}",
        "\tfn mneg(&self) -> usize {",
        "\t\t(MOD - self.val()).val()",
        "\t}",
        "\tfn msub(&self, other: usize) -> usize {",
        "\t\tself.madd(other.mneg())",
        "\t}",
        "\tfn mmul(&self, other: usize) -> usize {",
        "\t\t(self.val() * other.val()).val()",
        "\t}",
        "\tfn mpow(&self, other: usize) -> usize {",
        "\t\tlet (mut a, mut b) = (self.val(), other);",
        "\t\tlet mut res = 1;",
        "\t\twhile b > 0 {",
        "\t\t\tif b & 1 == 1 {",
        "\t\t\t\tres = res.mmul(a);",
        "\t\t\t}",
        "\t\t\ta = a.mmul(a);",
        "\t\t\tb >>= 1;",
        "\t\t}",
        "\t\tres",
        "\t}",
        "\tfn minv(&self) -> usize {",
        "\t\tassert!(*self != 0);",
        "\t\tself.mpow(MOD - 2)",
        "\t}",
        "\tfn mdiv(&self, other: usize) -> usize {",
        "\t\tself.mmul(other.minv())",
        "\t}",
        "}",
        "pub trait FpAssign {",
        "\tfn madd_assign(&mut self, other: usize);",
        "\tfn msub_assign(&mut self, other: usize);",
        "\tfn mmul_assign(&mut self, other: usize);",
        "}",
        "impl FpAssign for usize {",
        "\tfn madd_assign(&mut self, other: usize) {",
        "\t\t*self = self.madd(other);",
        "\t}",
        "\tfn mmul_assign(&mut self, other: usize) {",
        "\t\t*self = self.mmul(other);",
        "\t}",
        "\tfn msub_assign(&mut self, other: usize) {",
        "\t\t*self = self.msub(other);",
        "\t}",
        "}",
        "pub const MOD: usize = 998_244_353;",
        "// const MOD: usize = 1_000_000_007;"
      ],
      "description": "Modintをusizeに注入するトレイト"
    },
    {
      "prefix": "binary_search_slice.rs",
      "body": [
        "/// # BinarySearch",
        "/// 二分探索の実装",
        "pub trait BinarySearch<T> {",
        "\tfn lower_bound(&self, x: T) -> usize;",
        "\tfn upper_bound(&self, x: T) -> usize;",
        "}",
        "impl<T: Ord> BinarySearch<T> for [T] {",
        "\t/// ソート済み配列において、`v`以上の最小のインデックスを取得",
        "\tfn lower_bound(&self, v: T) -> usize {",
        "\t\tlet mut ng = 1_usize.wrapping_neg();",
        "\t\tlet mut ok = self.len();",
        "\t\twhile ok.wrapping_sub(ng) > 1 {",
        "\t\t\tlet mid = ng.wrapping_add(ok) / 2;",
        "\t\t\tif v <= self[mid] {",
        "\t\t\t\tok = mid;",
        "\t\t\t} else {",
        "\t\t\t\tng = mid;",
        "\t\t\t}",
        "\t\t}",
        "\t\tok",
        "\t}",
        "\t/// ソート済み配列において、`v`より大きい最小のインデックスを取得",
        "\tfn upper_bound(&self, v: T) -> usize {",
        "\t\tlet mut ng = 1_usize.wrapping_neg();",
        "\t\tlet mut ok = self.len();",
        "\t\twhile ok.wrapping_sub(ng) > 1 {",
        "\t\t\tlet mid = ng.wrapping_add(ok) / 2;",
        "\t\t\tif v < self[mid] {",
        "\t\t\t\tok = mid;",
        "\t\t\t} else {",
        "\t\t\t\tng = mid;",
        "\t\t\t}",
        "\t\t}",
        "\t\tok",
        "\t}",
        "}"
      ],
      "description": "sliceに対する`lower_bound`,`upper_bound`の実装"
    },
    {
      "prefix": "comb.rs",
      "body": [
        "const MOD: usize = 998_244_353;",
        "// const MOD: usize = 1_000_000_007;",
        "/// # Comb",
        "/// 二項係数を高速に求める",
        "/// - 前計算: `O(N)`",
        "/// - クエリ: `O(1)`",
        "pub struct Comb {",
        "\tfac: Vec<usize>,",
        "\tfinv: Vec<usize>,",
        "}",
        "impl Comb {",
        "\t/// サイズ`max_size`で配列を初期化する",
        "\tpub fn new(max_size: usize) -> Self {",
        "\t\tlet mut fac = vec![1; max_size];",
        "\t\tlet mut finv = vec![1; max_size];",
        "\t\tlet mut inv = vec![1; max_size];",
        "\t\tfor i in 2..max_size {",
        "\t\t\tfac[i] = fac[i - 1] * i % MOD;",
        "\t\t\tinv[i] = MOD - (MOD / i) * inv[MOD % i] % MOD;",
        "\t\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;",
        "\t\t}",
        "\t\tComb { fac, finv }",
        "\t}",
        "\t/// `nCr`を`MOD`で割った値を求める",
        "\tpub fn comb(&self, n: usize, r: usize) -> usize {",
        "\t\tif n < r {",
        "\t\t\treturn 0;",
        "\t\t}",
        "\t\tself.fac[n] * (self.finv[r] * self.finv[n - r] % MOD) % MOD",
        "\t}",
        "\t/// `nPr`を`MOD`で割った値を求める",
        "\tpub fn perm(&self, n: usize, r: usize) -> usize {",
        "\t\tif n < r {",
        "\t\t\treturn 0;",
        "\t\t}",
        "\t\tself.fac[n] * self.finv[n - r] % MOD",
        "\t}",
        "}"
      ],
      "description": "二項係数を求める"
    },
    {
      "prefix": "rolling_hash.rs",
      "body": [
        "/// # Modint",
        "pub trait Modint {",
        "\tconst MOD: usize;",
        "\tfn madd(&self, other: usize) -> usize;",
        "\tfn msub(&self, other: usize) -> usize;",
        "\tfn mmul(&self, other: usize) -> usize;",
        "}",
        "impl Modint for usize {",
        "\tconst MOD: usize = (1 << 61) - 1;",
        "\tfn madd(&self, other: usize) -> usize {",
        "\t\t(*self + other) % Self::MOD",
        "\t}",
        "\tfn msub(&self, other: usize) -> usize {",
        "\t\t(Self::MOD + *self - other) % Self::MOD",
        "\t}",
        "\tfn mmul(&self, other: usize) -> usize {",
        "\t\tlet res: u128 = (*self as u128) * (other as u128);",
        "\t\t(res % Self::MOD as u128) as usize",
        "\t}",
        "}",
        "/// # RollingHash",
        "/// 文字列の比較を高速に行う",
        "/// - 計算量: `O(n+m)`",
        "#[derive(Debug)]",
        "pub struct RollingHash {",
        "\tpub size: usize,",
        "\tpower: Vec<usize>,",
        "\thash: Vec<usize>,",
        "\tbase: usize,",
        "}",
        "impl RollingHash {",
        "\t/// 初期化",
        "\tpub fn build(arr: &[usize], base: usize) -> Self {",
        "\t\tlet size = arr.len();",
        "\t\tlet mut power = vec![0; size + 1];",
        "\t\tlet mut hash = vec![0; size + 1];",
        "\t\t// hashを初期化",
        "\t\tlet (mut h, mut p) = (0, 1);",
        "\t\tfor i in 0..size {",
        "\t\t\th = arr[i].madd(h.mmul(base));",
        "\t\t\tp = p.mmul(base);",
        "\t\t\thash[i + 1] = h;",
        "\t\t\tpower[i + 1] = p;",
        "\t\t}",
        "\t\tSelf {",
        "\t\t\tsize,",
        "\t\t\tpower,",
        "\t\t\thash,",
        "\t\t\tbase,",
        "\t\t}",
        "\t}",
        "\t/// 文字列から生成",
        "\tpub fn from_str(s: &str, base: usize) -> Self {",
        "\t\tlet arr: Vec<usize> = s.chars().map(Self::ord).collect();",
        "\t\tSelf::build(&arr, base)",
        "\t}",
        "\t/// `l..r`のハッシュを取得",
        "\t/// - 計算量: `O(1)`",
        "\tpub fn get(&self, l: usize, r: usize) -> usize {",
        "\t\tself.hash[r].msub(self.hash[l].mmul(self.power[r - l]))",
        "\t}",
        "\t/// `0..size`のハッシュを取得",
        "\t/// - 計算量: `O(1)`",
        "\tpub fn full(&self) -> usize {",
        "\t\tself.hash[self.size]",
        "\t}",
        "\t/// a,bからの最長共通接頭辞の長さを調べる",
        "\t/// - 計算量: `O(log N)`",
        "\tpub fn getLCP(&self, a: usize, b: usize) -> usize {",
        "\t\tlet len = self.size.saturating_sub(a.max(b));",
        "\t\tlet (mut lo, mut hi) = (0, len + 1);",
        "\t\twhile hi - lo > 1 {",
        "\t\t\tlet mid = (lo + hi) / 2;",
        "\t\t\tif self.get(a, a + mid) == self.get(b, b + mid) {",
        "\t\t\t\tlo = mid;",
        "\t\t\t} else {",
        "\t\t\t\thi = mid;",
        "\t\t\t}",
        "\t\t}",
        "\t\tlo",
        "\t}",
        "\t/// ハッシュ同士を連結",
        "\t/// - 計算量: `O(1)`",
        "\tpub fn concat(&self, h1: usize, h2: usize, h2_len: usize) -> usize {",
        "\t\th1.mmul(self.power[h2_len]).madd(h2)",
        "\t}",
        "\t/// `A`を`0`とするascii文字(`A~Za~z`)のインデックスを返す",
        "\tfn ord(c: char) -> usize {",
        "\t\tlet a = 'A' as u32;",
        "\t\tlet c = c as u32;",
        "\t\t(c - a) as usize",
        "\t}",
        "}"
      ],
      "description": "ローリングハッシュ"
    },
    {
      "prefix": "powmod.rs",
      "body": [
        "/// 余りをとる累乗",
        "pub fn powmod(mut a: usize, mut b: usize, m: usize) -> usize {",
        "\tlet mut res = 1;",
        "\twhile b > 0 {",
        "\t\tif b & 1 == 1 {",
        "\t\t\tres = (res * a) % m;",
        "\t\t}",
        "\t\ta = (a * a) % m;",
        "\t\tb >>= 1;",
        "\t}",
        "\tres",
        "}"
      ],
      "description": "あまりを取る累乗"
    },
    {
      "prefix": "factors.rs",
      "body": [
        "/// # 前計算ありの高速素因数分解",
        "/// `N`までの数の素因数分解を",
        "/// - 前計算: `O(NloglogN)`",
        "/// - クエリ: `O(logN)`",
        "/// で行う。",
        "pub struct Factors {",
        "\tn: usize,",
        "\tsieve: Vec<usize>,",
        "}",
        "impl Factors {",
        "\t/// 前計算を行う",
        "\t/// - `O(NloglogN)`で篩を作成",
        "\tpub fn new(n: usize) -> Self {",
        "\t\tlet mut facs = Factors {",
        "\t\t\tn,",
        "\t\t\tsieve: vec![1; n + 1],",
        "\t\t};",
        "\t\tfor i in 2..=n {",
        "\t\t\tfor j in 1.. {",
        "\t\t\t\tif i * j > n {",
        "\t\t\t\t\tbreak;",
        "\t\t\t\t}",
        "\t\t\t\tif facs.sieve[i * j] == 1 {",
        "\t\t\t\t\tfacs.sieve[i * j] = i;",
        "\t\t\t\t}",
        "\t\t\t}",
        "\t\t}",
        "\t\tfacs",
        "\t}",
        "\t/// 素因数分解を`O(logn)`で行う",
        "\t/// ### 戻り値",
        "\t/// - `Vec<usize>`: 素因数のリスト",
        "\tpub fn factorize(&self, mut x: usize) -> Vec<usize> {",
        "\t\tassert!(1 <= x && x <= self.n);",
        "\t\tlet mut factors = vec![];",
        "\t\twhile x > 1 {",
        "\t\t\tfactors.push(self.sieve[x]);",
        "\t\t\tx /= self.sieve[x];",
        "\t\t}",
        "\t\tfactors",
        "\t}",
        "\t/// 素因数分解を`O(logn)`で行う",
        "\t/// ### 戻り値",
        "\t/// - `Vec<(usize, usize)>`: (素因数, その個数)",
        "\tpub fn factorize_pairs(&self, mut x: usize) -> Vec<(usize, usize)> {",
        "\t\tassert!(1 <= x && x <= self.n);",
        "\t\tlet mut pairs: Vec<(usize, usize)> = vec![];",
        "\t\twhile x > 1 {",
        "\t\t\tlet p = self.sieve[x];",
        "\t\t\tif !pairs.is_empty() && pairs.last().unwrap().0 == p {",
        "\t\t\t\tpairs.last_mut().unwrap().1 += 1",
        "\t\t\t} else {",
        "\t\t\t\tpairs.push((p, 1));",
        "\t\t\t}",
        "\t\t\tx /= self.sieve[x];",
        "\t\t}",
        "\t\tpairs",
        "\t}",
        "}"
      ],
      "description": "前計算ありの高速素因数分解"
    },
    {
      "prefix": "coordinate_compression.rs",
      "body": [
        "/// # 座標圧縮",
        "#[derive(Debug)]",
        "pub struct Compression<'a, T> {",
        "\tpub size: usize,",
        "\tpub sorted_array: Vec<&'a T>,",
        "}",
        "impl<'a, T: Ord> Compression<'a, T> {",
        "\t/// スライス`array`で配列を初期化する",
        "\tpub fn new(array: &'a [T]) -> Self {",
        "\t\tlet mut comp: Vec<&T> = array.iter().collect();",
        "\t\tcomp.sort();",
        "\t\tcomp.dedup();",
        "\t\tSelf {",
        "\t\t\tsize: comp.len(),",
        "\t\t\tsorted_array: comp,",
        "\t\t}",
        "\t}",
        "\t/// 圧縮後の`val`の番号を返す",
        "\tpub fn idx(&self, val: &T) -> Option<usize> {",
        "\t\tlet idx = self.sorted_array.binary_search(&val);",
        "\t\tif let Ok(idx) = idx {",
        "\t\t\tSome(idx)",
        "\t\t} else {",
        "\t\t\tNone",
        "\t\t}",
        "\t}",
        "\t/// 圧縮前の要素`idx`を返す",
        "\tpub fn val(&self, idx: usize) -> Option<&T> {",
        "\t\tif let Some(&val) = self.sorted_array.get(idx) {",
        "\t\t\tSome(val)",
        "\t\t} else {",
        "\t\t\tNone",
        "\t\t}",
        "\t}",
        "}"
      ],
      "description": "座標圧縮"
    },
    {
      "prefix": "lca.rs",
      "body": [
        "const INF: usize = 1001001001001001001;",
        "type Graph = Vec<Vec<usize>>;",
        "/// # LCA",
        "/// 最小共通祖先を求めるクエリに答える",
        "pub struct LCA {",
        "\tdouble: Vec<Vec<usize>>,",
        "\tdepth: Vec<usize>,",
        "}",
        "impl LCA {",
        "\t/// `root`を根に持つ木`tree`で、初期化を行う",
        "\tpub fn new(tree: &Graph, root: usize) -> Self {",
        "\t\tlet V = tree.len(); // グラフの頂点数",
        "\t\tlet logV = {",
        "\t\t\t// log_2(グラフの頂点数)",
        "\t\t\tlet mut logv = 0;",
        "\t\t\twhile (V >> logv) > 0 {",
        "\t\t\t\tlogv += 1;",
        "\t\t\t}",
        "\t\t\tlogv",
        "\t\t};",
        "\t\tlet mut double = vec![vec![0; V]; logV]; // ダブリング配列",
        "\t\tlet mut depth = vec![INF; V]; // 頂点の根からの距離",
        "\t\tdepth[0] = 0;",
        "\t\tSelf::dfs(root, &mut double[0], &mut depth, tree);",
        "\t\t// ダブリング",
        "\t\tfor i in 1..logV {",
        "\t\t\tfor j in 0..V {",
        "\t\t\t\tdouble[i][j] = double[i - 1][double[i - 1][j]];",
        "\t\t\t}",
        "\t\t}",
        "\t\tSelf { double, depth }",
        "\t}",
        "\tfn dfs(u: usize, par: &mut Vec<usize>, depth: &mut Vec<usize>, tree: &Graph) {",
        "\t\tfor &v in &tree[u] {",
        "\t\t\tif depth[v] != INF {",
        "\t\t\t\tcontinue;",
        "\t\t\t}",
        "\t\t\tdepth[v] = depth[u] + 1;",
        "\t\t\tpar[v] = u;",
        "\t\t\tSelf::dfs(v, par, depth, tree);",
        "\t\t}",
        "\t}",
        "\t/// 頂点`u`,`v`の最小共通祖先を求める",
        "\tpub fn get_lca(&self, mut u: usize, mut v: usize) -> usize {",
        "\t\t// 常にuを深くする",
        "\t\tif self.depth[u] < self.depth[v] {",
        "\t\t\tstd::mem::swap(&mut u, &mut v);",
        "\t\t}",
        "\t\t// LCAまでの距離を同じにする",
        "\t\tfor k in 0..self.double.len() {",
        "\t\t\tif ((self.depth[u] - self.depth[v]) >> k) & 1 == 1 {",
        "\t\t\t\tu = self.double[k][u];",
        "\t\t\t}",
        "\t\t}",
        "\t\tif u == v {",
        "\t\t\treturn u;",
        "\t\t}",
        "\t\t// 二分探索",
        "\t\tfor k in (0..self.double.len()).rev() {",
        "\t\t\tif self.double[k][u] != self.double[k][v] {",
        "\t\t\t\tu = self.double[k][u];",
        "\t\t\t\tv = self.double[k][v];",
        "\t\t\t}",
        "\t\t}",
        "\t\tself.double[0][u]",
        "\t}",
        "\t/// 頂点`u`,`v`の距離を求める",
        "\tpub fn dist(&self, u: usize, v: usize) -> usize {",
        "\t\tlet o = self.get_lca(u, v);",
        "\t\t(self.depth[u] - self.depth[o]) + (self.depth[v] - self.depth[o])",
        "\t}",
        "}"
      ],
      "description": "ダブリングにより、最小共通祖先を求める"
    },
    {
      "prefix": "pollard_rho_method.rs",
      "body": [
        "use crate::miller_rabin_test::is_prime_MR;",
        "/// `a`,`b`の最大公約数を求める",
        "pub fn gcd(a: usize, b: usize) -> usize {",
        "\tif b == 0 {",
        "\t\ta",
        "\t} else {",
        "\t\tgcd(b, a % b)",
        "\t}",
        "}",
        "/// ## pollard_rho",
        "/// ポラード・ロー法を適用し、約数を見つける",
        "pub fn pollard_rho(N: usize) -> usize {",
        "\tif N % 2 == 0 {",
        "\t\treturn 2;",
        "\t}",
        "\tif is_prime_MR(N) {",
        "\t\treturn N;",
        "\t}",
        "\tlet f = |x: usize| -> usize { (((x as u128).pow(2) + 1) % N as u128) as usize };",
        "\tlet mut step = 0;",
        "\tloop {",
        "\t\tstep += 1;",
        "\t\tlet mut x = step;",
        "\t\tlet mut y = f(x);",
        "\t\tloop {",
        "\t\t\tlet p = gcd(N + y - x, N);",
        "\t\t\tif p == 0 || p == N {",
        "\t\t\t\tbreak;",
        "\t\t\t}",
        "\t\t\tif p != 1 {",
        "\t\t\t\treturn p;",
        "\t\t\t}",
        "\t\t\tx = f(x);",
        "\t\t\ty = f(f(y));",
        "\t\t}",
        "\t}",
        "}",
        "/// ## factorize",
        "/// ポラード・ロー法による高速素因数分解",
        "/// `O(n^(1/4))`",
        "pub fn factorize(N: usize) -> Vec<usize> {",
        "\tif N == 1 {",
        "\t\treturn vec![];",
        "\t}",
        "\tlet p = pollard_rho(N);",
        "\tif p == N {",
        "\t\treturn vec![N];",
        "\t}",
        "\tlet mut left = factorize(p);",
        "\tlet mut right = factorize(N / p);",
        "\tleft.append(&mut right);",
        "\tleft.sort();",
        "\tleft",
        "}"
      ],
      "description": "ポラード・ロー法による素因数分解"
    },
    {
      "prefix": "dijkstra.rs",
      "body": [
        "use std::cmp::Reverse;",
        "use std::collections::BinaryHeap;",
        "/// Dijkstra法",
        "/// - グラフ`graph`が与えられたとき、スタート地点`s`から各頂点への最短路を求める",
        "pub fn dijkstra(graph: &Vec<Vec<(usize, usize)>>, s: usize) -> Vec<usize> {",
        "\tconst INF: usize = 1001001001001001001;",
        "\tlet n: usize = graph.len();",
        "\tlet mut dist: Vec<usize> = vec![INF; n];",
        "\tlet mut pq: BinaryHeap<Reverse<(usize, usize)>> = BinaryHeap::new();",
        "\t// 初期化",
        "\tdist[s] = 0;",
        "\tpq.push(Reverse((dist[s], s)));",
        "\t// 更新",
        "\twhile let Some(Reverse((cost, u))) = pq.pop() {",
        "\t\tif dist[u] < cost {",
        "\t\t\tcontinue;",
        "\t\t}",
        "\t\tfor &(v, weight) in &graph[u] {",
        "\t\t\tif dist[v] > dist[u] + weight {",
        "\t\t\t\tdist[v] = dist[u] + weight;",
        "\t\t\t\tpq.push(Reverse((dist[v], v)));",
        "\t\t\t}",
        "\t\t}",
        "\t}",
        "\tdist",
        "}"
      ],
      "description": "ダイクストラ法"
    },
    {
      "prefix": "grid.rs",
      "body": [
        "/// グリッドの探索",
        "pub trait Grid<T>",
        "where",
        "\tSelf: Sized,",
        "{",
        "\t/// usizeにおける-1",
        "\tconst NEG1: T;",
        "\t/// 隣接する4方向（上下左右）",
        "\tconst ADJ4: [(T, T); 4];",
        "\t/// 隣接する8方向",
        "\tconst ADJ8: [(T, T); 8];",
        "\t/// 座標`(i,j)`に上下左右で隣接する座標を取得",
        "\t/// - グリッドサイズ`HxW`でバリデーション",
        "\tfn get_adj_4(&self, H: usize, W: usize) -> Vec<Self>;",
        "\t/// 座標`(i,j)`に8方向で隣接する座標を取得",
        "\t/// - グリッドサイズ`HxW`でバリデーション",
        "\tfn get_adj_8(&self, H: usize, W: usize) -> Vec<Self>;",
        "}",
        "impl Grid<usize> for (usize, usize) {",
        "\tconst NEG1: usize = 1_usize.wrapping_neg();",
        "\tconst ADJ4: [(usize, usize); 4] = [(0, Self::NEG1), (Self::NEG1, 0), (0, 1), (1, 0)];",
        "\tconst ADJ8: [(usize, usize); 8] = [",
        "\t\t(Self::NEG1, Self::NEG1),",
        "\t\t(Self::NEG1, 0),",
        "\t\t(Self::NEG1, 1),",
        "\t\t(0, Self::NEG1),",
        "\t\t(0, 1),",
        "\t\t(1, Self::NEG1),",
        "\t\t(1, 0),",
        "\t\t(1, 1),",
        "\t];",
        "\tfn get_adj_4(&self, H: usize, W: usize) -> Vec<(usize, usize)> {",
        "\t\tlet mut adj = vec![];",
        "\t\tfor &(dr, dc) in &Self::ADJ4 {",
        "\t\t\tlet nr = self.0.wrapping_add(dr);",
        "\t\t\tlet nc = self.1.wrapping_add(dc);",
        "\t\t\tif nr < H && nc < W {",
        "\t\t\t\tadj.push((nr, nc));",
        "\t\t\t}",
        "\t\t}",
        "\t\tadj",
        "\t}",
        "\tfn get_adj_8(&self, H: usize, W: usize) -> Vec<(usize, usize)> {",
        "\t\tlet mut adj = vec![];",
        "\t\tfor &(dr, dc) in &Self::ADJ8 {",
        "\t\t\tlet nr = self.0.wrapping_add(dr);",
        "\t\t\tlet nc = self.1.wrapping_add(dc);",
        "\t\t\tif nr < H && nc < W {",
        "\t\t\t\tadj.push((nr, nc));",
        "\t\t\t}",
        "\t\t}",
        "\t\tadj",
        "\t}",
        "}"
      ],
      "description": "グリッド探索の便利ツール"
    },
    {
      "prefix": "binary_search_btreeset.rs",
      "body": [
        "use std::collections::BTreeSet;",
        "use std::ops::Bound::{Excluded, Included, Unbounded};",
        "/// # BinarySearch",
        "/// 二分探索",
        "pub trait BinarySearch<T> {",
        "\tfn lower_bound(&self, x: &T) -> Option<&T>;",
        "\tfn upper_bound(&self, x: &T) -> Option<&T>;",
        "}",
        "impl<T: Ord> BinarySearch<T> for BTreeSet<T> {",
        "\t/// x以上の値を探索する",
        "\tfn lower_bound(&self, x: &T) -> Option<&T> {",
        "\t\tlet mut greater_equal = self.range((Included(x), Unbounded));",
        "\t\tgreater_equal.next()",
        "\t}",
        "\t/// xより大きい値を探索する",
        "\tfn upper_bound(&self, x: &T) -> Option<&T> {",
        "\t\tlet mut greater_equal = self.range((Excluded(x), Unbounded));",
        "\t\tgreater_equal.next()",
        "\t}",
        "}"
      ],
      "description": "BTreeSetに対する`lower_bound`,`upper_bound`の実装"
    },
    {
      "prefix": "union_find.rs",
      "body": [
        "/// # UnionFind",
        "/// 参考: [RustでUnionFind](https://zenn.dev/nakamurus/articles/f398b7f4d7618ea5b7eb)",
        "pub struct UnionFind {",
        "\tpar: Vec<usize>,",
        "\tsiz: Vec<usize>,",
        "\t/// 連結成分の個数",
        "\tpub group_count: usize,",
        "}",
        "impl UnionFind {",
        "\t/// UnionFindを新規作成",
        "\tpub fn new(n: usize) -> Self {",
        "\t\tUnionFind {",
        "\t\t\tpar: (0..n).collect(),",
        "\t\t\tsiz: vec![1; n],",
        "\t\t\tgroup_count: n,",
        "\t\t}",
        "\t}",
        "\t/// 根を求める",
        "\tpub fn root(&mut self, x: usize) -> usize {",
        "\t\tif self.par[x] == x {",
        "\t\t\treturn x;",
        "\t\t}",
        "\t\tself.par[x] = self.root(self.par[x]); // 経路圧縮",
        "\t\tself.par[x]",
        "\t}",
        "\t/// 同一の集合に所属するか判定",
        "\tpub fn issame(&mut self, x: usize, y: usize) -> bool {",
        "\t\tself.root(x) == self.root(y)",
        "\t}",
        "\t/// 要素を結合",
        "\tpub fn unite(&mut self, mut parent: usize, mut child: usize) -> bool {",
        "\t\tparent = self.root(parent);",
        "\t\tchild = self.root(child);",
        "\t\tif parent == child {",
        "\t\t\treturn false;",
        "\t\t}",
        "\t\t// 要素数が大きい方を子にすることで、高さを均等に保つ",
        "\t\tif self.siz[parent] < self.siz[child] {",
        "\t\t\tstd::mem::swap(&mut parent, &mut child);",
        "\t\t}",
        "\t\tself.par[child] = parent;",
        "\t\tself.siz[parent] += self.siz[child];",
        "\t\tself.group_count -= 1;",
        "\t\ttrue",
        "\t}",
        "\t/// 連結成分の大きさを求める",
        "\tpub fn size(&mut self, x: usize) -> usize {",
        "\t\tlet root = self.root(x);",
        "\t\tself.siz[root]",
        "\t}",
        "}"
      ],
      "description": "UnionFind木"
    },
    {
      "prefix": "vec2.rs",
      "body": [
        "use std::ops::{Add, Mul, Neg, Sub};",
        "pub type Pos<T> = (T, T);",
        "pub type Line<T> = (Pos<T>, Pos<T>);",
        "/// ベクトル演算を行う",
        "pub trait Vec2<T> {",
        "\tfn mul(&self, scalar: T) -> Self;",
        "\tfn add(&self, other: Self) -> Self;",
        "\tfn sub(&self, other: Self) -> Self;",
        "\t/// ドット積",
        "\tfn dot(&self, other: Self) -> T;",
        "\t/// クロス積",
        "\tfn cross(&self, other: Self) -> T;",
        "\t/// L2-ノルム（の2乗）",
        "\tfn dist2(&self, other: Self) -> T;",
        "}",
        "impl<T> Vec2<T> for Pos<T>",
        "where",
        "\tT: Copy + Add<Output = T> + Sub<Output = T> + Mul<Output = T> + Neg,",
        "{",
        "\tfn mul(&self, scalar: T) -> Self {",
        "\t\t(self.0 * scalar, self.1 * scalar)",
        "\t}",
        "\tfn add(&self, other: Self) -> Self {",
        "\t\t(self.0 + other.0, self.1 + other.1)",
        "\t}",
        "\tfn sub(&self, other: Self) -> Self {",
        "\t\t(self.0 - other.0, self.1 - other.1)",
        "\t}",
        "\tfn dot(&self, other: Self) -> T {",
        "\t\tself.0 * other.0 + self.1 * other.1",
        "\t}",
        "\tfn cross(&self, other: Self) -> T {",
        "\t\t(self.0 * other.1) - (other.0 * self.1)",
        "\t}",
        "\tfn dist2(&self, other: Self) -> T {",
        "\t\t(self.0 - other.0) * (self.0 - other.0) + (self.1 - other.1) * (self.1 - other.1)",
        "\t}",
        "}",
        "/// 線分abと線分xyが衝突しているかどうか",
        "pub fn is_collided(ab: Line<isize>, xy: Line<isize>) -> bool {",
        "\tlet (a, b) = ab;",
        "\tlet (x, y) = xy;",
        "\t// Aから見たとき",
        "\tlet AX = x.sub(a);",
        "\tlet AY = y.sub(a);",
        "\tlet AB = b.sub(a);",
        "\t// Xから見たとき",
        "\tlet XA = a.sub(x);",
        "\tlet XB = b.sub(x);",
        "\tlet XY = y.sub(x);",
        "\tAB.cross(AX) * AB.cross(AY) < 0 && XY.cross(XA) * XY.cross(XB) < 0",
        "}"
      ],
      "description": "幾何ライブラリ"
    },
    {
      "prefix": "factorize.rs",
      "body": [
        "/// - 素因数分解し、`(素因数,指数)`のペアを返す",
        "pub fn factorize(mut n: usize) -> Vec<(usize, usize)> {",
        "\tlet mut res = Vec::new();",
        "\tfor i in 2.. {",
        "\t\tif i * i > n {",
        "\t\t\tbreak;",
        "\t\t}",
        "\t\tlet mut cnt = 0;",
        "\t\twhile n % i == 0 {",
        "\t\t\tn /= i;",
        "\t\t\tcnt += 1;",
        "\t\t}",
        "\t\tif cnt >= 1 {",
        "\t\t\tres.push((i, cnt));",
        "\t\t}",
        "\t}",
        "\tif n > 1 {",
        "\t\tres.push((n, 1));",
        "\t}",
        "\tres",
        "}"
      ],
      "description": "素因数分解"
    },
    {
      "prefix": "trie.rs",
      "body": [
        "use std::fmt::Debug;",
        "// 定数",
        "const ORIGIN: char = 'a'; // 基準となる文字",
        "const ORIGIN_ID: usize = ORIGIN as u32 as usize; // 基準となる文字のID",
        "const KINDS: usize = 26; // 文字の種類数",
        "type NodePointer<T> = Option<Box<TrieNode<T>>>;",
        "/// 何番目の文字かを判定する",
        "fn ord(c: char) -> usize {",
        "\tlet num = c as u32 as usize;",
        "\tnum - ORIGIN_ID",
        "}",
        "/// i番目の文字を返す",
        "fn chr(i: usize) -> char {",
        "\t(ORIGIN_ID + i) as u8 as char",
        "}",
        "/// # TrieNode",
        "/// - トライ木のノード",
        "#[derive(Debug, Clone)]",
        "struct TrieNode<T> {",
        "\tdata: Option<T>,",
        "\tchildren: Vec<NodePointer<T>>,",
        "}",
        "impl<T> TrieNode<T>",
        "where",
        "\tT: Clone,",
        "{",
        "\tpub fn new(data: Option<T>) -> Self {",
        "\t\tSelf {",
        "\t\t\tdata,",
        "\t\t\tchildren: vec![NodePointer::None; KINDS],",
        "\t\t}",
        "\t}",
        "}",
        "/// # Trie",
        "/// - トライ木の実装",
        "#[derive(Debug)]",
        "pub struct Trie<T> {",
        "\troot: NodePointer<T>,",
        "}",
        "impl<T> Trie<T>",
        "where",
        "\tT: Clone + Debug,",
        "{",
        "\t// self.originを基準にした文字の番号を返す",
        "\t// fn ord()",
        "\tpub fn new() -> Self {",
        "\t\tTrie {",
        "\t\t\troot: Some(Box::new(TrieNode {",
        "\t\t\t\tdata: None,",
        "\t\t\t\tchildren: vec![NodePointer::None; KINDS],",
        "\t\t\t})),",
        "\t\t}",
        "\t}",
        "\tpub fn insert(&mut self, key: &str, data: T) {",
        "\t\t*self.get_or_insert_mut(key) = Some(data);",
        "\t}",
        "\tpub fn get(&self, key: &str) -> Option<&T> {",
        "\t\tlet mut node = &self.root;",
        "\t\tfor c in key.chars().map(ord) {",
        "\t\t\tnode = &node.as_ref()?.children[c];",
        "\t\t}",
        "\t\tnode.as_deref()?.data.as_ref()",
        "\t}",
        "\tpub fn get_mut(&mut self, key: &str) -> Option<&mut T> {",
        "\t\tlet mut node = &mut self.root;",
        "\t\tfor c in key.chars().map(ord) {",
        "\t\t\tnode = node.as_mut()?.children.get_mut(c).unwrap();",
        "\t\t}",
        "\t\tnode.as_deref_mut()?.data.as_mut()",
        "\t}",
        "\tpub fn get_or_insert_mut(&mut self, key: &str) -> &mut Option<T> {",
        "\t\tlet mut node = &mut self.root;",
        "\t\tfor c in key.chars().map(ord).chain(KINDS..=KINDS) {",
        "\t\t\t// データの挿入",
        "\t\t\tif c == KINDS {",
        "\t\t\t\tif node.as_ref().is_none() {",
        "\t\t\t\t\t*node = Some(Box::new(TrieNode::new(None)));",
        "\t\t\t\t}",
        "\t\t\t\tbreak;",
        "\t\t\t}",
        "\t\t\tif node.as_ref().is_none() {",
        "\t\t\t\t*node = Some(Box::new(TrieNode::new(None)));",
        "\t\t\t}",
        "\t\t\tnode = node.as_mut().unwrap().children.get_mut(c).unwrap();",
        "\t\t}",
        "\t\t&mut node.as_deref_mut().unwrap().data",
        "\t}",
        "\tpub fn traverse(&self) -> Vec<(String, &T)> {",
        "\t\tlet mut res = vec![];",
        "\t\tlet mut cur = String::new();",
        "\t\ttraverse_inner(&self.root, &mut cur, &mut res);",
        "\t\tres",
        "\t}",
        "}",
        "/// trieを順に探索する",
        "fn traverse_inner<'a, T>(",
        "\tnode: &'a NodePointer<T>,",
        "\tcur: &mut String,",
        "\tlist: &mut Vec<(String, &'a T)>,",
        ") {",
        "\tif let Some(value) = node.as_ref().unwrap().data.as_ref() {",
        "\t\tlet key = cur.clone();",
        "\t\tlist.push((key, value));",
        "\t}",
        "\tif let Some(node) = node.as_deref() {",
        "\t\tfor (i, child) in node.children.iter().enumerate() {",
        "\t\t\tif child.as_ref().is_some() {",
        "\t\t\t\tcur.push(chr(i));",
        "\t\t\t\ttraverse_inner(child, cur, list);",
        "\t\t\t\tcur.pop();",
        "\t\t\t}",
        "\t\t}",
        "\t}",
        "}"
      ],
      "description": "トライ木"
    },
    {
      "prefix": "simple_graph.rs",
      "body": [
        "type Graph = Vec<Vec<usize>>;",
        "/// # 単純グラフ",
        "/// 単純グラフに対して",
        "/// - 連結成分分解",
        "/// - 2部グラフ分解",
        "///",
        "/// を行う。",
        "#[derive(Debug)]",
        "pub struct SimpleGraph {",
        "\tpub V: usize,",
        "\tpub E: usize,",
        "\tpub graph: Graph,",
        "\tpub edges: Vec<(usize, usize)>,",
        "\tpub component_size: Option<usize>,",
        "\tpub components: Vec<usize>,",
        "}",
        "impl SimpleGraph {",
        "\tconst INF: usize = 1_000_000_000_000_000_000;",
        "\t/// グラフの構築",
        "\tpub fn new(V: usize) -> Self {",
        "\t\tSelf {",
        "\t\t\tV,",
        "\t\t\tE: 0,",
        "\t\t\tgraph: vec![vec![]; V],",
        "\t\t\tedges: vec![],",
        "\t\t\tcomponent_size: None,",
        "\t\t\tcomponents: vec![Self::INF; V],",
        "\t\t}",
        "\t}",
        "\t/// 辺の追加",
        "\tpub fn add_edge(&mut self, u: usize, v: usize) {",
        "\t\tself.E += 1;",
        "\t\tself.edges.push((u, v));",
        "\t\tself.graph[u].push(v);",
        "\t\tself.graph[v].push(u);",
        "\t}",
        "\t/// 連結成分に分解：O(|V|+|E|)",
        "\tpub fn decompose(&mut self) {",
        "\t\tlet mut component = 0;",
        "\t\tself.components = vec![Self::INF; self.V];",
        "\t\tfor i in 0..self.V {",
        "\t\t\tif self.components[i] != Self::INF {",
        "\t\t\t\tcontinue;",
        "\t\t\t}",
        "\t\t\tself.components[i] = component;",
        "\t\t\tlet mut stack = vec![i];",
        "\t\t\twhile let Some(u) = stack.pop() {",
        "\t\t\t\tfor &v in &self.graph[u] {",
        "\t\t\t\t\tif self.components[v] == Self::INF {",
        "\t\t\t\t\t\tself.components[v] = component;",
        "\t\t\t\t\t\tstack.push(v);",
        "\t\t\t\t\t}",
        "\t\t\t\t}",
        "\t\t\t}",
        "\t\t\tcomponent += 1;",
        "\t\t}",
        "\t\tself.component_size = Some(component);",
        "\t}",
        "\t/// 2部グラフ判定：O(|V|+|E|)",
        "\tpub fn bipartite(&mut self) -> Option<Vec<isize>> {",
        "\t\t// 未だ連結成分分解されていない場合",
        "\t\tif self.component_size.is_none() {",
        "\t\t\tself.decompose();",
        "\t\t}",
        "\t\tlet mut res: Vec<isize> = vec![0; self.V];",
        "\t\tfor i in 0..self.V {",
        "\t\t\tlet mut stack = vec![i];",
        "\t\t\tif res[i] != 0 {",
        "\t\t\t\tcontinue;",
        "\t\t\t}",
        "\t\t\tres[i] = self.components[i] as isize + 1;",
        "\t\t\twhile let Some(u) = stack.pop() {",
        "\t\t\t\tfor &v in &self.graph[u] {",
        "\t\t\t\t\tif res[v] == res[u] {",
        "\t\t\t\t\t\treturn None;",
        "\t\t\t\t\t}",
        "\t\t\t\t\tif res[v] == 0 {",
        "\t\t\t\t\t\tres[v] = -res[u];",
        "\t\t\t\t\t\tstack.push(v);",
        "\t\t\t\t\t}",
        "\t\t\t\t}",
        "\t\t\t}",
        "\t\t}",
        "\t\tSome(res)",
        "\t}",
        "}"
      ],
      "description": "単純グラフの処理"
    },
    {
      "prefix": "tree_dp.rs",
      "body": [
        "type Graph = Vec<Vec<usize>>;",
        "/// # Monoid",
        "pub trait Monoid {",
        "\ttype Val: Clone + PartialEq;",
        "\tconst E: Self::Val;",
        "\tfn op(u: &Self::Val, v: &Self::Val) -> Self::Val;",
        "\tfn apply(val: &Self::Val) -> Self::Val;",
        "}",
        "/// # 木DP",
        "struct TreeDP<T: Monoid> {",
        "\tpub N: usize,",
        "\tpub G: Graph,",
        "\tdp: Vec<T::Val>,",
        "}",
        "impl<T: Monoid> TreeDP<T> {",
        "\t/// 頂点数`N`でグラフを初期化する",
        "\tpub fn new(N: usize) -> Self {",
        "\t\tSelf {",
        "\t\t\tN,",
        "\t\t\tG: vec![vec![]; N],",
        "\t\t\tdp: vec![T::E; N],",
        "\t\t}",
        "\t}",
        "\t/// 辺`u`-`v`を追加する",
        "\tpub fn add_edge(&mut self, u: usize, v: usize) {",
        "\t\tself.G[u].push(v);",
        "\t\tself.G[v].push(u);",
        "\t}",
        "\t/// 頂点`start`に値を集約する",
        "\tpub fn aggregate(&mut self, start: usize) -> T::Val {",
        "\t\tlet NEG1 = 1_usize.wrapping_neg();",
        "\t\tSelf::dfs(NEG1, start, &self.G, &mut self.dp);",
        "\t\tself.dp[start].clone()",
        "\t}",
        "\tfn dfs(p: usize, u: usize, G: &Graph, dp: &mut Vec<T::Val>) {",
        "\t\t// 葉であるときの処理",
        "\t\tif G[u].len() == 1 && G[u][0] == p {",
        "\t\t\tdp[u] = T::E;",
        "\t\t\treturn;",
        "\t\t}",
        "\t\t// 子要素を集約する",
        "\t\tlet mut acc = T::E; // 子要素の累積",
        "\t\tfor &v in &G[u] {",
        "\t\t\tif v == p {",
        "\t\t\t\tcontinue;",
        "\t\t\t}",
        "\t\t\tSelf::dfs(u, v, G, dp);",
        "\t\t\tacc = T::op(&acc, &dp[v]);",
        "\t\t}",
        "\t\tdp[u] = T::apply(&acc);",
        "\t}",
        "}"
      ],
      "description": "木DP"
    },
    {
      "prefix": "multiset.rs",
      "body": [
        "use std::collections::BTreeMap;",
        "#[derive(Debug)]",
        "pub struct MultiSet<T> {",
        "\tpub map: BTreeMap<T, usize>,",
        "\tlen: usize,",
        "}",
        "impl<T> MultiSet<T>",
        "where",
        "\tT: Ord,",
        "{",
        "\t/// MultiSetを初期化する",
        "\tpub fn new() -> Self {",
        "\t\tMultiSet {",
        "\t\t\tmap: BTreeMap::new(),",
        "\t\t\tlen: 0,",
        "\t\t}",
        "\t}",
        "\t/// 要素`x`を追加する",
        "\tpub fn insert(&mut self, x: T) {",
        "\t\t*self.map.entry(x).or_insert(0) += 1;",
        "\t\tself.len += 1;",
        "\t}",
        "\t/// 要素`x`を削除する",
        "\tpub fn remove(&mut self, x: &T) -> bool {",
        "\t\tif let Some(v) = self.map.get_mut(x) {",
        "\t\t\t*v -= 1;",
        "\t\t\tif *v == 0 {",
        "\t\t\t\tself.map.remove(x);",
        "\t\t\t}",
        "\t\t\tself.len -= 1;",
        "\t\t\treturn true;",
        "\t\t}",
        "\t\tfalse",
        "\t}",
        "\t/// 要素`x`が存在するか判定する",
        "\tpub fn contains(&self, x: &T) -> bool {",
        "\t\tself.map.contains_key(x)",
        "\t}",
        "\t/// 先頭の要素を取得する",
        "\tpub fn first(&self) -> Option<&T> {",
        "\t\tself.map.keys().next()",
        "\t}",
        "\t/// 末尾の要素を取得する",
        "\tpub fn last(&self) -> Option<&T> {",
        "\t\tself.map.keys().last()",
        "\t}",
        "\t/// `x`の個数をカウントする",
        "\tpub fn count(&self, x: &T) -> usize {",
        "\t\tmatch self.map.get(x) {",
        "\t\t\tSome(&v) => v,",
        "\t\t\tNone => 0,",
        "\t\t}",
        "\t}",
        "\tpub fn len(&self) -> usize {",
        "\t\tself.len",
        "\t}",
        "\tpub fn is_empty(&self) -> bool {",
        "\t\tself.len == 0",
        "\t}",
        "}"
      ],
      "description": "多重集合"
    },
    {
      "prefix": "modint.rs",
      "body": [
        "#[rustfmt::skip]",
        "pub mod modint {",
        "\tuse std::{fmt::Display,ops::{Add, AddAssign, Div, Mul, MulAssign, Neg, Sub}, str::FromStr, num::ParseIntError};",
        "\t#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)] pub struct Modint<const MOD: usize>(pub usize);",
        "\timpl<const MOD: usize> Modint<MOD> { pub fn new(n: usize) -> Self { Self(if n < MOD { n } else { n % MOD }) } }",
        "\timpl<const MOD: usize> Neg for Modint<MOD> { type Output = Self; fn neg(self) -> Self { Modint(if self.0 == 0 { 0 } else { MOD - self.0 }) } }",
        "\timpl<const MOD: usize> Add for Modint<MOD> { type Output = Self; fn add(self, rhs: Self) -> Self { let mut res = self.0 + rhs.0; if res >= MOD { res -= MOD; } Modint(res) } }",
        "\timpl<const MOD: usize> Sub for Modint<MOD> { type Output = Self; fn sub(self, rhs: Self) -> Self { self + (- rhs) } }",
        "\timpl<const MOD: usize> Mul for Modint<MOD> { type Output = Self; fn mul(self, rhs: Self) -> Self { Modint(self.0 * rhs.0 % MOD) } }",
        "\timpl<const MOD: usize> Div for Modint<MOD> { type Output = Self; fn div(self, rhs: Self) -> Self { self * rhs.inv() } }",
        "\timpl<const MOD: usize> AddAssign for Modint<MOD> { fn add_assign(&mut self, rhs: Self) { self.0 = (*self + rhs).0 } }",
        "\timpl<const MOD: usize> MulAssign for Modint<MOD> { fn mul_assign(&mut self, rhs: Self) { self.0 = (*self * rhs).0 } }",
        "\timpl<const MOD: usize> From<usize> for Modint<MOD> { fn from(value: usize) -> Self { Modint::new(value) } }",
        "\timpl<const MOD: usize> Add<usize> for Modint<MOD> { type Output = Self; fn add(self, rhs: usize) -> Self { let mut res = self.0 + rhs; if res >= MOD {res -= MOD;} Modint(res) } }",
        "\timpl<const MOD: usize> Sub<usize> for Modint<MOD> { type Output = Self; fn sub(self, rhs: usize) -> Self { self - Modint::new(rhs) } }",
        "\timpl<const MOD: usize> Mul<usize> for Modint<MOD> { type Output = Self; fn mul(self, rhs: usize) -> Self { self * Modint::new(rhs) } }",
        "\timpl<const MOD: usize> Div<usize> for Modint<MOD> { type Output = Self; fn div(self, rhs: usize) -> Self { self / Modint::new(rhs) } }",
        "\timpl<const MOD: usize> AddAssign<usize> for Modint<MOD> { fn add_assign(&mut self, rhs: usize) { *self += Modint::new(rhs) } }",
        "\timpl<const MOD: usize> MulAssign<usize> for Modint<MOD> { fn mul_assign(&mut self, rhs: usize) { *self *= Modint::new(rhs) } }",
        "\timpl<const MOD: usize> Display for Modint<MOD> { fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, \"{}\", self.0) } }",
        "\timpl<const MOD: usize> PartialEq<usize> for Modint<MOD> { fn eq(&self, other: &usize) -> bool { self == &Modint::new(*other) } }",
        "\timpl<const MOD: usize> FromStr for Modint<MOD> { type Err = ParseIntError; fn from_str(s: &str) -> Result<Self, Self::Err> { usize::from_str(s).map(Modint::new) } }",
        "\tpub trait Fp { fn pow(&self, rhs: usize) -> Self; fn inv(&self) -> Self; }",
        "\timpl<const MOD: usize> Fp for Modint<MOD> { fn pow(&self, rhs: usize) -> Self { let (mut a, mut b) = (self.0, rhs); let mut res = 1; while b > 0 { if b & 1 == 1 { res = (res * a) % MOD; } a = (a * a) % MOD; b >>= 1u32; } Modint(res) } fn inv(&self) -> Self { self.pow(MOD - 2) } }",
        "}",
        "use modint::*;",
        "pub type Mod998 = Modint<998244353>;",
        "pub type Mod1e9 = Modint<1000000007>;"
      ],
      "description": "Modintの構造体"
    },
    {
      "prefix": "weighted_union_find.rs",
      "body": [
        "use std::fmt::Debug;",
        "/// ## アーベル群",
        "pub trait Abel {",
        "\ttype E: Debug + Clone;",
        "\tconst I: Self::E;",
        "\tfn op(x: &Self::E, y: &Self::E) -> Self::E;",
        "\tfn inv(x: &Self::E) -> Self::E;",
        "}",
        "/// # 重み付きUnionFind",
        "pub struct WeightedUnionFind<G: Abel> {",
        "\tpar: Vec<usize>,",
        "\trank: Vec<usize>,",
        "\tweight: Vec<G::E>,",
        "\tpub group_count: usize,",
        "}",
        "impl<G: Abel> WeightedUnionFind<G> {",
        "\t/// UnionFindを構築",
        "\tpub fn new(n: usize) -> Self {",
        "\t\tWeightedUnionFind {",
        "\t\t\tpar: (0..n).collect(),",
        "\t\t\trank: vec![1; n],",
        "\t\t\tweight: vec![G::I; n],",
        "\t\t\tgroup_count: n,",
        "\t\t}",
        "\t}",
        "\t/// 根を求める",
        "\tpub fn root(&mut self, x: usize) -> usize {",
        "\t\tif self.par[x] == x {",
        "\t\t\treturn x;",
        "\t\t}",
        "\t\tlet r = self.root(self.par[x]);",
        "\t\tlet parent = self.weight[self.par[x]].clone();",
        "\t\tlet child = self.weight.get_mut(x).unwrap();",
        "\t\t*child = G::op(child, &parent);",
        "\t\tself.par[x] = r; // 経路圧縮",
        "\t\tr",
        "\t}",
        "\t/// 重みを求める",
        "\tpub fn weight(&mut self, x: usize) -> G::E {",
        "\t\tself.root(x); // 経路圧縮",
        "\t\tself.weight[x].clone()",
        "\t}",
        "\t/// 同一の集合に所属するか判定",
        "\tpub fn issame(&mut self, x: usize, y: usize) -> bool {",
        "\t\tself.root(x) == self.root(y)",
        "\t}",
        "\t/// 重みの差を求める",
        "\t/// - 同じグループにいない場合にはNone",
        "\tpub fn diff(&mut self, x: usize, y: usize) -> Option<G::E> {",
        "\t\tif self.issame(x, y) {",
        "\t\t\tlet res = G::op(&self.weight(y), &G::inv(&self.weight(x)));",
        "\t\t\treturn Some(res);",
        "\t\t}",
        "\t\tNone",
        "\t}",
        "\t/// 要素を結合",
        "\tpub fn unite(&mut self, mut x: usize, mut y: usize, mut weight: G::E) -> bool {",
        "\t\t// x,yそれぞれについて重み差分を補正",
        "\t\tweight = G::op(&weight, &self.weight(x));",
        "\t\tweight = G::op(&weight, &G::inv(&self.weight(y)));",
        "\t\tx = self.root(x);",
        "\t\ty = self.root(y);",
        "\t\tif x == y {",
        "\t\t\treturn false;",
        "\t\t}",
        "\t\t// 要素数が大きい方を子にすることで、高さを均等に保つ",
        "\t\tif self.rank[x] < self.rank[y] {",
        "\t\t\tstd::mem::swap(&mut x, &mut y);",
        "\t\t\tweight = G::inv(&weight);",
        "\t\t}",
        "\t\tself.par[y] = x;",
        "\t\tself.rank[x] += self.rank[y];",
        "\t\tself.group_count -= 1;",
        "\t\t// 重みの更新",
        "\t\tself.weight[y] = weight;",
        "\t\ttrue",
        "\t}",
        "\tpub fn size(&mut self, x: usize) -> usize {",
        "\t\tlet root = self.root(x);",
        "\t\tself.rank[root]",
        "\t}",
        "}",
        "pub mod Alg {",
        "\tuse super::Abel;",
        "\tpub struct Add;",
        "\timpl Abel for Add {",
        "\t\ttype E = isize;",
        "\t\tconst I: Self::E = 0;",
        "\t\tfn op(x: &Self::E, y: &Self::E) -> Self::E {",
        "\t\t\tx + y",
        "\t\t}",
        "\t\tfn inv(x: &Self::E) -> Self::E {",
        "\t\t\t-x",
        "\t\t}",
        "\t}",
        "}"
      ],
      "description": "重み付きUnionFind"
    },
    {
      "prefix": "affine_transform.rs",
      "body": [
        "/// # AffineMatrix",
        "/// アフィン変換（3x3行列）",
        "#[derive(Debug, Clone, Copy)]",
        "pub struct AffineMatrix {",
        "\tarr: [[isize; 3]; 3],",
        "}",
        "impl AffineMatrix {",
        "\tpub fn e() -> Self {",
        "\t\tSelf {",
        "\t\t\tarr: [[1, 0, 0], [0, 1, 0], [0, 0, 1]],",
        "\t\t}",
        "\t}",
        "\tpub fn rotate90() -> Self {",
        "\t\tSelf {",
        "\t\t\tarr: [[0, -1, 0], [1, 0, 0], [0, 0, 1]],",
        "\t\t}",
        "\t}",
        "\tpub fn rotate270() -> Self {",
        "\t\tSelf {",
        "\t\t\tarr: [[0, 1, 0], [-1, 0, 0], [0, 0, 1]],",
        "\t\t}",
        "\t}",
        "\tpub fn mirror_x(p: isize) -> Self {",
        "\t\tSelf {",
        "\t\t\tarr: [[-1, 0, 2 * p], [0, 1, 0], [0, 0, 1]],",
        "\t\t}",
        "\t}",
        "\tpub fn mirror_y(p: isize) -> Self {",
        "\t\tSelf {",
        "\t\t\tarr: [[1, 0, 0], [0, -1, 2 * p], [0, 0, 1]],",
        "\t\t}",
        "\t}",
        "\tpub fn dot(&self, other: &Self) -> Self {",
        "\t\tlet mut arr = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];",
        "\t\tfor i in 0..3 {",
        "\t\t\tfor j in 0..3 {",
        "\t\t\t\tfor k in 0..3 {",
        "\t\t\t\t\tarr[i][j] += self.arr[i][k] * other.arr[k][j];",
        "\t\t\t\t}",
        "\t\t\t}",
        "\t\t}",
        "\t\tSelf { arr }",
        "\t}",
        "\tpub fn apply(&self, vec: (isize, isize)) -> (isize, isize) {",
        "\t\t(",
        "\t\t\tself.arr[0][0] * vec.0 + self.arr[0][1] * vec.1 + self.arr[0][2],",
        "\t\t\tself.arr[1][0] * vec.0 + self.arr[1][1] * vec.1 + self.arr[1][2],",
        "\t\t)",
        "\t}",
        "}"
      ],
      "description": "アフィン変換"
    },
    {
      "prefix": "lazy_segment_tree.rs",
      "body": [
        "use std::ops::{",
        "\tBound::{Excluded, Included, Unbounded},",
        "\tRangeBounds,",
        "};",
        "/// 作用付きモノイド",
        "pub trait ExtMonoid {",
        "\t/// 要素のデータ型",
        "\ttype X: Clone + PartialEq;",
        "\t/// 作用素のデータ型",
        "\ttype M: Clone + PartialEq;",
        "\t/// 要素Xの単位元",
        "\tconst IX: Self::X;",
        "\t/// 作用素Mの単位元",
        "\tconst IM: Self::M;",
        "\t/// 要素同士の演算",
        "\tfn operate_x(x: &Self::X, y: &Self::X) -> Self::X;",
        "\t/// 要素に対する作用",
        "\tfn apply(x: &Self::X, y: &Self::M) -> Self::X;",
        "\t/// 作用素同士の演算",
        "\tfn operate_m(x: &Self::M, y: &Self::M) -> Self::M;",
        "\t/// 作用素の集約",
        "\tfn aggregate(x: &Self::M, p: usize) -> Self::M;",
        "}",
        "/// 遅延評価セグメント木",
        "#[derive(Debug)]",
        "pub struct LazySegmentTree<T: ExtMonoid> {",
        "\tpub size: usize,",
        "\toffset: usize,",
        "\tdata: Vec<T::X>,",
        "\tlazy: Vec<T::M>,",
        "}",
        "impl<T: ExtMonoid> LazySegmentTree<T> {",
        "\t#[inline]",
        "\tfn parse_range<R: RangeBounds<usize>>(&self, range: R) -> Option<(usize, usize)> {",
        "\t\tlet start = match range.start_bound() {",
        "\t\t\tUnbounded => 0,",
        "\t\t\tExcluded(&v) => v + 1,",
        "\t\t\tIncluded(&v) => v,",
        "\t\t}",
        "\t\t.min(self.size);",
        "\t\tlet end = match range.end_bound() {",
        "\t\t\tUnbounded => self.size,",
        "\t\t\tExcluded(&v) => v,",
        "\t\t\tIncluded(&v) => v + 1,",
        "\t\t}",
        "\t\t.min(self.size);",
        "\t\tif start <= end {",
        "\t\t\tSome((start, end))",
        "\t\t} else {",
        "\t\t\tNone",
        "\t\t}",
        "\t}",
        "\t/// 遅延評価セグメント木を初期化する",
        "\t/// - `n`: 配列サイズ",
        "\tpub fn new(n: usize) -> Self {",
        "\t\tlet offset = n.next_power_of_two();",
        "\t\tSelf {",
        "\t\t\tsize: n,",
        "\t\t\toffset,",
        "\t\t\tdata: vec![T::IX; offset << 1],",
        "\t\t\tlazy: vec![T::IM; offset << 1],",
        "\t\t}",
        "\t}",
        "\t/// 遅延値を評価",
        "\tfn eval(&mut self, idx: usize, len: usize) {",
        "\t\tif self.lazy[idx] == T::IM {",
        "\t\t\treturn;",
        "\t\t}",
        "\t\t// 葉でなければ子に伝搬",
        "\t\tif idx < self.offset {",
        "\t\t\tself.lazy[idx * 2] = T::operate_m(&self.lazy[idx * 2], &self.lazy[idx]);",
        "\t\t\tself.lazy[idx * 2 + 1] = T::operate_m(&self.lazy[idx * 2 + 1], &self.lazy[idx]);",
        "\t\t}",
        "\t\t// 自身を更新",
        "\t\tself.data[idx] = T::apply(&self.data[idx], &T::aggregate(&self.lazy[idx], len));",
        "\t\tself.lazy[idx] = T::IM;",
        "\t}",
        "\t/// 区間に`val`を作用させる",
        "\t/// - `range`: `[left, right)`",
        "\tpub fn apply<R: RangeBounds<usize>>(&mut self, range: R, val: T::M) {",
        "\t\tif let Some((left, right)) = self.parse_range(range) {",
        "\t\t\tself.apply_inner(left, right, val, 0, self.offset, 1);",
        "\t\t}",
        "\t}",
        "\tfn apply_inner(",
        "\t\t&mut self,",
        "\t\tleft: usize,",
        "\t\tright: usize,",
        "\t\tval: T::M,",
        "\t\tbegin: usize,",
        "\t\tend: usize,",
        "\t\tidx: usize,",
        "\t) {",
        "\t\t// 遅延値を評価",
        "\t\tself.eval(idx, end - begin);",
        "\t\t// 区間を内包するとき",
        "\t\tif left <= begin && end <= right {",
        "\t\t\tself.lazy[idx] = T::operate_m(&self.lazy[idx], &val);",
        "\t\t\tself.eval(idx, end - begin);",
        "\t\t}",
        "\t\t// 区間が重なるとき",
        "\t\telse if left < end && begin < right {",
        "\t\t\tlet mid = (begin + end) / 2;",
        "\t\t\t// 左の子を更新",
        "\t\t\tself.apply_inner(left, right, val.clone(), begin, mid, idx * 2);",
        "\t\t\t// 右の子を更新",
        "\t\t\tself.apply_inner(left, right, val, mid, end, idx * 2 + 1);",
        "\t\t\t// 値を更新",
        "\t\t\tself.data[idx] = T::operate_x(&self.data[idx * 2], &self.data[idx * 2 + 1]);",
        "\t\t}",
        "\t}",
        "\t/// 区間を取得する",
        "\t/// - `range`: `[left, right)`",
        "\tpub fn get<R: RangeBounds<usize>>(&mut self, range: R) -> T::X {",
        "\t\tif let Some((left, right)) = self.parse_range(range) {",
        "\t\t\tself.get_inner(left, right, 0, self.offset, 1)",
        "\t\t} else {",
        "\t\t\tT::IX",
        "\t\t}",
        "\t}",
        "\tfn get_inner(",
        "\t\t&mut self,",
        "\t\tleft: usize,",
        "\t\tright: usize,",
        "\t\tbegin: usize,",
        "\t\tend: usize,",
        "\t\tidx: usize,",
        "\t) -> T::X {",
        "\t\t// 遅延値を評価",
        "\t\tself.eval(idx, end - begin);",
        "\t\t// 区間を含まない",
        "\t\tif end <= left || right <= begin {",
        "\t\t\tT::IX",
        "\t\t}",
        "\t\t// 区間を包含する",
        "\t\telse if left <= begin && end <= right {",
        "\t\t\tself.data[idx].clone()",
        "\t\t}",
        "\t\t// 区間が重なる",
        "\t\telse {",
        "\t\t\tlet mid = (begin + end) / 2;",
        "\t\t\tlet l_val = self.get_inner(left, right, begin, mid, idx * 2);",
        "\t\t\tlet r_val = self.get_inner(left, right, mid, end, idx * 2 + 1);",
        "\t\t\tT::operate_x(&l_val, &r_val)",
        "\t\t}",
        "\t}",
        "}",
        "impl<T: ExtMonoid> From<&Vec<T::X>> for LazySegmentTree<T> {",
        "\tfn from(src: &Vec<T::X>) -> Self {",
        "\t\tlet mut seg = Self::new(src.len());",
        "\t\tfor (i, v) in src.iter().enumerate() {",
        "\t\t\tseg.data[seg.offset + i] = v.clone();",
        "\t\t}",
        "\t\tfor i in (0..seg.offset).rev() {",
        "\t\t\tlet lch = i << 1;",
        "\t\t\tseg.data[i] = T::operate_x(&seg.data[lch], &seg.data[lch + 1]);",
        "\t\t}",
        "\t\tseg",
        "\t}",
        "}",
        "pub mod Alg {",
        "\tuse super::ExtMonoid;",
        "\t/// ## RSQandRAQ",
        "\t/// - 区間加算",
        "\t/// - 区間和",
        "\t#[derive(Debug)]",
        "\tpub struct RSQandRAQ;",
        "\timpl ExtMonoid for RSQandRAQ {",
        "\t\ttype X = isize;",
        "\t\ttype M = isize;",
        "\t\tconst IX: Self::X = 0;",
        "\t\tconst IM: Self::M = 0;",
        "\t\tfn operate_x(x: &Self::X, y: &Self::X) -> Self::X {",
        "\t\t\tx + y",
        "\t\t}",
        "\t\tfn apply(x: &Self::X, y: &Self::M) -> Self::X {",
        "\t\t\tx + y",
        "\t\t}",
        "\t\tfn operate_m(x: &Self::M, y: &Self::M) -> Self::M {",
        "\t\t\tx + y",
        "\t\t}",
        "\t\tfn aggregate(x: &Self::M, p: usize) -> Self::M {",
        "\t\t\tx * p as isize",
        "\t\t}",
        "\t}",
        "\t/// ## RMQandRUQ",
        "\t/// - 区間更新",
        "\t/// - 区間最小値",
        "\t#[derive(Debug)]",
        "\tpub struct RMQandRUQ;",
        "\timpl ExtMonoid for RMQandRUQ {",
        "\t\ttype X = isize;",
        "\t\ttype M = isize;",
        "\t\tconst IM: Self::M = (1 << 31) - 1;",
        "\t\tconst IX: Self::X = (1 << 31) - 1;",
        "\t\tfn operate_x(x: &Self::X, y: &Self::X) -> Self::X {",
        "\t\t\t*x.min(y)",
        "\t\t}",
        "\t\tfn apply(_x: &Self::X, y: &Self::M) -> Self::X {",
        "\t\t\t*y",
        "\t\t}",
        "\t\tfn operate_m(_x: &Self::M, y: &Self::M) -> Self::M {",
        "\t\t\t*y",
        "\t\t}",
        "\t\tfn aggregate(x: &Self::M, _p: usize) -> Self::M {",
        "\t\t\t*x",
        "\t\t}",
        "\t}",
        "\t/// ## RMQandRAQ",
        "\t/// - 区間加算",
        "\t/// - 区間最小値",
        "\t#[derive(Debug)]",
        "\tpub struct RMQandRAQ;",
        "\timpl ExtMonoid for RMQandRAQ {",
        "\t\ttype X = isize;",
        "\t\ttype M = isize;",
        "\t\tconst IM: Self::M = 0;",
        "\t\tconst IX: Self::X = 1 << 31;",
        "\t\tfn operate_x(x: &Self::X, y: &Self::X) -> Self::X {",
        "\t\t\t*x.min(y)",
        "\t\t}",
        "\t\tfn apply(x: &Self::X, y: &Self::M) -> Self::X {",
        "\t\t\tx + y",
        "\t\t}",
        "\t\tfn operate_m(x: &Self::M, y: &Self::M) -> Self::M {",
        "\t\t\tx + y",
        "\t\t}",
        "\t\tfn aggregate(x: &Self::M, _p: usize) -> Self::M {",
        "\t\t\t*x",
        "\t\t}",
        "\t}",
        "\t/// ## RSQandRUQ",
        "\t/// - 区間更新",
        "\t/// - 区間和取得",
        "\t#[derive(Debug)]",
        "\tpub struct RSQandRUQ;",
        "\timpl ExtMonoid for RSQandRUQ {",
        "\t\ttype X = isize;",
        "\t\ttype M = Option<isize>;",
        "\t\tconst IX: Self::X = 0;",
        "\t\tconst IM: Self::M = None;",
        "\t\tfn operate_x(x: &Self::X, y: &Self::X) -> Self::X {",
        "\t\t\tx + y",
        "\t\t}",
        "\t\tfn apply(_x: &Self::X, y: &Self::M) -> Self::X {",
        "\t\t\ty.unwrap()",
        "\t\t}",
        "\t\tfn operate_m(_x: &Self::M, y: &Self::M) -> Self::M {",
        "\t\t\t*y",
        "\t\t}",
        "\t\tfn aggregate(x: &Self::M, p: usize) -> Self::M {",
        "\t\t\tx.map(|x| x * p as isize)",
        "\t\t}",
        "\t}",
        "}"
      ],
      "description": "遅延評価セグメント木"
    },
    {
      "prefix": "segment_tree.rs",
      "body": [
        "use std::fmt;",
        "use std::ops::{",
        "\tBound::{Excluded, Included, Unbounded},",
        "\tDeref, DerefMut, Index, RangeBounds,",
        "};",
        "/// モノイド",
        "pub trait Monoid {",
        "\t/// 元の型",
        "\ttype Val: fmt::Debug + Clone + PartialEq;",
        "\t/// 単位元",
        "\tconst E: Self::Val;",
        "\t/// 演算",
        "\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val;",
        "}",
        "/// # SegmentTree (Monoid)",
        "/// - 抽象化セグメント木",
        "pub struct SegmentTree<T: Monoid> {",
        "\tpub size: usize,",
        "\toffset: usize,",
        "\tdata: Vec<T::Val>,",
        "}",
        "impl<T: Monoid> Index<usize> for SegmentTree<T> {",
        "\ttype Output = T::Val;",
        "\tfn index(&self, idx: usize) -> &Self::Output {",
        "\t\t&self.data[self.offset + idx]",
        "\t}",
        "}",
        "impl<T: Monoid> SegmentTree<T> {",
        "\t#[inline]",
        "\tfn parse_range<R: RangeBounds<usize>>(&self, range: R) -> Option<(usize, usize)> {",
        "\t\tlet start = match range.start_bound() {",
        "\t\t\tUnbounded => 0,",
        "\t\t\tExcluded(&v) => v + 1,",
        "\t\t\tIncluded(&v) => v,",
        "\t\t}",
        "\t\t.min(self.size);",
        "\t\tlet end = match range.end_bound() {",
        "\t\t\tUnbounded => self.size,",
        "\t\t\tExcluded(&v) => v,",
        "\t\t\tIncluded(&v) => v + 1,",
        "\t\t}",
        "\t\t.min(self.size);",
        "\t\tif start <= end {",
        "\t\t\tSome((start, end))",
        "\t\t} else {",
        "\t\t\tNone",
        "\t\t}",
        "\t}",
        "\t/// ## new",
        "\t/// セグメント木を初期化する",
        "\tpub fn new(n: usize) -> Self {",
        "\t\tlet offset = n.next_power_of_two();",
        "\t\tSelf {",
        "\t\t\tsize: n,",
        "\t\t\toffset,",
        "\t\t\tdata: vec![T::E; offset << 1],",
        "\t\t}",
        "\t}",
        "\tfn update(&mut self, index: usize, value: T::Val) {",
        "\t\tlet mut i = index + self.offset;",
        "\t\tself.data[i] = value;",
        "\t\twhile i > 1 {",
        "\t\t\ti >>= 1;",
        "\t\t\tlet lch = i << 1;",
        "\t\t\tself.data[i] = T::op(&self.data[lch], &self.data[lch + 1]);",
        "\t\t}",
        "\t}",
        "\t/// 可変な参照を返す",
        "\tpub fn get_mut(&mut self, i: usize) -> Option<ValMut<'_, T>> {",
        "\t\tif i < self.offset {",
        "\t\t\tlet default = self.index(i).clone();",
        "\t\t\tSome(ValMut {",
        "\t\t\t\tsegtree: self,",
        "\t\t\t\tidx: i,",
        "\t\t\t\tnew_val: default,",
        "\t\t\t})",
        "\t\t} else {",
        "\t\t\tNone",
        "\t\t}",
        "\t}",
        "\t/// 区間`range`の集約を行う",
        "\tpub fn get_range<R: RangeBounds<usize>>(&self, range: R) -> T::Val {",
        "\t\tlet parsed = self.parse_range(range);",
        "\t\tif parsed.is_none() {",
        "\t\t\treturn T::E;",
        "\t\t}",
        "\t\tlet (start, end) = parsed.unwrap();",
        "\t\t// 全体の値を取得",
        "\t\tif (start, end) == (0, self.size) {",
        "\t\t\treturn self.data[1].clone();",
        "\t\t}",
        "\t\t// 値の取得",
        "\t\tlet mut l = self.offset + start;",
        "\t\tlet mut r = self.offset + end;",
        "\t\tlet (mut res_l, mut res_r) = (T::E, T::E);",
        "\t\twhile l < r {",
        "\t\t\tif l & 1 == 1 {",
        "\t\t\t\tres_l = T::op(&res_l, &self.data[l]);",
        "\t\t\t\tl += 1;",
        "\t\t\t}",
        "\t\t\tif r & 1 == 1 {",
        "\t\t\t\tr -= 1;",
        "\t\t\t\tres_r = T::op(&self.data[r], &res_r);",
        "\t\t\t}",
        "\t\t\tl >>= 1;",
        "\t\t\tr >>= 1;",
        "\t\t}",
        "\t\tT::op(&res_l, &res_r)",
        "\t}",
        "}",
        "impl<T: Monoid> From<&Vec<T::Val>> for SegmentTree<T> {",
        "\tfn from(src: &Vec<T::Val>) -> Self {",
        "\t\tlet mut seg = Self::new(src.len());",
        "\t\tfor (i, v) in src.iter().enumerate() {",
        "\t\t\tseg.data[seg.offset + i] = v.clone();",
        "\t\t}",
        "\t\tfor i in (0..seg.offset).rev() {",
        "\t\t\tlet lch = i << 1;",
        "\t\t\tseg.data[i] = T::op(&seg.data[lch], &seg.data[lch + 1]);",
        "\t\t}",
        "\t\tseg",
        "\t}",
        "}",
        "impl<T: Monoid> std::fmt::Debug for SegmentTree<T> {",
        "\tfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
        "\t\twrite!(f, \"SegmentTree {{ [\").ok();",
        "\t\tfor i in 0..self.size {",
        "\t\t\tif i + 1 < self.size {",
        "\t\t\t\twrite!(f, \"{:?}, \", self.data[self.offset + i]).ok();",
        "\t\t\t} else {",
        "\t\t\t\twrite!(f, \"{:?}\", self.data[self.offset + i]).ok();",
        "\t\t\t}",
        "\t\t}",
        "\t\twrite!(f, \"] }}\")",
        "\t}",
        "}",
        "pub struct ValMut<'a, T: 'a + Monoid> {",
        "\tsegtree: &'a mut SegmentTree<T>,",
        "\tidx: usize,",
        "\tnew_val: T::Val,",
        "}",
        "impl<T: Monoid> fmt::Debug for ValMut<'_, T> {",
        "\tfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
        "\t\tf.debug_tuple(\"ValMut\")",
        "\t\t\t.field(&self.segtree.index(self.idx))",
        "\t\t\t.finish()",
        "\t}",
        "}",
        "impl<T: Monoid> Drop for ValMut<'_, T> {",
        "\tfn drop(&mut self) {",
        "\t\tself.segtree.update(self.idx, self.new_val.clone());",
        "\t}",
        "}",
        "impl<T: Monoid> Deref for ValMut<'_, T> {",
        "\ttype Target = T::Val;",
        "\tfn deref(&self) -> &Self::Target {",
        "\t\t&self.segtree[self.idx]",
        "\t}",
        "}",
        "impl<T: Monoid> DerefMut for ValMut<'_, T> {",
        "\tfn deref_mut(&mut self) -> &mut Self::Target {",
        "\t\t&mut self.new_val",
        "\t}",
        "}",
        "/// さまざまな代数的構造",
        "pub mod Alg {",
        "\tuse super::Monoid;",
        "\t/// 和",
        "\tpub struct Add;",
        "\timpl Monoid for Add {",
        "\t\ttype Val = isize;",
        "\t\tconst E: Self::Val = 0;",
        "\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
        "\t\t\tleft + right",
        "\t\t}",
        "\t}",
        "\t/// 積",
        "\tpub struct Mul;",
        "\timpl Monoid for Mul {",
        "\t\ttype Val = isize;",
        "\t\tconst E: Self::Val = 1;",
        "\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
        "\t\t\tleft * right",
        "\t\t}",
        "\t}",
        "\t/// bit単位の排他的論理和",
        "\tpub struct Xor;",
        "\timpl Monoid for Xor {",
        "\t\ttype Val = usize;",
        "\t\tconst E: Self::Val = 0;",
        "\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
        "\t\t\tleft ^ right",
        "\t\t}",
        "\t}",
        "\t/// 最小値",
        "\tpub struct Min;",
        "\timpl Monoid for Min {",
        "\t\ttype Val = isize;",
        "\t\tconst E: Self::Val = (1 << 31) - 1;",
        "\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
        "\t\t\t*left.min(right)",
        "\t\t}",
        "\t}",
        "\t/// 最大値",
        "\tpub struct Max;",
        "\timpl Monoid for Max {",
        "\t\ttype Val = isize;",
        "\t\tconst E: Self::Val = -((1 << 31) - 1);",
        "\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
        "\t\t\t*left.max(right)",
        "\t\t}",
        "\t}",
        "\t/// 最小公倍数",
        "\tpub struct GCD;",
        "\timpl Monoid for GCD {",
        "\t\ttype Val = usize;",
        "\t\tconst E: Self::Val = 0;",
        "\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
        "\t\t\tgcd(*left, *right)",
        "\t\t}",
        "\t}",
        "\tpub fn gcd(a: usize, b: usize) -> usize {",
        "\t\tif b == 0 {",
        "\t\t\ta",
        "\t\t} else {",
        "\t\t\tgcd(b, a % b)",
        "\t\t}",
        "\t}",
        "\t// /// あまりをとる積",
        "\t// pub struct ModMul;",
        "\t// impl Monoid for ModMul {",
        "\t//\t type Val = Modint<998244353>;",
        "\t//\t const E: Self::Val = Modint::<998244353>(1);",
        "\t//\t fn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
        "\t//\t\t *left * *right",
        "\t//\t }",
        "\t// }",
        "}"
      ],
      "description": "セグメント木"
    },
    {
      "prefix": "ord_chr.rs",
      "body": [
        "/// ## ord",
        "/// `A`を`0`とするascii文字(`A~Za~z`)のインデックスを返す",
        "pub fn ord(c: char) -> usize {",
        "\tlet a = 'A' as u32;",
        "\tlet c = c as u32;",
        "\t(c - a) as usize",
        "}",
        "/// ## chr",
        "/// `chr(0) = A`であるようなascii文字(`A~Za~z`)を返す",
        "pub fn chr(i: usize) -> char {",
        "\tlet a = 'A' as u32;",
        "\tchar::from_u32(a + i as u32).unwrap()",
        "}"
      ],
      "description": "`char`と`usize`の相互変換"
    },
    {
      "prefix": "segment_tree_mutable.rs",
      "body": [
        "use std::fmt::{self, Debug};",
        "use std::ops::{",
        "\tBound::{Excluded, Included, Unbounded},",
        "\tDeref, DerefMut, Index, RangeBounds,",
        "};",
        "/// # SegmentTree (Monoid)",
        "/// - 抽象化セグメント木",
        "pub struct SegmentTree<T, F>",
        "where",
        "\tT: Debug + Clone + PartialEq,",
        "\tF: Fn(&T, &T) -> T,",
        "{",
        "\tpub size: usize,",
        "\toffset: usize,",
        "\te: T,",
        "\top: F,",
        "\tdata: Vec<T>,",
        "}",
        "impl<T, F> Index<usize> for SegmentTree<T, F>",
        "where",
        "\tT: Debug + Clone + PartialEq,",
        "\tF: Fn(&T, &T) -> T,",
        "{",
        "\ttype Output = T;",
        "\tfn index(&self, idx: usize) -> &Self::Output {",
        "\t\t&self.data[self.offset + idx]",
        "\t}",
        "}",
        "impl<T, F> SegmentTree<T, F>",
        "where",
        "\tT: Debug + Clone + PartialEq,",
        "\tF: Fn(&T, &T) -> T,",
        "{",
        "\t#[inline]",
        "\tfn parse_range<R: RangeBounds<usize>>(&self, range: R) -> Option<(usize, usize)> {",
        "\t\tlet start = match range.start_bound() {",
        "\t\t\tUnbounded => 0,",
        "\t\t\tExcluded(&v) => v + 1,",
        "\t\t\tIncluded(&v) => v,",
        "\t\t}",
        "\t\t.min(self.size);",
        "\t\tlet end = match range.end_bound() {",
        "\t\t\tUnbounded => self.size,",
        "\t\t\tExcluded(&v) => v,",
        "\t\t\tIncluded(&v) => v + 1,",
        "\t\t}",
        "\t\t.min(self.size);",
        "\t\tif start <= end {",
        "\t\t\tSome((start, end))",
        "\t\t} else {",
        "\t\t\tNone",
        "\t\t}",
        "\t}",
        "\t/// セグメント木を初期化する",
        "\tpub fn new(n: usize, e: T, op: F) -> Self {",
        "\t\tlet offset = n.next_power_of_two();",
        "\t\tSelf {",
        "\t\t\tsize: n,",
        "\t\t\toffset,",
        "\t\t\te: e.clone(),",
        "\t\t\top,",
        "\t\t\tdata: vec![e; offset << 1],",
        "\t\t}",
        "\t}",
        "\t/// セグメント木を配列から初期化する",
        "\tpub fn build(src: &[T], e: T, op: F) -> Self {",
        "\t\tlet mut seg = Self::new(src.len(), e, op);",
        "\t\tfor (i, v) in src.iter().enumerate() {",
        "\t\t\tseg.data[seg.offset + i] = v.clone();",
        "\t\t}",
        "\t\tfor i in (0..seg.offset).rev() {",
        "\t\t\tlet lch = i << 1;",
        "\t\t\tseg.data[i] = (seg.op)(&seg.data[lch], &seg.data[lch + 1]);",
        "\t\t}",
        "\t\tseg",
        "\t}",
        "\tfn update(&mut self, index: usize, value: T) {",
        "\t\tlet mut i = index + self.offset;",
        "\t\tself.data[i] = value;",
        "\t\twhile i > 1 {",
        "\t\t\ti >>= 1;",
        "\t\t\tlet lch = i << 1;",
        "\t\t\tself.data[i] = (self.op)(&self.data[lch], &self.data[lch + 1]);",
        "\t\t}",
        "\t}",
        "\t/// 可変な参照を返す",
        "\tpub fn get_mut(&mut self, i: usize) -> Option<ValMut<'_, T, F>> {",
        "\t\tif i < self.offset {",
        "\t\t\tlet default = self.index(i).clone();",
        "\t\t\tSome(ValMut {",
        "\t\t\t\tsegtree: self,",
        "\t\t\t\tidx: i,",
        "\t\t\t\tnew_val: default,",
        "\t\t\t})",
        "\t\t} else {",
        "\t\t\tNone",
        "\t\t}",
        "\t}",
        "\t/// 区間`range`の集約を行う",
        "\tpub fn get_range<R: RangeBounds<usize>>(&self, range: R) -> T {",
        "\t\tlet parsed = self.parse_range(range);",
        "\t\tif parsed.is_none() {",
        "\t\t\treturn self.e.clone();",
        "\t\t}",
        "\t\tlet (start, end) = parsed.unwrap();",
        "\t\t// 全体の値を取得",
        "\t\tif (start, end) == (0, self.size) {",
        "\t\t\treturn self.data[1].clone();",
        "\t\t}",
        "\t\t// 値の取得",
        "\t\tlet mut l = self.offset + start;",
        "\t\tlet mut r = self.offset + end;",
        "\t\tlet (mut res_l, mut res_r) = (self.e.clone(), self.e.clone());",
        "\t\twhile l < r {",
        "\t\t\tif l & 1 == 1 {",
        "\t\t\t\tres_l = (self.op)(&res_l, &self.data[l]);",
        "\t\t\t\tl += 1;",
        "\t\t\t}",
        "\t\t\tif r & 1 == 1 {",
        "\t\t\t\tr -= 1;",
        "\t\t\t\tres_r = (self.op)(&self.data[r], &res_r);",
        "\t\t\t}",
        "\t\t\tl >>= 1;",
        "\t\t\tr >>= 1;",
        "\t\t}",
        "\t\t(self.op)(&res_l, &res_r)",
        "\t}",
        "}",
        "impl<T: Debug, F> std::fmt::Debug for SegmentTree<T, F>",
        "where",
        "\tT: Debug + Clone + PartialEq,",
        "\tF: Fn(&T, &T) -> T,",
        "{",
        "\tfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
        "\t\twrite!(f, \"SegmentTree {{ [\").ok();",
        "\t\tfor i in 0..self.size {",
        "\t\t\tif i + 1 < self.size {",
        "\t\t\t\twrite!(f, \"{:?}, \", self.data[self.offset + i]).ok();",
        "\t\t\t} else {",
        "\t\t\t\twrite!(f, \"{:?}\", self.data[self.offset + i]).ok();",
        "\t\t\t}",
        "\t\t}",
        "\t\twrite!(f, \"] }}\")",
        "\t}",
        "}",
        "pub struct ValMut<'a, T: 'a, F>",
        "where",
        "\tT: Debug + Clone + PartialEq,",
        "\tF: Fn(&T, &T) -> T,",
        "{",
        "\tsegtree: &'a mut SegmentTree<T, F>,",
        "\tidx: usize,",
        "\tnew_val: T,",
        "}",
        "impl<T: Debug, F> fmt::Debug for ValMut<'_, T, F>",
        "where",
        "\tT: Debug + Clone + PartialEq,",
        "\tF: Fn(&T, &T) -> T,",
        "{",
        "\tfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
        "\t\tf.debug_tuple(\"ValMut\")",
        "\t\t\t.field(&self.segtree.index(self.idx))",
        "\t\t\t.finish()",
        "\t}",
        "}",
        "impl<T, F> Drop for ValMut<'_, T, F>",
        "where",
        "\tT: Debug + Clone + PartialEq,",
        "\tF: Fn(&T, &T) -> T,",
        "{",
        "\tfn drop(&mut self) {",
        "\t\tself.segtree.update(self.idx, self.new_val.clone());",
        "\t}",
        "}",
        "impl<T, F> Deref for ValMut<'_, T, F>",
        "where",
        "\tT: Debug + Clone + PartialEq,",
        "\tF: Fn(&T, &T) -> T,",
        "{",
        "\ttype Target = T;",
        "\tfn deref(&self) -> &Self::Target {",
        "\t\t&self.segtree[self.idx]",
        "\t}",
        "}",
        "impl<T, F> DerefMut for ValMut<'_, T, F>",
        "where",
        "\tT: Debug + Clone + PartialEq,",
        "\tF: Fn(&T, &T) -> T,",
        "{",
        "\tfn deref_mut(&mut self) -> &mut Self::Target {",
        "\t\t&mut self.new_val",
        "\t}",
        "}"
      ],
      "description": "セグメント木"
    },
    {
      "prefix": "run_length.rs",
      "body": [
        "/// ## ランレングス圧縮",
        "/// - スライスからエンコードを行う",
        "pub fn run_length_encode<T>(arr: &[T]) -> Vec<(T, usize)>",
        "where",
        "\tT: PartialEq + Copy,",
        "{",
        "\tlet mut res = vec![];",
        "\tlet mut cur = arr[0];",
        "\tlet mut cnt = 1;",
        "\tfor &val in &arr[1..] {",
        "\t\tif val == cur {",
        "\t\t\tcnt += 1;",
        "\t\t} else {",
        "\t\t\tres.push((cur, cnt));",
        "\t\t\tcur = val;",
        "\t\t\tcnt = 1;",
        "\t\t}",
        "\t}",
        "\tlet last_elem = *arr.last().unwrap();",
        "\tres.push((last_elem, cnt));",
        "\tres",
        "}",
        "/// ## ランレングス圧縮 (from Iterator)",
        "/// - イテレータからエンコードを行う",
        "pub fn run_length_encode_from<T, I>(mut itr: I) -> Vec<(T, usize)>",
        "where",
        "\tT: PartialEq,",
        "\tI: Iterator<Item = T>,",
        "{",
        "\tlet mut res = vec![];",
        "\tlet mut cur = itr.next().unwrap();",
        "\tlet mut cnt = 1;",
        "\tfor val in itr {",
        "\t\tif val == cur {",
        "\t\t\tcnt += 1;",
        "\t\t} else {",
        "\t\t\tres.push((cur, cnt));",
        "\t\t\tcur = val;",
        "\t\t\tcnt = 1;",
        "\t\t}",
        "\t}",
        "\tres.push((cur, cnt));",
        "\tres",
        "}"
      ],
      "description": "ランレングス圧縮"
    },
    {
      "prefix": "bit.rs",
      "body": [
        "use std::{",
        "\tfmt::Debug,",
        "\tops::{",
        "\t\tBound::{Excluded, Included, Unbounded},",
        "\t\tRangeBounds,",
        "\t},",
        "};",
        "/// # Monoid",
        "/// - モノイド",
        "pub trait Monoid {",
        "\t/// 値の型",
        "\ttype Val: Debug + Clone + PartialEq;",
        "\t/// 単位元",
        "\tconst E: Self::Val;",
        "\t/// 演算",
        "\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val;",
        "}",
        "/// モノイドに対する逆元の実装",
        "pub trait InversableMonoid: Monoid {",
        "\tfn inv(val: &Self::Val) -> Self::Val;",
        "}",
        "/// モノイドに対する順序の実装",
        "pub trait OrderedMonoid: Monoid {",
        "\tfn lt(left: &Self::Val, right: &Self::Val) -> bool;",
        "\tfn le(left: &Self::Val, right: &Self::Val) -> bool;",
        "}",
        "/// # BinaryIndexedTree",
        "/// - `0-indexed`なインターフェースを持つBIT",
        "pub struct BIT<T: Monoid> {",
        "\tpub size: usize,",
        "\tarr: Vec<T::Val>,",
        "}",
        "impl<T: Monoid> BIT<T> {",
        "\t#[inline]",
        "\tfn lsb(x: usize) -> usize {",
        "\t\tx & x.wrapping_neg()",
        "\t}",
        "\t/// BITの初期化を行う",
        "\t/// - `n`: 列の長さ",
        "\tpub fn new(n: usize) -> Self {",
        "\t\tBIT {",
        "\t\t\tsize: n,",
        "\t\t\tarr: vec![T::E; n + 1],",
        "\t\t}",
        "\t}",
        "\t/// 一点加算を行う",
        "\t/// - `i`: 加算を行うインデックス（`0-indexed`）",
        "\t/// - `x`: 加算する値",
        "\tpub fn add(&mut self, mut i: usize, x: T::Val) {",
        "\t\ti += 1;",
        "\t\twhile i <= self.size {",
        "\t\t\tself.arr[i] = T::op(&self.arr[i], &x);",
        "\t\t\ti += Self::lsb(i);",
        "\t\t}",
        "\t}",
        "\t/// 先頭からの和を求める",
        "\t/// - `i`: 区間`[0,i)`に対しての総和（`0-indexed`）",
        "\tpub fn prefix_sum(&self, mut i: usize) -> T::Val {",
        "\t\tlet mut res = T::E;",
        "\t\twhile i != 0 {",
        "\t\t\tres = T::op(&res, &self.arr[i]);",
        "\t\t\ti -= Self::lsb(i);",
        "\t\t}",
        "\t\tres",
        "\t}",
        "}",
        "impl<T: InversableMonoid> BIT<T> {",
        "\t#[inline]",
        "\tfn parse_range<R: RangeBounds<usize>>(&self, range: R) -> Option<(usize, usize)> {",
        "\t\tlet start = match range.start_bound() {",
        "\t\t\tUnbounded => 0,",
        "\t\t\tExcluded(&v) => v + 1,",
        "\t\t\tIncluded(&v) => v,",
        "\t\t}",
        "\t\t.min(self.size);",
        "\t\tlet end = match range.end_bound() {",
        "\t\t\tUnbounded => self.size,",
        "\t\t\tExcluded(&v) => v,",
        "\t\t\tIncluded(&v) => v + 1,",
        "\t\t}",
        "\t\t.min(self.size);",
        "\t\tif start <= end {",
        "\t\t\tSome((start, end))",
        "\t\t} else {",
        "\t\t\tNone",
        "\t\t}",
        "\t}",
        "\t/// 任意の区間の和を求める",
        "\t/// - `range`: 区間を表すRangeオブジェクト",
        "\tfn sum<R: RangeBounds<usize>>(&self, range: R) -> T::Val {",
        "\t\tif let Some((i, j)) = self.parse_range(range) {",
        "\t\t\tT::op(&self.prefix_sum(j), &T::inv(&self.prefix_sum(i)))",
        "\t\t} else {",
        "\t\t\tT::E",
        "\t\t}",
        "\t}",
        "}",
        "impl<T: Monoid> From<&Vec<T::Val>> for BIT<T> {",
        "\t/// ベクターの参照からBITを作成",
        "\tfn from(src: &Vec<T::Val>) -> Self {",
        "\t\tlet size = src.len();",
        "\t\tlet mut arr = vec![T::E; size + 1];",
        "\t\tfor i in 1..=size {",
        "\t\t\tlet x = src[i - 1].clone();",
        "\t\t\tarr[i] = T::op(&arr[i], &x);",
        "\t\t\tlet j = i + Self::lsb(i);",
        "\t\t\tif j < size + 1 {",
        "\t\t\t\tarr[j] = T::op(&arr[j], &arr[i].clone());",
        "\t\t\t}",
        "\t\t}",
        "\t\tSelf { size, arr }",
        "\t}",
        "}",
        "impl<T: OrderedMonoid> BIT<T> {",
        "\t/// `lower_bound`/`upper_bound`を共通化した実装",
        "\tfn binary_search<F>(&self, w: T::Val, compare: F) -> usize",
        "\twhere",
        "\t\tF: Fn(&T::Val, &T::Val) -> bool,",
        "\t{",
        "\t\tlet mut sum = T::E;",
        "\t\tlet mut idx = 0;",
        "\t\tlet mut d = self.size.next_power_of_two() / 2;",
        "\t\twhile d != 0 {",
        "\t\t\tif idx + d <= self.size {",
        "\t\t\t\tlet nxt = T::op(&sum, &self.arr[idx + d]);",
        "\t\t\t\tif compare(&nxt, &w) {",
        "\t\t\t\t\tsum = nxt;",
        "\t\t\t\t\tidx += d;",
        "\t\t\t\t}",
        "\t\t\t}",
        "\t\t\td >>= 1;",
        "\t\t}",
        "\t\tidx",
        "\t}",
        "\t/// `a_0 + a_1 + ... + a_i >= w`となる最小の`i`を求める",
        "\tpub fn lower_bound(&self, w: T::Val) -> usize {",
        "\t\tself.binary_search(w, T::lt)",
        "\t}",
        "\t/// `a_0 + a_1 + ... + a_i > w`となる最小の`i`を求める",
        "\tpub fn upper_bound(&self, w: T::Val) -> usize {",
        "\t\tself.binary_search(w, T::le)",
        "\t}",
        "}",
        "impl<T: InversableMonoid> Debug for BIT<T> {",
        "\tfn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
        "\t\twrite!(f, \"BIT {{ [\")?;",
        "\t\tfor i in 0..self.size - 1 {",
        "\t\t\twrite!(f, \"{:?}, \", self.sum(i..i + 1))?;",
        "\t\t}",
        "\t\twrite!(f, \"{:?}] }}\", self.sum(self.size - 1..self.size))",
        "\t}",
        "}",
        "pub mod Alg {",
        "\tuse super::{InversableMonoid, Monoid, OrderedMonoid};",
        "\t#[derive(Debug)]",
        "\tpub struct Add;",
        "\timpl Monoid for Add {",
        "\t\ttype Val = isize;",
        "\t\tconst E: Self::Val = 0;",
        "\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
        "\t\t\tleft + right",
        "\t\t}",
        "\t}",
        "\timpl InversableMonoid for Add {",
        "\t\tfn inv(val: &Self::Val) -> Self::Val {",
        "\t\t\t-val",
        "\t\t}",
        "\t}",
        "\timpl OrderedMonoid for Add {",
        "\t\tfn lt(left: &Self::Val, right: &Self::Val) -> bool {",
        "\t\t\tleft < right",
        "\t\t}",
        "\t\tfn le(left: &Self::Val, right: &Self::Val) -> bool {",
        "\t\t\tleft <= right",
        "\t\t}",
        "\t}",
        "\t#[derive(Debug)]",
        "\tpub struct Mul;",
        "\timpl Monoid for Mul {",
        "\t\ttype Val = isize;",
        "\t\tconst E: Self::Val = 1;",
        "\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
        "\t\t\tleft + right",
        "\t\t}",
        "\t}",
        "\t#[derive(Debug)]",
        "\tpub struct Xor;",
        "\timpl Monoid for Xor {",
        "\t\ttype Val = usize;",
        "\t\tconst E: Self::Val = 0;",
        "\t\tfn op(left: &Self::Val, right: &Self::Val) -> Self::Val {",
        "\t\t\tleft ^ right",
        "\t\t}",
        "\t}",
        "\timpl InversableMonoid for Xor {",
        "\t\tfn inv(val: &Self::Val) -> Self::Val {",
        "\t\t\t*val",
        "\t\t}",
        "\t}",
        "}"
      ],
      "description": "BinaryIndexedTree / FenwickTree"
    },
    {
      "prefix": "matrix_exp.rs",
      "body": [
        "// 定数",
        "const MOD: usize = 998244353;",
        "/* 行列累乗 */",
        "pub const DIM: usize = 4;",
        "pub type Vec = [usize; DIM];",
        "pub type Matrix = [[usize; DIM]; DIM];",
        "pub trait MatrixExp {",
        "\t/// ## e",
        "\t/// 単位行列を返す",
        "\tfn e() -> Self;",
        "\t/// ## apply",
        "\t/// ベクトル`x`と行列`A`について、`Ax`を返す",
        "\tfn dot(&self, other: Self) -> Self;",
        "\t/// ## pow",
        "\t/// 行列の累乗を返す（繰り返し2乗法）",
        "\tfn pow(&self, e: usize) -> Self;",
        "\t/// ## dot",
        "\t/// 行列のドット積",
        "\tfn apply(&self, vec: Vec) -> Vec;",
        "}",
        "impl MatrixExp for Matrix {",
        "\tfn e() -> Self {",
        "\t\tlet mut res = [[0; DIM]; DIM];",
        "\t\tfor i in 0..DIM {",
        "\t\t\tres[i][i] = 1;",
        "\t\t}",
        "\t\tres",
        "\t}",
        "\tfn apply(&self, vec: Vec) -> Vec {",
        "\t\tlet mut res = [0; DIM];",
        "\t\tfor i in 0..DIM {",
        "\t\t\tfor j in 0..DIM {",
        "\t\t\t\tres[i] += self[i][j] * vec[j] % MOD;",
        "\t\t\t\tres[i] %= MOD;",
        "\t\t\t}",
        "\t\t}",
        "\t\tres",
        "\t}",
        "\tfn pow(&self, mut e: usize) -> Self {",
        "\t\tlet mut res = Self::e();",
        "\t\tlet mut tmp = *self;",
        "\t\twhile e > 0 {",
        "\t\t\tif e & 1 == 1 {",
        "\t\t\t\tres = tmp.dot(res);",
        "\t\t\t}",
        "\t\t\ttmp = tmp.dot(tmp);",
        "\t\t\te >>= 1;",
        "\t\t}",
        "\t\tres",
        "\t}",
        "\tfn dot(&self, other: Self) -> Self {",
        "\t\tlet mut res = [[0; DIM]; DIM];",
        "\t\tfor i in 0..DIM {",
        "\t\t\tfor j in 0..DIM {",
        "\t\t\t\tfor k in 0..DIM {",
        "\t\t\t\t\tres[i][j] += self[i][k] * other[k][j] % MOD;",
        "\t\t\t\t\tres[i][j] %= MOD;",
        "\t\t\t\t}",
        "\t\t\t}",
        "\t\t}",
        "\t\tres",
        "\t}",
        "}"
      ],
      "description": "行列累乗"
    },
    {
      "prefix": "acc2d.rs",
      "body": [
        "use num_traits::Num;",
        "/// ## acc2D",
        "/// - 2次元累積和を取る",
        "/// ### 戻り値",
        "/// - `|r_start, r_end, c_start, c_end|: (usize, usize, usize, usize) -> T`",
        "pub fn acc2D<T: Num + Copy>(array: &Vec<Vec<T>>) -> impl Fn(usize, usize, usize, usize) -> T {",
        "\tlet (H, W) = (array.len(), array[0].len());",
        "\tlet mut S = vec![vec![T::zero(); W + 1]; H + 1];",
        "\tfor i in 0..H {",
        "\t\tfor j in 0..W {",
        "\t\t\tS[i + 1][j + 1] = S[i][j + 1] + S[i + 1][j] - S[i][j] + array[i][j];",
        "\t\t}",
        "\t}",
        "\tmove |r_start: usize, r_end: usize, c_start: usize, c_end: usize| -> T {",
        "\t\tS[r_end][c_end] - S[r_end][c_start] - S[r_start][c_end] + S[r_start][c_start]",
        "\t}",
        "}"
      ],
      "description": "2次元累積和"
    },
    {
      "prefix": "chmax_chmin.rs",
      "body": [
        "/// `chmax!{x1, x2, ..., xn}`:`x1`,`x2`,...,`xn`のうち最大のものを、`x1`に代入する",
        "/// - 代入があったとき、`true`を返す",
        "#[macro_export]",
        "macro_rules! chmax {",
        "\t( \\$a:expr, \\$b:expr \\$(,)* ) => {{",
        "\t\tif \\$a < \\$b {",
        "\t\t\t\\$a = \\$b;",
        "\t\t\ttrue",
        "\t\t} else {",
        "\t\t\tfalse",
        "\t\t}",
        "\t}};",
        "\t( \\$a:expr, \\$b:expr, \\$c:expr \\$(,\\$other:expr)* \\$(,)* ) => {{",
        "\t\tchmax! {",
        "\t\t\t\\$a,",
        "\t\t\t(\\$b).max(\\$c)",
        "\t\t\t\\$(,\\$other)*",
        "\t\t}",
        "\t}}",
        "}",
        "/// `chmin!{x1, x2, ..., xn}`:`x1`,`x2`,...,`xn`のうち最小のものを、`x1`に代入する",
        "/// - 代入があったとき、`true`を返す",
        "#[macro_export]",
        "macro_rules! chmin {",
        "\t( \\$a:expr, \\$b:expr \\$(,)* ) => {{",
        "\t\tif \\$a > \\$b {",
        "\t\t\t\\$a = \\$b;",
        "\t\t\ttrue",
        "\t\t} else {",
        "\t\t\tfalse",
        "\t\t}",
        "\t}};",
        "\t( \\$a:expr, \\$b:expr, \\$c:expr \\$(,\\$other:expr)* \\$(,)* ) => {{",
        "\t\tchmin! {",
        "\t\t\t\\$a,",
        "\t\t\t(\\$b).min(\\$c)",
        "\t\t\t\\$(,\\$other)*",
        "\t\t}",
        "\t}};",
        "}"
      ],
      "description": "chmax/chminの実装"
    },
    {
      "prefix": "namori.rs",
      "body": [
        "use std::collections::VecDeque;",
        "pub type Graph = Vec<Vec<usize>>;",
        "/// # なもりグラフ",
        "/// - なもりグラフ（木に辺を1本加えたグラフ）を分解する",
        "#[derive(Debug)]",
        "pub struct Namori {",
        "\tpub N: usize,",
        "\tpub graph: Graph,",
        "\tpub forest: Graph,",
        "\tpub on_cycle: Vec<bool>,",
        "}",
        "impl Namori {",
        "\t/// 頂点数`N`のグラフを作成する",
        "\tpub fn new(N: usize) -> Self {",
        "\t\tSelf {",
        "\t\t\tN,",
        "\t\t\tgraph: vec![vec![]; N],",
        "\t\t\tforest: vec![vec![]; N],",
        "\t\t\ton_cycle: vec![true; N],",
        "\t\t}",
        "\t}",
        "\t/// 頂点`u`,`v`に辺を張る",
        "\tpub fn add_edge(&mut self, u: usize, v: usize) {",
        "\t\tself.graph[u].push(v);",
        "\t\tself.graph[v].push(u);",
        "\t}",
        "\t/// なもりグラフを分解し、",
        "\t/// - サイクルを取り除いた森",
        "\t/// - サイクル上の頂点",
        "\t///",
        "\t/// を求める",
        "\tpub fn decompose(&mut self) {",
        "\t\t// 葉を調べる",
        "\t\tlet mut degree = vec![0; self.N];",
        "\t\tlet mut leafs = VecDeque::new();",
        "\t\tlet mut visited = vec![false; self.N];",
        "\t\tfor i in 0..self.N {",
        "\t\t\tdegree[i] = self.graph[i].len(); // 次数を調べる",
        "\t\t\t\t\t\t\t\t\t\t\t // 次数が1の頂点を格納",
        "\t\t\tif degree[i] == 1 {",
        "\t\t\t\tleafs.push_back(i);",
        "\t\t\t\tvisited[i] = true;",
        "\t\t\t}",
        "\t\t}",
        "\t\t// 葉を辿って木に分解",
        "\t\twhile let Some(u) = leafs.pop_front() {",
        "\t\t\tself.on_cycle[u] = false;",
        "\t\t\tfor &v in &self.graph[u] {",
        "\t\t\t\tif visited[v] {",
        "\t\t\t\t\tcontinue;",
        "\t\t\t\t}",
        "\t\t\t\tdegree[v] -= 1;",
        "\t\t\t\t// 森に追加",
        "\t\t\t\tself.forest[u].push(v);",
        "\t\t\t\tself.forest[v].push(u);",
        "\t\t\t\tif degree[v] <= 1 {",
        "\t\t\t\t\tleafs.push_back(v);",
        "\t\t\t\t\tvisited[v] = true;",
        "\t\t\t\t}",
        "\t\t\t}",
        "\t\t}",
        "\t}",
        "}"
      ],
      "description": "なもりグラフの分解"
    },
    {
      "prefix": "loop_detection.rs",
      "body": [
        "use num_bigint::BigUint;",
        "use num_traits::{FromPrimitive, ToPrimitive, Zero};",
        "use std::ops::{Add, Mul, Sub};",
        "use std::{collections::HashMap, hash::Hash};",
        "pub struct Loop<T, V, F, G>",
        "where",
        "\tF: Fn(T) -> T,",
        "\tG: Fn(T) -> V,",
        "{",
        "\t/// ノードの移動を行う関数",
        "\tpub next: F,",
        "\t/// ノードから値を取り出す関数",
        "\tpub get_val: G,",
        "\t/// 始点となるノード",
        "\tpub begin: T,",
        "\t/// ループの長さ",
        "\tpub loop_len: usize,",
        "\t/// ループ開始時の値",
        "\tpub loop_begin: T,",
        "\t/// ループに到達するまでの移動回数",
        "\tpub loop_begin_idx: usize,",
        "\t/// ループ開始時までの累積",
        "\tpub before_loop_sum: V,",
        "\t/// ループ内での累積",
        "\tpub loop_sum: V,",
        "\t/// ループの途中の値",
        "\tvals: HashMap<T, (usize, V)>,",
        "}",
        "impl<T, V, F, G> Loop<T, V, F, G>",
        "where",
        "\tT: Copy + Hash + Eq,",
        "\tV: Copy + Zero + Add<Output = V> + Sub<Output = V> + Mul<usize, Output = V>,",
        "\tF: Fn(T) -> T,",
        "\tG: Fn(T) -> V,",
        "{",
        "\t/// ループを検出する",
        "\tpub fn build(begin: T, next: F, get_val: G) -> Self {",
        "\t\t// 初期化",
        "\t\tlet mut cur: T = begin;",
        "\t\tlet mut idx: usize = 0;",
        "\t\tlet mut sum: V = V::zero();",
        "\t\tlet mut vals: HashMap<T, (usize, V)> = HashMap::new();",
        "\t\t// ループ検出",
        "\t\twhile vals.get(&cur).is_none() {",
        "\t\t\tvals.insert(cur, (idx, sum));",
        "\t\t\tsum = sum + get_val(cur);",
        "\t\t\tcur = next(cur);",
        "\t\t\tidx += 1;",
        "\t\t}",
        "\t\t// ループの値を取り出す",
        "\t\tlet loop_begin = cur;",
        "\t\tlet (loop_begin_idx, before_loop_sum) = vals[&loop_begin];",
        "\t\tlet loop_len = idx - loop_begin_idx;",
        "\t\tlet loop_sum = sum - before_loop_sum;",
        "\t\t// 返す",
        "\t\tSelf {",
        "\t\t\tnext,",
        "\t\t\tget_val,",
        "\t\t\tbegin,",
        "\t\t\tloop_len,",
        "\t\t\tloop_begin,",
        "\t\t\tloop_begin_idx,",
        "\t\t\tbefore_loop_sum,",
        "\t\t\tloop_sum,",
        "\t\t\tvals,",
        "\t\t}",
        "\t}",
        "\tfn accumulate(&self, begin: T, n: usize) -> (T, V) {",
        "\t\tlet mut res = V::zero();",
        "\t\tlet mut cur = begin;",
        "\t\tfor _ in 0..n {",
        "\t\t\tres = res + (self.get_val)(cur);",
        "\t\t\tcur = (self.next)(cur);",
        "\t\t}",
        "\t\t(cur, res)",
        "\t}",
        "\t/// self.beginからn個後の頂点を取り出す",
        "\tpub fn get_nth_node_usize(&self, n: usize) -> T {",
        "\t\tif n < self.loop_begin_idx {",
        "\t\t\tself.accumulate(self.begin, n).0",
        "\t\t} else {",
        "\t\t\tlet loop_rem = (n - self.loop_begin_idx) % self.loop_len;",
        "\t\t\tself.accumulate(self.loop_begin, loop_rem).0",
        "\t\t}",
        "\t}",
        "\t/// self.beginからn個後の値を取り出す",
        "\tpub fn get_nth_val_usize(&self, n: usize) -> V {",
        "\t\tif n < self.loop_begin_idx {",
        "\t\t\tself.accumulate(self.begin, n).1",
        "\t\t} else {",
        "\t\t\tlet loop_rep = (n - self.loop_begin_idx) / self.loop_len;",
        "\t\t\tlet loop_rem = (n - self.loop_begin_idx) % self.loop_len;",
        "\t\t\tself.before_loop_sum",
        "\t\t\t\t+ self.loop_sum * loop_rep",
        "\t\t\t\t+ self.accumulate(self.loop_begin, loop_rem).1",
        "\t\t}",
        "\t}",
        "\t/// self.beginからn個後の値を取り出す",
        "\tpub fn get_nth_node_biguint(&self, n: BigUint) -> T {",
        "\t\tlet loop_begin_idx = BigUint::from_usize(self.loop_begin_idx).unwrap();",
        "\t\tif n < loop_begin_idx {",
        "\t\t\tlet n_usize = n.to_usize().unwrap();",
        "\t\t\tself.accumulate(self.begin, n_usize).0",
        "\t\t} else {",
        "\t\t\tlet loop_len = BigUint::from_usize(self.loop_len).unwrap();",
        "\t\t\tlet loop_rem = (n - loop_begin_idx) % loop_len;",
        "\t\t\tlet loop_rem = loop_rem.to_usize().unwrap();",
        "\t\t\tself.accumulate(self.loop_begin, loop_rem).0",
        "\t\t}",
        "\t}",
        "}"
      ],
      "description": "ループ検出"
    },
    {
      "prefix": "scc.rs",
      "body": [
        "type Graph = Vec<Vec<usize>>;",
        "/// ## SCC (強連結成分分解)",
        "/// - Strongly Conneected Components",
        "pub struct SCC {",
        "\tpub V: usize,",
        "\tpub E: usize,",
        "\tpub G: Graph,",
        "\trG: Graph,",
        "\tpub group_count: Option<usize>,",
        "\tpub components: Vec<usize>,",
        "\tpub DAG: Graph,",
        "}",
        "impl SCC {",
        "\tconst INF: usize = std::usize::MAX;",
        "\t/// 頂点`V`のグラフを構築する",
        "\tpub fn new(V: usize) -> Self {",
        "\t\tSelf {",
        "\t\t\tV,",
        "\t\t\tE: 0,",
        "\t\t\tG: vec![vec![]; V],",
        "\t\t\trG: vec![vec![]; V],",
        "\t\t\tgroup_count: None,",
        "\t\t\tcomponents: vec![],",
        "\t\t\tDAG: vec![],",
        "\t\t}",
        "\t}",
        "\t/// uからvへの有向辺を追加",
        "\tpub fn add_edge(&mut self, u: usize, v: usize) {",
        "\t\tself.E += 1;",
        "\t\tself.G[u].push(v);",
        "\t\tself.rG[v].push(u);",
        "\t}",
        "\t/// 強連結成分に分解する",
        "\tpub fn decompose(&mut self) {",
        "\t\t// 帰りがけ順で順序付け",
        "\t\tlet mut order = vec![];",
        "\t\tlet mut visited = vec![false; self.V];",
        "\t\tfor i in 0..self.V {",
        "\t\t\tSelf::dfs(i, &self.G, &mut order, &mut visited);",
        "\t\t}",
        "\t\t// 連結成分に分解",
        "\t\tlet mut group = 0;",
        "\t\tlet mut components = vec![Self::INF; self.V];",
        "\t\tfor &i in order.iter().rev() {",
        "\t\t\tif components[i] == Self::INF {",
        "\t\t\t\tSelf::rdfs(i, group, &self.rG, &mut components);",
        "\t\t\t\tgroup += 1;",
        "\t\t\t}",
        "\t\t}",
        "\t\t// DAGを構築",
        "\t\tlet mut DAG = vec![vec![]; group];",
        "\t\tfor i in 0..self.V {",
        "\t\t\tfor &j in &self.G[i] {",
        "\t\t\t\tlet (u, v) = (components[i], components[j]);",
        "\t\t\t\tif u != v {",
        "\t\t\t\t\tDAG[u].push(v);",
        "\t\t\t\t}",
        "\t\t\t}",
        "\t\t}",
        "\t\tself.group_count = Some(group);",
        "\t\tself.components = components;",
        "\t\tself.DAG = DAG;",
        "\t}",
        "\tfn dfs(u: usize, G: &Graph, order: &mut Vec<usize>, visited: &mut Vec<bool>) {",
        "\t\tif visited[u] {",
        "\t\t\treturn;",
        "\t\t}",
        "\t\tvisited[u] = true;",
        "\t\tfor &v in &G[u] {",
        "\t\t\tSelf::dfs(v, G, order, visited);",
        "\t\t}",
        "\t\torder.push(u);",
        "\t}",
        "\tfn rdfs(u: usize, group: usize, rG: &Graph, components: &mut Vec<usize>) {",
        "\t\tif components[u] != Self::INF {",
        "\t\t\treturn;",
        "\t\t}",
        "\t\tcomponents[u] = group;",
        "\t\tfor &v in &rG[u] {",
        "\t\t\tSelf::rdfs(v, group, rG, components);",
        "\t\t}",
        "\t}",
        "}"
      ],
      "description": "強連結成分分解"
    }
  ]
}